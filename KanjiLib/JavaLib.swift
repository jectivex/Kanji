import KanjiVM

public class java$io$Bits : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$io$Bits$ = java$io$Bits

public class java$io$BufferedInputStream : java$io$FilterInputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$BufferedInputStream_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$BufferedInputStream$.java$io$BufferedInputStream_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedInputStream_init_java$io$InputStream_I__V = constructor((JObjectType("java/io/InputStream"), jint.jniType))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: jint) throws {
        let jobj = try java$io$BufferedInputStream$.java$io$BufferedInputStream_init_java$io$InputStream_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$BufferedInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$BufferedInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$BufferedInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$BufferedInputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$BufferedInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$BufferedInputStream_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$BufferedInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$BufferedInputStream$ = java$io$BufferedInputStream

public class java$io$BufferedOutputStream : java$io$FilterOutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$BufferedOutputStream_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$BufferedOutputStream$.java$io$BufferedOutputStream_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedOutputStream_init_java$io$OutputStream_I__V = constructor((JObjectType("java/io/OutputStream"), jint.jniType))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: jint) throws {
        let jobj = try java$io$BufferedOutputStream$.java$io$BufferedOutputStream_init_java$io$OutputStream_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$BufferedOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$BufferedOutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
}

public typealias java$io$BufferedOutputStream$ = java$io$BufferedOutputStream

public class java$io$BufferedReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$BufferedReader_init_java$io$Reader_I__V = constructor((JObjectType("java/io/Reader"), jint.jniType))
    public convenience init!(_ a0: java$io$Reader?, _ a1: jint) throws {
        let jobj = try java$io$BufferedReader$.java$io$BufferedReader_init_java$io$Reader_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedReader_init_java$io$Reader__V = constructor((JObjectType("java/io/Reader")))
    public convenience init!(_ a0: java$io$Reader?) throws {
        let jobj = try java$io$BufferedReader$.java$io$BufferedReader_init_java$io$Reader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$BufferedReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$BufferedReader_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    public func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$BufferedReader$.java$io$BufferedReader_readLine__java$lang$String(jobj)())
    }

    private static let java$io$BufferedReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$BufferedReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$BufferedReader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$BufferedReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$BufferedReader_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$BufferedReader_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$BufferedReader_lines__java$util$stream$Stream = invoker("lines", returns: JObjectType("java/util/stream/Stream"))
    public func lines() throws -> java$util$stream$Stream? {
        return try java$util$stream$Stream$(jobj: java$io$BufferedReader$.java$io$BufferedReader_lines__java$util$stream$Stream(jobj)())
    }

}

public typealias java$io$BufferedReader$ = java$io$BufferedReader

public class java$io$BufferedWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$BufferedWriter_init_java$io$Writer__V = constructor((JObjectType("java/io/Writer")))
    public convenience init!(_ a0: java$io$Writer?) throws {
        let jobj = try java$io$BufferedWriter$.java$io$BufferedWriter_init_java$io$Writer__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedWriter_init_java$io$Writer_I__V = constructor((JObjectType("java/io/Writer"), jint.jniType))
    public convenience init!(_ a0: java$io$Writer?, _ a1: jint) throws {
        let jobj = try java$io$BufferedWriter$.java$io$BufferedWriter_init_java$io$Writer_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$BufferedWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$BufferedWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$BufferedWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$BufferedWriter_newLine__V = invoker("newLine", returns: JVoid.jniType)
    public func newLine() throws -> Void {
        return try java$io$BufferedWriter$.java$io$BufferedWriter_newLine__V(jobj)()
    }

    private static let java$io$BufferedWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$BufferedWriter_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$BufferedWriter$ = java$io$BufferedWriter

public class java$io$ByteArrayInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ByteArrayInputStream_init_AB__V = constructor((JArray(jbyte.jniType)))
    public convenience init!(_ a0: [jbyte]?) throws {
        let jobj = try java$io$ByteArrayInputStream$.java$io$ByteArrayInputStream_init_AB__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$ByteArrayInputStream_init_AB_I_I__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$io$ByteArrayInputStream$.java$io$ByteArrayInputStream_init_AB_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$io$ByteArrayInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$ByteArrayInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ByteArrayInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$ByteArrayInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$ByteArrayInputStream_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$ByteArrayInputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$ByteArrayInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$ByteArrayInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$ByteArrayInputStream$ = java$io$ByteArrayInputStream

public class java$io$ByteArrayOutputStream : java$io$OutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ByteArrayOutputStream_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$ByteArrayOutputStream_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$io$ByteArrayOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$ByteArrayOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ByteArrayOutputStream_writeTo_java$io$OutputStream__V = invoker("writeTo", returns: JVoid.jniType, arguments: (JObjectType("java/io/OutputStream")))
    public func writeTo(a0: java$io$OutputStream?) throws -> Void {
        return try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_writeTo_java$io$OutputStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ByteArrayOutputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_reset__V(jobj)()
    }

    private static let java$io$ByteArrayOutputStream_toByteArray__AB = invoker("toByteArray", returns: JArray(jbyte.jniType))
    public func toByteArray() throws -> [jbyte]? {
        return try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_toByteArray__AB(jobj)().jarrayToArray()
    }

    private static let java$io$ByteArrayOutputStream_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_size__I(jobj)()
    }

    private static let java$io$ByteArrayOutputStream_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$io$ByteArrayOutputStream_toString_java$lang$String__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func toString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_toString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$ByteArrayOutputStream_toString_I__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func toString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ByteArrayOutputStream$.java$io$ByteArrayOutputStream_toString_I__java$lang$String(jobj)(a0))
    }

    private static let java$io$ByteArrayOutputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$ByteArrayOutputStream$ = java$io$ByteArrayOutputStream

public class java$io$CharArrayReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$CharArrayReader_init_AC__V = constructor((JArray(jchar.jniType)))
    public convenience init!(_ a0: [jchar]?) throws {
        let jobj = try java$io$CharArrayReader$.java$io$CharArrayReader_init_AC__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$CharArrayReader_init_AC_I_I__V = constructor((JArray(jchar.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jchar]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$io$CharArrayReader$.java$io$CharArrayReader_init_AC_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$io$CharArrayReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$CharArrayReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$CharArrayReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$CharArrayReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$CharArrayReader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$CharArrayReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$CharArrayReader_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$CharArrayReader_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$CharArrayReader$ = java$io$CharArrayReader

public class java$io$CharArrayWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$CharArrayWriter_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$CharArrayWriter$.java$io$CharArrayWriter_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$CharArrayWriter_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$io$CharArrayWriter$.java$io$CharArrayWriter_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$io$CharArrayWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$CharArrayWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$CharArrayWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$CharArrayWriter_writeTo_java$io$Writer__V = invoker("writeTo", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer")))
    public func writeTo(a0: java$io$Writer?) throws -> Void {
        return try java$io$CharArrayWriter$.java$io$CharArrayWriter_writeTo_java$io$Writer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$CharArrayWriter_append_java$lang$CharSequence__java$io$CharArrayWriter = invoker("append", returns: JObjectType("java/io/CharArrayWriter"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$CharArrayWriter_append_java$lang$CharSequence_I_I__java$io$CharArrayWriter = invoker("append", returns: JObjectType("java/io/CharArrayWriter"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$CharArrayWriter_append_C__java$io$CharArrayWriter = invoker("append", returns: JObjectType("java/io/CharArrayWriter"), arguments: (jchar.jniType))
    private static let java$io$CharArrayWriter_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$io$CharArrayWriter$.java$io$CharArrayWriter_reset__V(jobj)()
    }

    private static let java$io$CharArrayWriter_toCharArray__AC = invoker("toCharArray", returns: JArray(jchar.jniType))
    public func toCharArray() throws -> [jchar]? {
        return try java$io$CharArrayWriter$.java$io$CharArrayWriter_toCharArray__AC(jobj)().jarrayToArray()
    }

    private static let java$io$CharArrayWriter_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$io$CharArrayWriter$.java$io$CharArrayWriter_size__I(jobj)()
    }

    private static let java$io$CharArrayWriter_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$io$CharArrayWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$CharArrayWriter_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$CharArrayWriter_append_C__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (jchar.jniType))
    private static let java$io$CharArrayWriter_append_java$lang$CharSequence_I_I__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$CharArrayWriter_append_java$lang$CharSequence__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$CharArrayWriter_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    private static let java$io$CharArrayWriter_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$CharArrayWriter_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
}

public typealias java$io$CharArrayWriter$ = java$io$CharArrayWriter

public class java$io$CharConversionException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$CharConversionException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$CharConversionException$.java$io$CharConversionException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$CharConversionException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$CharConversionException$.java$io$CharConversionException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$CharConversionException$ = java$io$CharConversionException

public protocol java$io$Closeable : java$lang$AutoCloseable {
    func close() throws -> Void
}

public class java$io$Closeable$ : java$lang$Object$, java$io$Closeable, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Closeable_close__V = invoker("close", returns: JVoid.jniType)
}

public extension java$io$Closeable {
    func close() throws -> Void {
        return try java$io$Closeable$.java$io$Closeable_close__V(jobj)()
    }

}

public final class java$io$Console : java$lang$Object$, java$io$Flushable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Console_writer__java$io$PrintWriter = invoker("writer", returns: JObjectType("java/io/PrintWriter"))
    public func writer() throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$io$Console$.java$io$Console_writer__java$io$PrintWriter(jobj)())
    }

    private static let java$io$Console_reader__java$io$Reader = invoker("reader", returns: JObjectType("java/io/Reader"))
    public func reader() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$io$Console$.java$io$Console_reader__java$io$Reader(jobj)())
    }

    private static let java$io$Console_format_java$lang$String_Ajava$lang$Object__java$io$Console = invoker("format", returns: JObjectType("java/io/Console"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$Console? {
        return try java$io$Console$(jobj: java$io$Console$.java$io$Console_format_java$lang$String_Ajava$lang$Object__java$io$Console(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$Console_printf_java$lang$String_Ajava$lang$Object__java$io$Console = invoker("printf", returns: JObjectType("java/io/Console"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func printf(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$Console? {
        return try java$io$Console$(jobj: java$io$Console$.java$io$Console_printf_java$lang$String_Ajava$lang$Object__java$io$Console(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$Console_readLine_java$lang$String_Ajava$lang$Object__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func readLine(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$Console$.java$io$Console_readLine_java$lang$String_Ajava$lang$Object__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$Console_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    public func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$Console$.java$io$Console_readLine__java$lang$String(jobj)())
    }

    private static let java$io$Console_readPassword_java$lang$String_Ajava$lang$Object__AC = invoker("readPassword", returns: JArray(jchar.jniType), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func readPassword(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> [jchar]? {
        return try java$io$Console$.java$io$Console_readPassword_java$lang$String_Ajava$lang$Object__AC(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil).jarrayToArray()
    }

    private static let java$io$Console_readPassword__AC = invoker("readPassword", returns: JArray(jchar.jniType))
    public func readPassword() throws -> [jchar]? {
        return try java$io$Console$.java$io$Console_readPassword__AC(jobj)().jarrayToArray()
    }

    private static let java$io$Console_flush__V = invoker("flush", returns: JVoid.jniType)
    public func flush() throws -> Void {
        return try java$io$Console$.java$io$Console_flush__V(jobj)()
    }

}

public typealias java$io$Console$ = java$io$Console

public protocol java$io$DataInput : JavaObject {
    func readFully(a0: [jbyte]?) throws -> Void
    func readFully(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void
    func skipBytes(a0: jint) throws -> jint
    func readBoolean() throws -> jboolean
    func readByte() throws -> jbyte
    func readUnsignedByte() throws -> jint
    func readShort() throws -> jshort
    func readUnsignedShort() throws -> jint
    func readChar() throws -> jchar
    func readInt() throws -> jint
    func readLong() throws -> jlong
    func readFloat() throws -> jfloat
    func readDouble() throws -> jdouble
    func readLine() throws -> java$lang$String?
    func readUTF() throws -> java$lang$String?
}

public class java$io$DataInput$ : java$lang$Object$, java$io$DataInput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$DataInput_readFully_AB__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$DataInput_readFully_AB_I_I__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$DataInput_skipBytes_I__I = invoker("skipBytes", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$io$DataInput_readBoolean__Z = invoker("readBoolean", returns: jboolean.jniType)
    private static let java$io$DataInput_readByte__B = invoker("readByte", returns: jbyte.jniType)
    private static let java$io$DataInput_readUnsignedByte__I = invoker("readUnsignedByte", returns: jint.jniType)
    private static let java$io$DataInput_readShort__S = invoker("readShort", returns: jshort.jniType)
    private static let java$io$DataInput_readUnsignedShort__I = invoker("readUnsignedShort", returns: jint.jniType)
    private static let java$io$DataInput_readChar__C = invoker("readChar", returns: jchar.jniType)
    private static let java$io$DataInput_readInt__I = invoker("readInt", returns: jint.jniType)
    private static let java$io$DataInput_readLong__J = invoker("readLong", returns: jlong.jniType)
    private static let java$io$DataInput_readFloat__F = invoker("readFloat", returns: jfloat.jniType)
    private static let java$io$DataInput_readDouble__D = invoker("readDouble", returns: jdouble.jniType)
    private static let java$io$DataInput_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    private static let java$io$DataInput_readUTF__java$lang$String = invoker("readUTF", returns: JObjectType("java/lang/String"))
}

public extension java$io$DataInput {
    func readFully(a0: [jbyte]?) throws -> Void {
        return try java$io$DataInput$.java$io$DataInput_readFully_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    func readFully(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$DataInput$.java$io$DataInput_readFully_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    func skipBytes(a0: jint) throws -> jint {
        return try java$io$DataInput$.java$io$DataInput_skipBytes_I__I(jobj)(a0)
    }

    func readBoolean() throws -> jboolean {
        return try java$io$DataInput$.java$io$DataInput_readBoolean__Z(jobj)()
    }

    func readByte() throws -> jbyte {
        return try java$io$DataInput$.java$io$DataInput_readByte__B(jobj)()
    }

    func readUnsignedByte() throws -> jint {
        return try java$io$DataInput$.java$io$DataInput_readUnsignedByte__I(jobj)()
    }

    func readShort() throws -> jshort {
        return try java$io$DataInput$.java$io$DataInput_readShort__S(jobj)()
    }

    func readUnsignedShort() throws -> jint {
        return try java$io$DataInput$.java$io$DataInput_readUnsignedShort__I(jobj)()
    }

    func readChar() throws -> jchar {
        return try java$io$DataInput$.java$io$DataInput_readChar__C(jobj)()
    }

    func readInt() throws -> jint {
        return try java$io$DataInput$.java$io$DataInput_readInt__I(jobj)()
    }

    func readLong() throws -> jlong {
        return try java$io$DataInput$.java$io$DataInput_readLong__J(jobj)()
    }

    func readFloat() throws -> jfloat {
        return try java$io$DataInput$.java$io$DataInput_readFloat__F(jobj)()
    }

    func readDouble() throws -> jdouble {
        return try java$io$DataInput$.java$io$DataInput_readDouble__D(jobj)()
    }

    func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$DataInput$.java$io$DataInput_readLine__java$lang$String(jobj)())
    }

    func readUTF() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$DataInput$.java$io$DataInput_readUTF__java$lang$String(jobj)())
    }

}

public class java$io$DataInputStream : java$io$FilterInputStream$, java$io$DataInput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$DataInputStream_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$DataInputStream$.java$io$DataInputStream_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$DataInputStream_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$DataInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$DataInputStream_readFully_AB__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func readFully(a0: [jbyte]?) throws -> Void {
        return try java$io$DataInputStream$.java$io$DataInputStream_readFully_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$DataInputStream_readFully_AB_I_I__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func readFully(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$DataInputStream$.java$io$DataInputStream_readFully_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$DataInputStream_skipBytes_I__I = invoker("skipBytes", returns: jint.jniType, arguments: (jint.jniType))
    public func skipBytes(a0: jint) throws -> jint {
        return try java$io$DataInputStream$.java$io$DataInputStream_skipBytes_I__I(jobj)(a0)
    }

    private static let java$io$DataInputStream_readBoolean__Z = invoker("readBoolean", returns: jboolean.jniType)
    public func readBoolean() throws -> jboolean {
        return try java$io$DataInputStream$.java$io$DataInputStream_readBoolean__Z(jobj)()
    }

    private static let java$io$DataInputStream_readByte__B = invoker("readByte", returns: jbyte.jniType)
    public func readByte() throws -> jbyte {
        return try java$io$DataInputStream$.java$io$DataInputStream_readByte__B(jobj)()
    }

    private static let java$io$DataInputStream_readUnsignedByte__I = invoker("readUnsignedByte", returns: jint.jniType)
    public func readUnsignedByte() throws -> jint {
        return try java$io$DataInputStream$.java$io$DataInputStream_readUnsignedByte__I(jobj)()
    }

    private static let java$io$DataInputStream_readShort__S = invoker("readShort", returns: jshort.jniType)
    public func readShort() throws -> jshort {
        return try java$io$DataInputStream$.java$io$DataInputStream_readShort__S(jobj)()
    }

    private static let java$io$DataInputStream_readUnsignedShort__I = invoker("readUnsignedShort", returns: jint.jniType)
    public func readUnsignedShort() throws -> jint {
        return try java$io$DataInputStream$.java$io$DataInputStream_readUnsignedShort__I(jobj)()
    }

    private static let java$io$DataInputStream_readChar__C = invoker("readChar", returns: jchar.jniType)
    public func readChar() throws -> jchar {
        return try java$io$DataInputStream$.java$io$DataInputStream_readChar__C(jobj)()
    }

    private static let java$io$DataInputStream_readInt__I = invoker("readInt", returns: jint.jniType)
    public func readInt() throws -> jint {
        return try java$io$DataInputStream$.java$io$DataInputStream_readInt__I(jobj)()
    }

    private static let java$io$DataInputStream_readLong__J = invoker("readLong", returns: jlong.jniType)
    public func readLong() throws -> jlong {
        return try java$io$DataInputStream$.java$io$DataInputStream_readLong__J(jobj)()
    }

    private static let java$io$DataInputStream_readFloat__F = invoker("readFloat", returns: jfloat.jniType)
    public func readFloat() throws -> jfloat {
        return try java$io$DataInputStream$.java$io$DataInputStream_readFloat__F(jobj)()
    }

    private static let java$io$DataInputStream_readDouble__D = invoker("readDouble", returns: jdouble.jniType)
    public func readDouble() throws -> jdouble {
        return try java$io$DataInputStream$.java$io$DataInputStream_readDouble__D(jobj)()
    }

    private static let java$io$DataInputStream_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    public func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$DataInputStream$.java$io$DataInputStream_readLine__java$lang$String(jobj)())
    }

    private static let java$io$DataInputStream_readUTF__java$lang$String = invoker("readUTF", returns: JObjectType("java/lang/String"))
    public func readUTF() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$DataInputStream$.java$io$DataInputStream_readUTF__java$lang$String(jobj)())
    }

    private static let java$io$DataInputStream_readUTF_java$io$DataInput__java$lang$String = svoker("readUTF", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/io/DataInput")))
    public static func readUTF(a0: java$io$DataInput?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$DataInputStream$.java$io$DataInputStream_readUTF_java$io$DataInput__java$lang$String(a0?.jobj ?? nil))
    }

}

public typealias java$io$DataInputStream$ = java$io$DataInputStream

public protocol java$io$DataOutput : JavaObject {
    func write(a0: jint) throws -> Void
    func write(a0: [jbyte]?) throws -> Void
    func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void
    func writeBoolean(a0: jboolean) throws -> Void
    func writeByte(a0: jint) throws -> Void
    func writeShort(a0: jint) throws -> Void
    func writeChar(a0: jint) throws -> Void
    func writeInt(a0: jint) throws -> Void
    func writeLong(a0: jlong) throws -> Void
    func writeFloat(a0: jfloat) throws -> Void
    func writeDouble(a0: jdouble) throws -> Void
    func writeBytes(a0: java$lang$String?) throws -> Void
    func writeChars(a0: java$lang$String?) throws -> Void
    func writeUTF(a0: java$lang$String?) throws -> Void
}

public class java$io$DataOutput$ : java$lang$Object$, java$io$DataOutput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$DataOutput_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutput_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$DataOutput_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$DataOutput_writeBoolean_Z__V = invoker("writeBoolean", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$io$DataOutput_writeByte_I__V = invoker("writeByte", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutput_writeShort_I__V = invoker("writeShort", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutput_writeChar_I__V = invoker("writeChar", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutput_writeInt_I__V = invoker("writeInt", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutput_writeLong_J__V = invoker("writeLong", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$io$DataOutput_writeFloat_F__V = invoker("writeFloat", returns: JVoid.jniType, arguments: (jfloat.jniType))
    private static let java$io$DataOutput_writeDouble_D__V = invoker("writeDouble", returns: JVoid.jniType, arguments: (jdouble.jniType))
    private static let java$io$DataOutput_writeBytes_java$lang$String__V = invoker("writeBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$DataOutput_writeChars_java$lang$String__V = invoker("writeChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$DataOutput_writeUTF_java$lang$String__V = invoker("writeUTF", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
}

public extension java$io$DataOutput {
    func write(a0: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_write_I__V(jobj)(a0)
    }

    func write(a0: [jbyte]?) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_write_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_write_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    func writeBoolean(a0: jboolean) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeBoolean_Z__V(jobj)(a0)
    }

    func writeByte(a0: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeByte_I__V(jobj)(a0)
    }

    func writeShort(a0: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeShort_I__V(jobj)(a0)
    }

    func writeChar(a0: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeChar_I__V(jobj)(a0)
    }

    func writeInt(a0: jint) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeInt_I__V(jobj)(a0)
    }

    func writeLong(a0: jlong) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeLong_J__V(jobj)(a0)
    }

    func writeFloat(a0: jfloat) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeFloat_F__V(jobj)(a0)
    }

    func writeDouble(a0: jdouble) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeDouble_D__V(jobj)(a0)
    }

    func writeBytes(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeBytes_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func writeChars(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeChars_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func writeUTF(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutput$.java$io$DataOutput_writeUTF_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$io$DataOutputStream : java$io$FilterOutputStream$, java$io$DataOutput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$DataOutputStream_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$DataOutputStream$.java$io$DataOutputStream_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$DataOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$DataOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$DataOutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$DataOutputStream_writeBoolean_Z__V = invoker("writeBoolean", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func writeBoolean(a0: jboolean) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeBoolean_Z__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeByte_I__V = invoker("writeByte", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeByte(a0: jint) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeByte_I__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeShort_I__V = invoker("writeShort", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeShort(a0: jint) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeShort_I__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeChar_I__V = invoker("writeChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeChar(a0: jint) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeChar_I__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeInt_I__V = invoker("writeInt", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeInt(a0: jint) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeInt_I__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeLong_J__V = invoker("writeLong", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func writeLong(a0: jlong) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeLong_J__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeFloat_F__V = invoker("writeFloat", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func writeFloat(a0: jfloat) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeFloat_F__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeDouble_D__V = invoker("writeDouble", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func writeDouble(a0: jdouble) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeDouble_D__V(jobj)(a0)
    }

    private static let java$io$DataOutputStream_writeBytes_java$lang$String__V = invoker("writeBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeBytes(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeBytes_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$DataOutputStream_writeChars_java$lang$String__V = invoker("writeChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeChars(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeChars_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$DataOutputStream_writeUTF_java$lang$String__V = invoker("writeUTF", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeUTF(a0: java$lang$String?) throws -> Void {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_writeUTF_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$DataOutputStream_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$io$DataOutputStream$.java$io$DataOutputStream_size__I(jobj)()
    }

}

public typealias java$io$DataOutputStream$ = java$io$DataOutputStream

public class java$io$DefaultFileSystem : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$DefaultFileSystem_getFileSystem__java$io$FileSystem = svoker("getFileSystem", returns: JObjectType("java/io/FileSystem"))
    public static func getFileSystem() throws -> java$io$FileSystem? {
        return try java$io$FileSystem$(jobj: java$io$DefaultFileSystem$.java$io$DefaultFileSystem_getFileSystem__java$io$FileSystem())
    }

}

public typealias java$io$DefaultFileSystem$ = java$io$DefaultFileSystem

public class java$io$DeleteOnExitHook : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$io$DeleteOnExitHook$ = java$io$DeleteOnExitHook

public class java$io$EOFException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$EOFException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$EOFException$.java$io$EOFException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$EOFException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$EOFException$.java$io$EOFException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$EOFException$ = java$io$EOFException

public class java$io$ExpiringCache : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$io$ExpiringCache$ = java$io$ExpiringCache

public protocol java$io$Externalizable : java$io$Serializable {
    func writeExternal(a0: java$io$ObjectOutput?) throws -> Void
    func readExternal(a0: java$io$ObjectInput?) throws -> Void
}

public class java$io$Externalizable$ : java$lang$Object$, java$io$Externalizable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Externalizable_writeExternal_java$io$ObjectOutput__V = invoker("writeExternal", returns: JVoid.jniType, arguments: (JObjectType("java/io/ObjectOutput")))
    private static let java$io$Externalizable_readExternal_java$io$ObjectInput__V = invoker("readExternal", returns: JVoid.jniType, arguments: (JObjectType("java/io/ObjectInput")))
}

public extension java$io$Externalizable {
    func writeExternal(a0: java$io$ObjectOutput?) throws -> Void {
        return try java$io$Externalizable$.java$io$Externalizable_writeExternal_java$io$ObjectOutput__V(jobj)(a0?.jobj ?? nil)
    }

    func readExternal(a0: java$io$ObjectInput?) throws -> Void {
        return try java$io$Externalizable$.java$io$Externalizable_readExternal_java$io$ObjectInput__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$io$File : java$lang$Object$, java$io$Serializable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$File_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$File$.java$io$File_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$File_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$File$.java$io$File_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$File_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$File$.java$io$File_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$File_init_java$net$URI__V = constructor((JObjectType("java/net/URI")))
    public convenience init!(_ a0: java$net$URI?) throws {
        let jobj = try java$io$File$.java$io$File_init_java$net$URI__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$File_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$File$.java$io$File_getName__java$lang$String(jobj)())
    }

    private static let java$io$File_getParent__java$lang$String = invoker("getParent", returns: JObjectType("java/lang/String"))
    public func getParent() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$File$.java$io$File_getParent__java$lang$String(jobj)())
    }

    private static let java$io$File_getParentFile__java$io$File = invoker("getParentFile", returns: JObjectType("java/io/File"))
    public func getParentFile() throws -> java$io$File? {
        return try java$io$File$(jobj: java$io$File$.java$io$File_getParentFile__java$io$File(jobj)())
    }

    private static let java$io$File_getPath__java$lang$String = invoker("getPath", returns: JObjectType("java/lang/String"))
    public func getPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$File$.java$io$File_getPath__java$lang$String(jobj)())
    }

    private static let java$io$File_isAbsolute__Z = invoker("isAbsolute", returns: jboolean.jniType)
    public func isAbsolute() throws -> jboolean {
        return try java$io$File$.java$io$File_isAbsolute__Z(jobj)()
    }

    private static let java$io$File_getAbsolutePath__java$lang$String = invoker("getAbsolutePath", returns: JObjectType("java/lang/String"))
    public func getAbsolutePath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$File$.java$io$File_getAbsolutePath__java$lang$String(jobj)())
    }

    private static let java$io$File_getAbsoluteFile__java$io$File = invoker("getAbsoluteFile", returns: JObjectType("java/io/File"))
    public func getAbsoluteFile() throws -> java$io$File? {
        return try java$io$File$(jobj: java$io$File$.java$io$File_getAbsoluteFile__java$io$File(jobj)())
    }

    private static let java$io$File_getCanonicalPath__java$lang$String = invoker("getCanonicalPath", returns: JObjectType("java/lang/String"))
    public func getCanonicalPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$File$.java$io$File_getCanonicalPath__java$lang$String(jobj)())
    }

    private static let java$io$File_getCanonicalFile__java$io$File = invoker("getCanonicalFile", returns: JObjectType("java/io/File"))
    public func getCanonicalFile() throws -> java$io$File? {
        return try java$io$File$(jobj: java$io$File$.java$io$File_getCanonicalFile__java$io$File(jobj)())
    }

    private static let java$io$File_toURL__java$net$URL = invoker("toURL", returns: JObjectType("java/net/URL"))
    public func toURL() throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$io$File$.java$io$File_toURL__java$net$URL(jobj)())
    }

    private static let java$io$File_toURI__java$net$URI = invoker("toURI", returns: JObjectType("java/net/URI"))
    public func toURI() throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$io$File$.java$io$File_toURI__java$net$URI(jobj)())
    }

    private static let java$io$File_canRead__Z = invoker("canRead", returns: jboolean.jniType)
    public func canRead() throws -> jboolean {
        return try java$io$File$.java$io$File_canRead__Z(jobj)()
    }

    private static let java$io$File_canWrite__Z = invoker("canWrite", returns: jboolean.jniType)
    public func canWrite() throws -> jboolean {
        return try java$io$File$.java$io$File_canWrite__Z(jobj)()
    }

    private static let java$io$File_exists__Z = invoker("exists", returns: jboolean.jniType)
    public func exists() throws -> jboolean {
        return try java$io$File$.java$io$File_exists__Z(jobj)()
    }

    private static let java$io$File_isDirectory__Z = invoker("isDirectory", returns: jboolean.jniType)
    public func isDirectory() throws -> jboolean {
        return try java$io$File$.java$io$File_isDirectory__Z(jobj)()
    }

    private static let java$io$File_isFile__Z = invoker("isFile", returns: jboolean.jniType)
    public func isFile() throws -> jboolean {
        return try java$io$File$.java$io$File_isFile__Z(jobj)()
    }

    private static let java$io$File_isHidden__Z = invoker("isHidden", returns: jboolean.jniType)
    public func isHidden() throws -> jboolean {
        return try java$io$File$.java$io$File_isHidden__Z(jobj)()
    }

    private static let java$io$File_lastModified__J = invoker("lastModified", returns: jlong.jniType)
    public func lastModified() throws -> jlong {
        return try java$io$File$.java$io$File_lastModified__J(jobj)()
    }

    private static let java$io$File_length__J = invoker("length", returns: jlong.jniType)
    public func length() throws -> jlong {
        return try java$io$File$.java$io$File_length__J(jobj)()
    }

    private static let java$io$File_createNewFile__Z = invoker("createNewFile", returns: jboolean.jniType)
    public func createNewFile() throws -> jboolean {
        return try java$io$File$.java$io$File_createNewFile__Z(jobj)()
    }

    private static let java$io$File_delete__Z = invoker("delete", returns: jboolean.jniType)
    public func delete() throws -> jboolean {
        return try java$io$File$.java$io$File_delete__Z(jobj)()
    }

    private static let java$io$File_deleteOnExit__V = invoker("deleteOnExit", returns: JVoid.jniType)
    public func deleteOnExit() throws -> Void {
        return try java$io$File$.java$io$File_deleteOnExit__V(jobj)()
    }

    private static let java$io$File_list__Ajava$lang$String = invoker("list", returns: JArray(JObjectType("java/lang/String")))
    public func list() throws -> [java$lang$String?]? {
        return try java$io$File$.java$io$File_list__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$io$File_list_java$io$FilenameFilter__Ajava$lang$String = invoker("list", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/io/FilenameFilter")))
    public func list(a0: java$io$FilenameFilter?) throws -> [java$lang$String?]? {
        return try java$io$File$.java$io$File_list_java$io$FilenameFilter__Ajava$lang$String(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$io$File_listFiles__Ajava$io$File = invoker("listFiles", returns: JArray(JObjectType("java/io/File")))
    public func listFiles() throws -> [java$io$File?]? {
        return try java$io$File$.java$io$File_listFiles__Ajava$io$File(jobj)().jarrayToArray(java$io$File$.self)?.map({ $0 as java$io$File? })
    }

    private static let java$io$File_listFiles_java$io$FilenameFilter__Ajava$io$File = invoker("listFiles", returns: JArray(JObjectType("java/io/File")), arguments: (JObjectType("java/io/FilenameFilter")))
    public func listFiles(a0: java$io$FilenameFilter?) throws -> [java$io$File?]? {
        return try java$io$File$.java$io$File_listFiles_java$io$FilenameFilter__Ajava$io$File(jobj)(a0?.jobj ?? nil).jarrayToArray(java$io$File$.self)?.map({ $0 as java$io$File? })
    }

    private static let java$io$File_listFiles_java$io$FileFilter__Ajava$io$File = invoker("listFiles", returns: JArray(JObjectType("java/io/File")), arguments: (JObjectType("java/io/FileFilter")))
    public func listFiles(a0: java$io$FileFilter?) throws -> [java$io$File?]? {
        return try java$io$File$.java$io$File_listFiles_java$io$FileFilter__Ajava$io$File(jobj)(a0?.jobj ?? nil).jarrayToArray(java$io$File$.self)?.map({ $0 as java$io$File? })
    }

    private static let java$io$File_mkdir__Z = invoker("mkdir", returns: jboolean.jniType)
    public func mkdir() throws -> jboolean {
        return try java$io$File$.java$io$File_mkdir__Z(jobj)()
    }

    private static let java$io$File_mkdirs__Z = invoker("mkdirs", returns: jboolean.jniType)
    public func mkdirs() throws -> jboolean {
        return try java$io$File$.java$io$File_mkdirs__Z(jobj)()
    }

    private static let java$io$File_renameTo_java$io$File__Z = invoker("renameTo", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    public func renameTo(a0: java$io$File?) throws -> jboolean {
        return try java$io$File$.java$io$File_renameTo_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$File_setLastModified_J__Z = invoker("setLastModified", returns: jboolean.jniType, arguments: (jlong.jniType))
    public func setLastModified(a0: jlong) throws -> jboolean {
        return try java$io$File$.java$io$File_setLastModified_J__Z(jobj)(a0)
    }

    private static let java$io$File_setReadOnly__Z = invoker("setReadOnly", returns: jboolean.jniType)
    public func setReadOnly() throws -> jboolean {
        return try java$io$File$.java$io$File_setReadOnly__Z(jobj)()
    }

    private static let java$io$File_setWritable_Z_Z__Z = invoker("setWritable", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public func setWritable(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setWritable_Z_Z__Z(jobj)(a0, a1)
    }

    private static let java$io$File_setWritable_Z__Z = invoker("setWritable", returns: jboolean.jniType, arguments: (jboolean.jniType))
    public func setWritable(a0: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setWritable_Z__Z(jobj)(a0)
    }

    private static let java$io$File_setReadable_Z_Z__Z = invoker("setReadable", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public func setReadable(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setReadable_Z_Z__Z(jobj)(a0, a1)
    }

    private static let java$io$File_setReadable_Z__Z = invoker("setReadable", returns: jboolean.jniType, arguments: (jboolean.jniType))
    public func setReadable(a0: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setReadable_Z__Z(jobj)(a0)
    }

    private static let java$io$File_setExecutable_Z_Z__Z = invoker("setExecutable", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public func setExecutable(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setExecutable_Z_Z__Z(jobj)(a0, a1)
    }

    private static let java$io$File_setExecutable_Z__Z = invoker("setExecutable", returns: jboolean.jniType, arguments: (jboolean.jniType))
    public func setExecutable(a0: jboolean) throws -> jboolean {
        return try java$io$File$.java$io$File_setExecutable_Z__Z(jobj)(a0)
    }

    private static let java$io$File_canExecute__Z = invoker("canExecute", returns: jboolean.jniType)
    public func canExecute() throws -> jboolean {
        return try java$io$File$.java$io$File_canExecute__Z(jobj)()
    }

    private static let java$io$File_listRoots__Ajava$io$File = svoker("listRoots", returns: JArray(JObjectType("java/io/File")))
    public static func listRoots() throws -> [java$io$File?]? {
        return try java$io$File$.java$io$File_listRoots__Ajava$io$File().jarrayToArray(java$io$File$.self)?.map({ $0 as java$io$File? })
    }

    private static let java$io$File_getTotalSpace__J = invoker("getTotalSpace", returns: jlong.jniType)
    public func getTotalSpace() throws -> jlong {
        return try java$io$File$.java$io$File_getTotalSpace__J(jobj)()
    }

    private static let java$io$File_getFreeSpace__J = invoker("getFreeSpace", returns: jlong.jniType)
    public func getFreeSpace() throws -> jlong {
        return try java$io$File$.java$io$File_getFreeSpace__J(jobj)()
    }

    private static let java$io$File_getUsableSpace__J = invoker("getUsableSpace", returns: jlong.jniType)
    public func getUsableSpace() throws -> jlong {
        return try java$io$File$.java$io$File_getUsableSpace__J(jobj)()
    }

    private static let java$io$File_createTempFile_java$lang$String_java$lang$String_java$io$File__java$io$File = svoker("createTempFile", returns: JObjectType("java/io/File"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/io/File")))
    public static func createTempFile(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$io$File?) throws -> java$io$File? {
        return try java$io$File$(jobj: java$io$File$.java$io$File_createTempFile_java$lang$String_java$lang$String_java$io$File__java$io$File(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$io$File_createTempFile_java$lang$String_java$lang$String__java$io$File = svoker("createTempFile", returns: JObjectType("java/io/File"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func createTempFile(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$io$File? {
        return try java$io$File$(jobj: java$io$File$.java$io$File_createTempFile_java$lang$String_java$lang$String__java$io$File(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$io$File_compareTo_java$io$File__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
    public func compareTo(a0: java$io$File?) throws -> jint {
        return try java$io$File$.java$io$File_compareTo_java$io$File__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$File_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$io$File_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$io$File_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$io$File_toPath__java$nio$file$Path = invoker("toPath", returns: JObjectType("java/nio/file/Path"))
    public func toPath() throws -> java$nio$file$Path? {
        return try java$nio$file$Path$(jobj: java$io$File$.java$io$File_toPath__java$nio$file$Path(jobj)())
    }

    private static let java$io$File_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$io$File$.java$io$File_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$io$File$ = java$io$File

public final class java$io$FileDescriptor : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileDescriptor_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$FileDescriptor$.java$io$FileDescriptor_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$FileDescriptor_valid__Z = invoker("valid", returns: jboolean.jniType)
    public func valid() throws -> jboolean {
        return try java$io$FileDescriptor$.java$io$FileDescriptor_valid__Z(jobj)()
    }

    private static let java$io$FileDescriptor_sync__V = invoker("sync", returns: JVoid.jniType)
    public func sync() throws -> Void {
        return try java$io$FileDescriptor$.java$io$FileDescriptor_sync__V(jobj)()
    }

}

public typealias java$io$FileDescriptor$ = java$io$FileDescriptor

public protocol java$io$FileFilter : JavaObject {
    func accept(a0: java$io$File?) throws -> jboolean
}

public class java$io$FileFilter$ : java$lang$Object$, java$io$FileFilter {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileFilter_accept_java$io$File__Z = invoker("accept", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
}

public extension java$io$FileFilter {
    func accept(a0: java$io$File?) throws -> jboolean {
        return try java$io$FileFilter$.java$io$FileFilter_accept_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

}

public class java$io$FileInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileInputStream_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$FileInputStream$.java$io$FileInputStream_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileInputStream_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$FileInputStream$.java$io$FileInputStream_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileInputStream_init_java$io$FileDescriptor__V = constructor((JObjectType("java/io/FileDescriptor")))
    public convenience init!(_ a0: java$io$FileDescriptor?) throws {
        let jobj = try java$io$FileInputStream$.java$io$FileInputStream_init_java$io$FileDescriptor__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$FileInputStream_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$FileInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$FileInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$FileInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$FileInputStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$FileInputStream_getFD__java$io$FileDescriptor = invoker("getFD", returns: JObjectType("java/io/FileDescriptor"))
    public func getFD() throws -> java$io$FileDescriptor? {
        return try java$io$FileDescriptor$(jobj: java$io$FileInputStream$.java$io$FileInputStream_getFD__java$io$FileDescriptor(jobj)())
    }

    private static let java$io$FileInputStream_getChannel__java$nio$channels$FileChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/FileChannel"))
    public func getChannel() throws -> java$nio$channels$FileChannel? {
        return try java$nio$channels$FileChannel$(jobj: java$io$FileInputStream$.java$io$FileInputStream_getChannel__java$nio$channels$FileChannel(jobj)())
    }

}

public typealias java$io$FileInputStream$ = java$io$FileInputStream

public class java$io$FileNotFoundException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileNotFoundException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$FileNotFoundException$.java$io$FileNotFoundException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$FileNotFoundException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$FileNotFoundException$.java$io$FileNotFoundException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$FileNotFoundException$ = java$io$FileNotFoundException

public class java$io$FileOutputStream : java$io$OutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileOutputStream_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$FileOutputStream$.java$io$FileOutputStream_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileOutputStream_init_java$lang$String_Z__V = constructor((JObjectType("java/lang/String"), jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jboolean) throws {
        let jobj = try java$io$FileOutputStream$.java$io$FileOutputStream_init_java$lang$String_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$FileOutputStream_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$FileOutputStream$.java$io$FileOutputStream_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileOutputStream_init_java$io$File_Z__V = constructor((JObjectType("java/io/File"), jboolean.jniType))
    public convenience init!(_ a0: java$io$File?, _ a1: jboolean) throws {
        let jobj = try java$io$FileOutputStream$.java$io$FileOutputStream_init_java$io$File_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$FileOutputStream_init_java$io$FileDescriptor__V = constructor((JObjectType("java/io/FileDescriptor")))
    public convenience init!(_ a0: java$io$FileDescriptor?) throws {
        let jobj = try java$io$FileOutputStream$.java$io$FileOutputStream_init_java$io$FileDescriptor__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$FileOutputStream_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$FileOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$FileOutputStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$FileOutputStream_getFD__java$io$FileDescriptor = invoker("getFD", returns: JObjectType("java/io/FileDescriptor"))
    public func getFD() throws -> java$io$FileDescriptor? {
        return try java$io$FileDescriptor$(jobj: java$io$FileOutputStream$.java$io$FileOutputStream_getFD__java$io$FileDescriptor(jobj)())
    }

    private static let java$io$FileOutputStream_getChannel__java$nio$channels$FileChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/FileChannel"))
    public func getChannel() throws -> java$nio$channels$FileChannel? {
        return try java$nio$channels$FileChannel$(jobj: java$io$FileOutputStream$.java$io$FileOutputStream_getChannel__java$nio$channels$FileChannel(jobj)())
    }

}

public typealias java$io$FileOutputStream$ = java$io$FileOutputStream

public class java$io$FileReader : java$io$InputStreamReader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileReader_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$FileReader$.java$io$FileReader_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileReader_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$FileReader$.java$io$FileReader_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileReader_init_java$io$FileDescriptor__V = constructor((JObjectType("java/io/FileDescriptor")))
    public convenience init!(_ a0: java$io$FileDescriptor?) throws {
        let jobj = try java$io$FileReader$.java$io$FileReader_init_java$io$FileDescriptor__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$FileReader$ = java$io$FileReader

public class java$io$FileSystem : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileSystem_getSeparator__C = invoker("getSeparator", returns: jchar.jniType)
    public func getSeparator() throws -> jchar {
        return try java$io$FileSystem$.java$io$FileSystem_getSeparator__C(jobj)()
    }

    private static let java$io$FileSystem_getPathSeparator__C = invoker("getPathSeparator", returns: jchar.jniType)
    public func getPathSeparator() throws -> jchar {
        return try java$io$FileSystem$.java$io$FileSystem_getPathSeparator__C(jobj)()
    }

    private static let java$io$FileSystem_normalize_java$lang$String__java$lang$String = invoker("normalize", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func normalize(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_normalize_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$FileSystem_prefixLength_java$lang$String__I = invoker("prefixLength", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func prefixLength(a0: java$lang$String?) throws -> jint {
        return try java$io$FileSystem$.java$io$FileSystem_prefixLength_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_resolve_java$lang$String_java$lang$String__java$lang$String = invoker("resolve", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func resolve(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_resolve_java$lang$String_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$io$FileSystem_getDefaultParent__java$lang$String = invoker("getDefaultParent", returns: JObjectType("java/lang/String"))
    public func getDefaultParent() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_getDefaultParent__java$lang$String(jobj)())
    }

    private static let java$io$FileSystem_fromURIPath_java$lang$String__java$lang$String = invoker("fromURIPath", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func fromURIPath(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_fromURIPath_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$FileSystem_isAbsolute_java$io$File__Z = invoker("isAbsolute", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    public func isAbsolute(a0: java$io$File?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_isAbsolute_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_resolve_java$io$File__java$lang$String = invoker("resolve", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/io/File")))
    public func resolve(a0: java$io$File?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_resolve_java$io$File__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$FileSystem_canonicalize_java$lang$String__java$lang$String = invoker("canonicalize", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func canonicalize(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$FileSystem$.java$io$FileSystem_canonicalize_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$FileSystem_getBooleanAttributes_java$io$File__I = invoker("getBooleanAttributes", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
    public func getBooleanAttributes(a0: java$io$File?) throws -> jint {
        return try java$io$FileSystem$.java$io$FileSystem_getBooleanAttributes_java$io$File__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_checkAccess_java$io$File_I__Z = invoker("checkAccess", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jint.jniType))
    public func checkAccess(a0: java$io$File?, _ a1: jint) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_checkAccess_java$io$File_I__Z(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$io$FileSystem_setPermission_java$io$File_I_Z_Z__Z = invoker("setPermission", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jint.jniType, jboolean.jniType, jboolean.jniType))
    public func setPermission(a0: java$io$File?, _ a1: jint, _ a2: jboolean, _ a3: jboolean) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_setPermission_java$io$File_I_Z_Z__Z(jobj)(a0?.jobj ?? nil, a1, a2, a3)
    }

    private static let java$io$FileSystem_getLastModifiedTime_java$io$File__J = invoker("getLastModifiedTime", returns: jlong.jniType, arguments: (JObjectType("java/io/File")))
    public func getLastModifiedTime(a0: java$io$File?) throws -> jlong {
        return try java$io$FileSystem$.java$io$FileSystem_getLastModifiedTime_java$io$File__J(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_getLength_java$io$File__J = invoker("getLength", returns: jlong.jniType, arguments: (JObjectType("java/io/File")))
    public func getLength(a0: java$io$File?) throws -> jlong {
        return try java$io$FileSystem$.java$io$FileSystem_getLength_java$io$File__J(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_createFileExclusively_java$lang$String__Z = invoker("createFileExclusively", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func createFileExclusively(a0: java$lang$String?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_createFileExclusively_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_delete_java$io$File__Z = invoker("delete", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    public func delete(a0: java$io$File?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_delete_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_list_java$io$File__Ajava$lang$String = invoker("list", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/io/File")))
    public func list(a0: java$io$File?) throws -> [java$lang$String?]? {
        return try java$io$FileSystem$.java$io$FileSystem_list_java$io$File__Ajava$lang$String(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$io$FileSystem_createDirectory_java$io$File__Z = invoker("createDirectory", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    public func createDirectory(a0: java$io$File?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_createDirectory_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_rename_java$io$File_java$io$File__Z = invoker("rename", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), JObjectType("java/io/File")))
    public func rename(a0: java$io$File?, _ a1: java$io$File?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_rename_java$io$File_java$io$File__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$io$FileSystem_setLastModifiedTime_java$io$File_J__Z = invoker("setLastModifiedTime", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jlong.jniType))
    public func setLastModifiedTime(a0: java$io$File?, _ a1: jlong) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_setLastModifiedTime_java$io$File_J__Z(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$io$FileSystem_setReadOnly_java$io$File__Z = invoker("setReadOnly", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    public func setReadOnly(a0: java$io$File?) throws -> jboolean {
        return try java$io$FileSystem$.java$io$FileSystem_setReadOnly_java$io$File__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$FileSystem_listRoots__Ajava$io$File = invoker("listRoots", returns: JArray(JObjectType("java/io/File")))
    public func listRoots() throws -> [java$io$File?]? {
        return try java$io$FileSystem$.java$io$FileSystem_listRoots__Ajava$io$File(jobj)().jarrayToArray(java$io$File$.self)?.map({ $0 as java$io$File? })
    }

    private static let java$io$FileSystem_getSpace_java$io$File_I__J = invoker("getSpace", returns: jlong.jniType, arguments: (JObjectType("java/io/File"), jint.jniType))
    public func getSpace(a0: java$io$File?, _ a1: jint) throws -> jlong {
        return try java$io$FileSystem$.java$io$FileSystem_getSpace_java$io$File_I__J(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$io$FileSystem_compare_java$io$File_java$io$File__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/io/File"), JObjectType("java/io/File")))
    public func compare(a0: java$io$File?, _ a1: java$io$File?) throws -> jint {
        return try java$io$FileSystem$.java$io$FileSystem_compare_java$io$File_java$io$File__I(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$io$FileSystem_hashCode_java$io$File__I = invoker("hashCode", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
    public func hashCode(a0: java$io$File?) throws -> jint {
        return try java$io$FileSystem$.java$io$FileSystem_hashCode_java$io$File__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$io$FileSystem$ = java$io$FileSystem

public class java$io$FileWriter : java$io$OutputStreamWriter$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FileWriter_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$FileWriter$.java$io$FileWriter_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileWriter_init_java$lang$String_Z__V = constructor((JObjectType("java/lang/String"), jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jboolean) throws {
        let jobj = try java$io$FileWriter$.java$io$FileWriter_init_java$lang$String_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$FileWriter_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$FileWriter$.java$io$FileWriter_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FileWriter_init_java$io$File_Z__V = constructor((JObjectType("java/io/File"), jboolean.jniType))
    public convenience init!(_ a0: java$io$File?, _ a1: jboolean) throws {
        let jobj = try java$io$FileWriter$.java$io$FileWriter_init_java$io$File_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$FileWriter_init_java$io$FileDescriptor__V = constructor((JObjectType("java/io/FileDescriptor")))
    public convenience init!(_ a0: java$io$FileDescriptor?) throws {
        let jobj = try java$io$FileWriter$.java$io$FileWriter_init_java$io$FileDescriptor__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$FileWriter$ = java$io$FileWriter

public protocol java$io$FilenameFilter : JavaObject {
    func accept(a0: java$io$File?, _ a1: java$lang$String?) throws -> jboolean
}

public class java$io$FilenameFilter$ : java$lang$Object$, java$io$FilenameFilter {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FilenameFilter_accept_java$io$File_java$lang$String__Z = invoker("accept", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), JObjectType("java/lang/String")))
}

public extension java$io$FilenameFilter {
    func accept(a0: java$io$File?, _ a1: java$lang$String?) throws -> jboolean {
        return try java$io$FilenameFilter$.java$io$FilenameFilter_accept_java$io$File_java$lang$String__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public class java$io$FilterInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FilterInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$FilterInputStream_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$FilterInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$FilterInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$FilterInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$FilterInputStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$FilterInputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$FilterInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$FilterInputStream_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
}

public typealias java$io$FilterInputStream$ = java$io$FilterInputStream

public class java$io$FilterOutputStream : java$io$OutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FilterOutputStream_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$FilterOutputStream$.java$io$FilterOutputStream_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$FilterOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$FilterOutputStream_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$FilterOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$FilterOutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$FilterOutputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$FilterOutputStream$ = java$io$FilterOutputStream

public class java$io$FilterReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FilterReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$FilterReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$FilterReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$FilterReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$FilterReader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$FilterReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$FilterReader_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$FilterReader_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$FilterReader$ = java$io$FilterReader

public class java$io$FilterWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$FilterWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$FilterWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$FilterWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$FilterWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$FilterWriter_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$FilterWriter$ = java$io$FilterWriter

public protocol java$io$Flushable : JavaObject {
    func flush() throws -> Void
}

public class java$io$Flushable$ : java$lang$Object$, java$io$Flushable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Flushable_flush__V = invoker("flush", returns: JVoid.jniType)
}

public extension java$io$Flushable {
    func flush() throws -> Void {
        return try java$io$Flushable$.java$io$Flushable_flush__V(jobj)()
    }

}

public class java$io$IOError : java$lang$Error$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$IOError_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$io$IOError$.java$io$IOError_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$IOError$ = java$io$IOError

public class java$io$IOException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$IOException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$IOException$.java$io$IOException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$IOException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$IOException$.java$io$IOException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$IOException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$io$IOException$.java$io$IOException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$IOException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$io$IOException$.java$io$IOException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$IOException$ = java$io$IOException

public class java$io$InputStream : java$lang$Object$, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$InputStream_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$InputStream$.java$io$InputStream_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$InputStream_read__I = invoker("read", returns: jint.jniType)
    public func read() throws -> jint {
        return try java$io$InputStream$.java$io$InputStream_read__I(jobj)()
    }

    private static let java$io$InputStream_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    public func read(a0: [jbyte]?) throws -> jint {
        return try java$io$InputStream$.java$io$InputStream_read_AB__I(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$InputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func read(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$io$InputStream$.java$io$InputStream_read_AB_I_I__I(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$InputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    public func skip(a0: jlong) throws -> jlong {
        return try java$io$InputStream$.java$io$InputStream_skip_J__J(jobj)(a0)
    }

    private static let java$io$InputStream_available__I = invoker("available", returns: jint.jniType)
    public func available() throws -> jint {
        return try java$io$InputStream$.java$io$InputStream_available__I(jobj)()
    }

    private static let java$io$InputStream_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$io$InputStream$.java$io$InputStream_close__V(jobj)()
    }

    private static let java$io$InputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    public func mark(a0: jint) throws -> Void {
        return try java$io$InputStream$.java$io$InputStream_mark_I__V(jobj)(a0)
    }

    private static let java$io$InputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$io$InputStream$.java$io$InputStream_reset__V(jobj)()
    }

    private static let java$io$InputStream_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    public func markSupported() throws -> jboolean {
        return try java$io$InputStream$.java$io$InputStream_markSupported__Z(jobj)()
    }

}

public typealias java$io$InputStream$ = java$io$InputStream

public class java$io$InputStreamReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$InputStreamReader_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$InputStreamReader$.java$io$InputStreamReader_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InputStreamReader_init_java$io$InputStream_java$lang$String__V = constructor((JObjectType("java/io/InputStream"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$InputStreamReader$.java$io$InputStreamReader_init_java$io$InputStream_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InputStreamReader_init_java$io$InputStream_java$nio$charset$Charset__V = constructor((JObjectType("java/io/InputStream"), JObjectType("java/nio/charset/Charset")))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: java$nio$charset$Charset?) throws {
        let jobj = try java$io$InputStreamReader$.java$io$InputStreamReader_init_java$io$InputStream_java$nio$charset$Charset__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InputStreamReader_init_java$io$InputStream_java$nio$charset$CharsetDecoder__V = constructor((JObjectType("java/io/InputStream"), JObjectType("java/nio/charset/CharsetDecoder")))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: java$nio$charset$CharsetDecoder?) throws {
        let jobj = try java$io$InputStreamReader$.java$io$InputStreamReader_init_java$io$InputStream_java$nio$charset$CharsetDecoder__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InputStreamReader_getEncoding__java$lang$String = invoker("getEncoding", returns: JObjectType("java/lang/String"))
    public func getEncoding() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$InputStreamReader$.java$io$InputStreamReader_getEncoding__java$lang$String(jobj)())
    }

    private static let java$io$InputStreamReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$InputStreamReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$InputStreamReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$InputStreamReader_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$InputStreamReader$ = java$io$InputStreamReader

public class java$io$InterruptedIOException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$InterruptedIOException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$InterruptedIOException$.java$io$InterruptedIOException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$InterruptedIOException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$InterruptedIOException$.java$io$InterruptedIOException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$InterruptedIOException$ = java$io$InterruptedIOException

public class java$io$InvalidClassException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$InvalidClassException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$InvalidClassException$.java$io$InvalidClassException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InvalidClassException_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$InvalidClassException$.java$io$InvalidClassException_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$InvalidClassException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$io$InvalidClassException$ = java$io$InvalidClassException

public class java$io$InvalidObjectException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$InvalidObjectException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$InvalidObjectException$.java$io$InvalidObjectException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$InvalidObjectException$ = java$io$InvalidObjectException

public class java$io$LineNumberInputStream : java$io$FilterInputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$LineNumberInputStream_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$LineNumberInputStream$.java$io$LineNumberInputStream_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$LineNumberInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$LineNumberInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$LineNumberInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$LineNumberInputStream_setLineNumber_I__V = invoker("setLineNumber", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setLineNumber(a0: jint) throws -> Void {
        return try java$io$LineNumberInputStream$.java$io$LineNumberInputStream_setLineNumber_I__V(jobj)(a0)
    }

    private static let java$io$LineNumberInputStream_getLineNumber__I = invoker("getLineNumber", returns: jint.jniType)
    public func getLineNumber() throws -> jint {
        return try java$io$LineNumberInputStream$.java$io$LineNumberInputStream_getLineNumber__I(jobj)()
    }

    private static let java$io$LineNumberInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$LineNumberInputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$LineNumberInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
}

public typealias java$io$LineNumberInputStream$ = java$io$LineNumberInputStream

public class java$io$LineNumberReader : java$io$BufferedReader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$LineNumberReader_init_java$io$Reader__V = constructor((JObjectType("java/io/Reader")))
    public convenience init!(_ a0: java$io$Reader?) throws {
        let jobj = try java$io$LineNumberReader$.java$io$LineNumberReader_init_java$io$Reader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$LineNumberReader_init_java$io$Reader_I__V = constructor((JObjectType("java/io/Reader"), jint.jniType))
    public convenience init!(_ a0: java$io$Reader?, _ a1: jint) throws {
        let jobj = try java$io$LineNumberReader$.java$io$LineNumberReader_init_java$io$Reader_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$LineNumberReader_setLineNumber_I__V = invoker("setLineNumber", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setLineNumber(a0: jint) throws -> Void {
        return try java$io$LineNumberReader$.java$io$LineNumberReader_setLineNumber_I__V(jobj)(a0)
    }

    private static let java$io$LineNumberReader_getLineNumber__I = invoker("getLineNumber", returns: jint.jniType)
    public func getLineNumber() throws -> jint {
        return try java$io$LineNumberReader$.java$io$LineNumberReader_getLineNumber__I(jobj)()
    }

    private static let java$io$LineNumberReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$LineNumberReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$LineNumberReader_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    private static let java$io$LineNumberReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$LineNumberReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$LineNumberReader_reset__V = invoker("reset", returns: JVoid.jniType)
}

public typealias java$io$LineNumberReader$ = java$io$LineNumberReader

public class java$io$NotActiveException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$NotActiveException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$NotActiveException$.java$io$NotActiveException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$NotActiveException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$NotActiveException$.java$io$NotActiveException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$io$NotActiveException$ = java$io$NotActiveException

public class java$io$NotSerializableException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$NotSerializableException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$NotSerializableException$.java$io$NotSerializableException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$NotSerializableException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$NotSerializableException$.java$io$NotSerializableException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$io$NotSerializableException$ = java$io$NotSerializableException

public protocol java$io$ObjectInput : java$io$DataInput, java$lang$AutoCloseable {
    func readObject() throws -> java$lang$Object?
    func read() throws -> jint
    func read(a0: [jbyte]?) throws -> jint
    func read(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> jint
    func skip(a0: jlong) throws -> jlong
    func available() throws -> jint
    func close() throws -> Void
}

public class java$io$ObjectInput$ : java$lang$Object$, java$io$ObjectInput, java$io$DataInput, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectInput_readObject__java$lang$Object = invoker("readObject", returns: JObjectType("java/lang/Object"))
    private static let java$io$ObjectInput_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$ObjectInput_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$ObjectInput_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ObjectInput_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$ObjectInput_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$ObjectInput_close__V = invoker("close", returns: JVoid.jniType)
}

public extension java$io$ObjectInput {
    func readObject() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$io$ObjectInput$.java$io$ObjectInput_readObject__java$lang$Object(jobj)())
    }

    func read() throws -> jint {
        return try java$io$ObjectInput$.java$io$ObjectInput_read__I(jobj)()
    }

    func read(a0: [jbyte]?) throws -> jint {
        return try java$io$ObjectInput$.java$io$ObjectInput_read_AB__I(jobj)(a0?.arrayToJArray() ?? nil)
    }

    func read(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$io$ObjectInput$.java$io$ObjectInput_read_AB_I_I__I(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    func skip(a0: jlong) throws -> jlong {
        return try java$io$ObjectInput$.java$io$ObjectInput_skip_J__J(jobj)(a0)
    }

    func available() throws -> jint {
        return try java$io$ObjectInput$.java$io$ObjectInput_available__I(jobj)()
    }

    func close() throws -> Void {
        return try java$io$ObjectInput$.java$io$ObjectInput_close__V(jobj)()
    }

}

public class java$io$ObjectInputStream : java$io$InputStream$, java$io$ObjectInput, java$io$ObjectStreamConstants {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectInputStream_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$ObjectInputStream$.java$io$ObjectInputStream_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$ObjectInputStream_readObject__java$lang$Object = invoker("readObject", returns: JObjectType("java/lang/Object"))
    public func readObject() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$io$ObjectInputStream$.java$io$ObjectInputStream_readObject__java$lang$Object(jobj)())
    }

    private static let java$io$ObjectInputStream_readUnshared__java$lang$Object = invoker("readUnshared", returns: JObjectType("java/lang/Object"))
    public func readUnshared() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$io$ObjectInputStream$.java$io$ObjectInputStream_readUnshared__java$lang$Object(jobj)())
    }

    private static let java$io$ObjectInputStream_defaultReadObject__V = invoker("defaultReadObject", returns: JVoid.jniType)
    public func defaultReadObject() throws -> Void {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_defaultReadObject__V(jobj)()
    }

    private static let java$io$ObjectInputStream_readFields__java$io$ObjectInputStream$GetField = invoker("readFields", returns: JObjectType("java/io/ObjectInputStream$GetField"))
    public func readFields() throws -> java$io$ObjectInputStream$GetField? {
        return try java$io$ObjectInputStream$GetField$(jobj: java$io$ObjectInputStream$.java$io$ObjectInputStream_readFields__java$io$ObjectInputStream$GetField(jobj)())
    }

    private static let java$io$ObjectInputStream_registerValidation_java$io$ObjectInputValidation_I__V = invoker("registerValidation", returns: JVoid.jniType, arguments: (JObjectType("java/io/ObjectInputValidation"), jint.jniType))
    public func registerValidation(a0: java$io$ObjectInputValidation?, _ a1: jint) throws -> Void {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_registerValidation_java$io$ObjectInputValidation_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$io$ObjectInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$ObjectInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ObjectInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$ObjectInputStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$ObjectInputStream_readBoolean__Z = invoker("readBoolean", returns: jboolean.jniType)
    public func readBoolean() throws -> jboolean {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readBoolean__Z(jobj)()
    }

    private static let java$io$ObjectInputStream_readByte__B = invoker("readByte", returns: jbyte.jniType)
    public func readByte() throws -> jbyte {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readByte__B(jobj)()
    }

    private static let java$io$ObjectInputStream_readUnsignedByte__I = invoker("readUnsignedByte", returns: jint.jniType)
    public func readUnsignedByte() throws -> jint {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readUnsignedByte__I(jobj)()
    }

    private static let java$io$ObjectInputStream_readChar__C = invoker("readChar", returns: jchar.jniType)
    public func readChar() throws -> jchar {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readChar__C(jobj)()
    }

    private static let java$io$ObjectInputStream_readShort__S = invoker("readShort", returns: jshort.jniType)
    public func readShort() throws -> jshort {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readShort__S(jobj)()
    }

    private static let java$io$ObjectInputStream_readUnsignedShort__I = invoker("readUnsignedShort", returns: jint.jniType)
    public func readUnsignedShort() throws -> jint {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readUnsignedShort__I(jobj)()
    }

    private static let java$io$ObjectInputStream_readInt__I = invoker("readInt", returns: jint.jniType)
    public func readInt() throws -> jint {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readInt__I(jobj)()
    }

    private static let java$io$ObjectInputStream_readLong__J = invoker("readLong", returns: jlong.jniType)
    public func readLong() throws -> jlong {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readLong__J(jobj)()
    }

    private static let java$io$ObjectInputStream_readFloat__F = invoker("readFloat", returns: jfloat.jniType)
    public func readFloat() throws -> jfloat {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readFloat__F(jobj)()
    }

    private static let java$io$ObjectInputStream_readDouble__D = invoker("readDouble", returns: jdouble.jniType)
    public func readDouble() throws -> jdouble {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readDouble__D(jobj)()
    }

    private static let java$io$ObjectInputStream_readFully_AB__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func readFully(a0: [jbyte]?) throws -> Void {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readFully_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$ObjectInputStream_readFully_AB_I_I__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func readFully(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_readFully_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$ObjectInputStream_skipBytes_I__I = invoker("skipBytes", returns: jint.jniType, arguments: (jint.jniType))
    public func skipBytes(a0: jint) throws -> jint {
        return try java$io$ObjectInputStream$.java$io$ObjectInputStream_skipBytes_I__I(jobj)(a0)
    }

    private static let java$io$ObjectInputStream_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    public func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ObjectInputStream$.java$io$ObjectInputStream_readLine__java$lang$String(jobj)())
    }

    private static let java$io$ObjectInputStream_readUTF__java$lang$String = invoker("readUTF", returns: JObjectType("java/lang/String"))
    public func readUTF() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ObjectInputStream$.java$io$ObjectInputStream_readUTF__java$lang$String(jobj)())
    }

}

public typealias java$io$ObjectInputStream$ = java$io$ObjectInputStream

public protocol java$io$ObjectInputValidation : JavaObject {
    func validateObject() throws -> Void
}

public class java$io$ObjectInputValidation$ : java$lang$Object$, java$io$ObjectInputValidation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectInputValidation_validateObject__V = invoker("validateObject", returns: JVoid.jniType)
}

public extension java$io$ObjectInputValidation {
    func validateObject() throws -> Void {
        return try java$io$ObjectInputValidation$.java$io$ObjectInputValidation_validateObject__V(jobj)()
    }

}

public protocol java$io$ObjectOutput : java$io$DataOutput, java$lang$AutoCloseable {
    func writeObject(a0: java$lang$Object?) throws -> Void
    func write(a0: jint) throws -> Void
    func write(a0: [jbyte]?) throws -> Void
    func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void
    func flush() throws -> Void
    func close() throws -> Void
}

public class java$io$ObjectOutput$ : java$lang$Object$, java$io$ObjectOutput, java$io$DataOutput, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectOutput_writeObject_java$lang$Object__V = invoker("writeObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$io$ObjectOutput_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$ObjectOutput_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$ObjectOutput_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ObjectOutput_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$ObjectOutput_close__V = invoker("close", returns: JVoid.jniType)
}

public extension java$io$ObjectOutput {
    func writeObject(a0: java$lang$Object?) throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_writeObject_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    func write(a0: jint) throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_write_I__V(jobj)(a0)
    }

    func write(a0: [jbyte]?) throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_write_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_write_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    func flush() throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_flush__V(jobj)()
    }

    func close() throws -> Void {
        return try java$io$ObjectOutput$.java$io$ObjectOutput_close__V(jobj)()
    }

}

public class java$io$ObjectOutputStream : java$io$OutputStream$, java$io$ObjectOutput, java$io$ObjectStreamConstants {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectOutputStream_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$ObjectOutputStream_useProtocolVersion_I__V = invoker("useProtocolVersion", returns: JVoid.jniType, arguments: (jint.jniType))
    public func useProtocolVersion(a0: jint) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_useProtocolVersion_I__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeObject_java$lang$Object__V = invoker("writeObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func writeObject(a0: java$lang$Object?) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeObject_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ObjectOutputStream_writeUnshared_java$lang$Object__V = invoker("writeUnshared", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func writeUnshared(a0: java$lang$Object?) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeUnshared_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ObjectOutputStream_defaultWriteObject__V = invoker("defaultWriteObject", returns: JVoid.jniType)
    public func defaultWriteObject() throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_defaultWriteObject__V(jobj)()
    }

    private static let java$io$ObjectOutputStream_putFields__java$io$ObjectOutputStream$PutField = invoker("putFields", returns: JObjectType("java/io/ObjectOutputStream$PutField"))
    public func putFields() throws -> java$io$ObjectOutputStream$PutField? {
        return try java$io$ObjectOutputStream$PutField$(jobj: java$io$ObjectOutputStream$.java$io$ObjectOutputStream_putFields__java$io$ObjectOutputStream$PutField(jobj)())
    }

    private static let java$io$ObjectOutputStream_writeFields__V = invoker("writeFields", returns: JVoid.jniType)
    public func writeFields() throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeFields__V(jobj)()
    }

    private static let java$io$ObjectOutputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_reset__V(jobj)()
    }

    private static let java$io$ObjectOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$ObjectOutputStream_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$io$ObjectOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$ObjectOutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$ObjectOutputStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$ObjectOutputStream_writeBoolean_Z__V = invoker("writeBoolean", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func writeBoolean(a0: jboolean) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeBoolean_Z__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeByte_I__V = invoker("writeByte", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeByte(a0: jint) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeByte_I__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeShort_I__V = invoker("writeShort", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeShort(a0: jint) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeShort_I__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeChar_I__V = invoker("writeChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeChar(a0: jint) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeChar_I__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeInt_I__V = invoker("writeInt", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeInt(a0: jint) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeInt_I__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeLong_J__V = invoker("writeLong", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func writeLong(a0: jlong) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeLong_J__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeFloat_F__V = invoker("writeFloat", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func writeFloat(a0: jfloat) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeFloat_F__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeDouble_D__V = invoker("writeDouble", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func writeDouble(a0: jdouble) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeDouble_D__V(jobj)(a0)
    }

    private static let java$io$ObjectOutputStream_writeBytes_java$lang$String__V = invoker("writeBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeBytes(a0: java$lang$String?) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeBytes_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ObjectOutputStream_writeChars_java$lang$String__V = invoker("writeChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeChars(a0: java$lang$String?) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeChars_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ObjectOutputStream_writeUTF_java$lang$String__V = invoker("writeUTF", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeUTF(a0: java$lang$String?) throws -> Void {
        return try java$io$ObjectOutputStream$.java$io$ObjectOutputStream_writeUTF_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$io$ObjectOutputStream$ = java$io$ObjectOutputStream

public class java$io$ObjectStreamClass : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectStreamClass_lookup_java$lang$Class__java$io$ObjectStreamClass = svoker("lookup", returns: JObjectType("java/io/ObjectStreamClass"), arguments: (JObjectType("java/lang/Class")))
    public static func lookup(a0: java$lang$Class?) throws -> java$io$ObjectStreamClass? {
        return try java$io$ObjectStreamClass$(jobj: java$io$ObjectStreamClass$.java$io$ObjectStreamClass_lookup_java$lang$Class__java$io$ObjectStreamClass(a0?.jobj ?? nil))
    }

    private static let java$io$ObjectStreamClass_lookupAny_java$lang$Class__java$io$ObjectStreamClass = svoker("lookupAny", returns: JObjectType("java/io/ObjectStreamClass"), arguments: (JObjectType("java/lang/Class")))
    public static func lookupAny(a0: java$lang$Class?) throws -> java$io$ObjectStreamClass? {
        return try java$io$ObjectStreamClass$(jobj: java$io$ObjectStreamClass$.java$io$ObjectStreamClass_lookupAny_java$lang$Class__java$io$ObjectStreamClass(a0?.jobj ?? nil))
    }

    private static let java$io$ObjectStreamClass_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ObjectStreamClass$.java$io$ObjectStreamClass_getName__java$lang$String(jobj)())
    }

    private static let java$io$ObjectStreamClass_getSerialVersionUID__J = invoker("getSerialVersionUID", returns: jlong.jniType)
    public func getSerialVersionUID() throws -> jlong {
        return try java$io$ObjectStreamClass$.java$io$ObjectStreamClass_getSerialVersionUID__J(jobj)()
    }

    private static let java$io$ObjectStreamClass_forClass__java$lang$Class = invoker("forClass", returns: JObjectType("java/lang/Class"))
    public func forClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$io$ObjectStreamClass$.java$io$ObjectStreamClass_forClass__java$lang$Class(jobj)())
    }

    private static let java$io$ObjectStreamClass_getFields__Ajava$io$ObjectStreamField = invoker("getFields", returns: JArray(JObjectType("java/io/ObjectStreamField")))
    public func getFields() throws -> [java$io$ObjectStreamField?]? {
        return try java$io$ObjectStreamClass$.java$io$ObjectStreamClass_getFields__Ajava$io$ObjectStreamField(jobj)().jarrayToArray(java$io$ObjectStreamField$.self)?.map({ $0 as java$io$ObjectStreamField? })
    }

    private static let java$io$ObjectStreamClass_getField_java$lang$String__java$io$ObjectStreamField = invoker("getField", returns: JObjectType("java/io/ObjectStreamField"), arguments: (JObjectType("java/lang/String")))
    public func getField(a0: java$lang$String?) throws -> java$io$ObjectStreamField? {
        return try java$io$ObjectStreamField$(jobj: java$io$ObjectStreamClass$.java$io$ObjectStreamClass_getField_java$lang$String__java$io$ObjectStreamField(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$ObjectStreamClass_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$io$ObjectStreamClass$ = java$io$ObjectStreamClass

public protocol java$io$ObjectStreamConstants : JavaObject {
}

public class java$io$ObjectStreamConstants$ : java$lang$Object$, java$io$ObjectStreamConstants {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$io$ObjectStreamConstants {
}

public class java$io$ObjectStreamException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$io$ObjectStreamException$ = java$io$ObjectStreamException

public class java$io$ObjectStreamField : java$lang$Object$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$ObjectStreamField_init_java$lang$String_java$lang$Class__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Class")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Class?) throws {
        let jobj = try java$io$ObjectStreamField$.java$io$ObjectStreamField_init_java$lang$String_java$lang$Class__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$ObjectStreamField_init_java$lang$String_java$lang$Class_Z__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Class"), jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Class?, _ a2: jboolean) throws {
        let jobj = try java$io$ObjectStreamField$.java$io$ObjectStreamField_init_java$lang$String_java$lang$Class_Z__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let java$io$ObjectStreamField_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ObjectStreamField$.java$io$ObjectStreamField_getName__java$lang$String(jobj)())
    }

    private static let java$io$ObjectStreamField_getType__java$lang$Class = invoker("getType", returns: JObjectType("java/lang/Class"))
    public func getType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$io$ObjectStreamField$.java$io$ObjectStreamField_getType__java$lang$Class(jobj)())
    }

    private static let java$io$ObjectStreamField_getTypeCode__C = invoker("getTypeCode", returns: jchar.jniType)
    public func getTypeCode() throws -> jchar {
        return try java$io$ObjectStreamField$.java$io$ObjectStreamField_getTypeCode__C(jobj)()
    }

    private static let java$io$ObjectStreamField_getTypeString__java$lang$String = invoker("getTypeString", returns: JObjectType("java/lang/String"))
    public func getTypeString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$ObjectStreamField$.java$io$ObjectStreamField_getTypeString__java$lang$String(jobj)())
    }

    private static let java$io$ObjectStreamField_getOffset__I = invoker("getOffset", returns: jint.jniType)
    public func getOffset() throws -> jint {
        return try java$io$ObjectStreamField$.java$io$ObjectStreamField_getOffset__I(jobj)()
    }

    private static let java$io$ObjectStreamField_isPrimitive__Z = invoker("isPrimitive", returns: jboolean.jniType)
    public func isPrimitive() throws -> jboolean {
        return try java$io$ObjectStreamField$.java$io$ObjectStreamField_isPrimitive__Z(jobj)()
    }

    private static let java$io$ObjectStreamField_isUnshared__Z = invoker("isUnshared", returns: jboolean.jniType)
    public func isUnshared() throws -> jboolean {
        return try java$io$ObjectStreamField$.java$io$ObjectStreamField_isUnshared__Z(jobj)()
    }

    private static let java$io$ObjectStreamField_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$io$ObjectStreamField$.java$io$ObjectStreamField_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$ObjectStreamField_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$io$ObjectStreamField$ = java$io$ObjectStreamField

public class java$io$OptionalDataException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$io$OptionalDataException$ = java$io$OptionalDataException

public class java$io$OutputStream : java$lang$Object$, java$io$Closeable, java$io$Flushable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$OutputStream_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$OutputStream$.java$io$OutputStream_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$OutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    public func write(a0: jint) throws -> Void {
        return try java$io$OutputStream$.java$io$OutputStream_write_I__V(jobj)(a0)
    }

    private static let java$io$OutputStream_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func write(a0: [jbyte]?) throws -> Void {
        return try java$io$OutputStream$.java$io$OutputStream_write_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$OutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$OutputStream$.java$io$OutputStream_write_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$OutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
    public func flush() throws -> Void {
        return try java$io$OutputStream$.java$io$OutputStream_flush__V(jobj)()
    }

    private static let java$io$OutputStream_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$io$OutputStream$.java$io$OutputStream_close__V(jobj)()
    }

}

public typealias java$io$OutputStream$ = java$io$OutputStream

public class java$io$OutputStreamWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$OutputStreamWriter_init_java$io$OutputStream_java$lang$String__V = constructor((JObjectType("java/io/OutputStream"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$OutputStreamWriter$.java$io$OutputStreamWriter_init_java$io$OutputStream_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$OutputStreamWriter_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$OutputStreamWriter$.java$io$OutputStreamWriter_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$OutputStreamWriter_init_java$io$OutputStream_java$nio$charset$Charset__V = constructor((JObjectType("java/io/OutputStream"), JObjectType("java/nio/charset/Charset")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: java$nio$charset$Charset?) throws {
        let jobj = try java$io$OutputStreamWriter$.java$io$OutputStreamWriter_init_java$io$OutputStream_java$nio$charset$Charset__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$OutputStreamWriter_init_java$io$OutputStream_java$nio$charset$CharsetEncoder__V = constructor((JObjectType("java/io/OutputStream"), JObjectType("java/nio/charset/CharsetEncoder")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: java$nio$charset$CharsetEncoder?) throws {
        let jobj = try java$io$OutputStreamWriter$.java$io$OutputStreamWriter_init_java$io$OutputStream_java$nio$charset$CharsetEncoder__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$OutputStreamWriter_getEncoding__java$lang$String = invoker("getEncoding", returns: JObjectType("java/lang/String"))
    public func getEncoding() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$OutputStreamWriter$.java$io$OutputStreamWriter_getEncoding__java$lang$String(jobj)())
    }

    private static let java$io$OutputStreamWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$OutputStreamWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$OutputStreamWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$OutputStreamWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$OutputStreamWriter_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$OutputStreamWriter$ = java$io$OutputStreamWriter

public class java$io$PipedInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PipedInputStream_init_java$io$PipedOutputStream__V = constructor((JObjectType("java/io/PipedOutputStream")))
    public convenience init!(_ a0: java$io$PipedOutputStream?) throws {
        let jobj = try java$io$PipedInputStream$.java$io$PipedInputStream_init_java$io$PipedOutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedInputStream_init_java$io$PipedOutputStream_I__V = constructor((JObjectType("java/io/PipedOutputStream"), jint.jniType))
    public convenience init!(_ a0: java$io$PipedOutputStream?, _ a1: jint) throws {
        let jobj = try java$io$PipedInputStream$.java$io$PipedInputStream_init_java$io$PipedOutputStream_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedInputStream_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$PipedInputStream$.java$io$PipedInputStream_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$PipedInputStream_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$io$PipedInputStream$.java$io$PipedInputStream_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedInputStream_connect_java$io$PipedOutputStream__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/io/PipedOutputStream")))
    public func connect(a0: java$io$PipedOutputStream?) throws -> Void {
        return try java$io$PipedInputStream$.java$io$PipedInputStream_connect_java$io$PipedOutputStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PipedInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$PipedInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$PipedInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$PipedInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$PipedInputStream$ = java$io$PipedInputStream

public class java$io$PipedOutputStream : java$io$OutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PipedOutputStream_init_java$io$PipedInputStream__V = constructor((JObjectType("java/io/PipedInputStream")))
    public convenience init!(_ a0: java$io$PipedInputStream?) throws {
        let jobj = try java$io$PipedOutputStream$.java$io$PipedOutputStream_init_java$io$PipedInputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedOutputStream_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$PipedOutputStream$.java$io$PipedOutputStream_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$PipedOutputStream_connect_java$io$PipedInputStream__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/io/PipedInputStream")))
    public func connect(a0: java$io$PipedInputStream?) throws -> Void {
        return try java$io$PipedOutputStream$.java$io$PipedOutputStream_connect_java$io$PipedInputStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PipedOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PipedOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$PipedOutputStream_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$PipedOutputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$PipedOutputStream$ = java$io$PipedOutputStream

public class java$io$PipedReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PipedReader_init_java$io$PipedWriter__V = constructor((JObjectType("java/io/PipedWriter")))
    public convenience init!(_ a0: java$io$PipedWriter?) throws {
        let jobj = try java$io$PipedReader$.java$io$PipedReader_init_java$io$PipedWriter__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedReader_init_java$io$PipedWriter_I__V = constructor((JObjectType("java/io/PipedWriter"), jint.jniType))
    public convenience init!(_ a0: java$io$PipedWriter?, _ a1: jint) throws {
        let jobj = try java$io$PipedReader$.java$io$PipedReader_init_java$io$PipedWriter_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedReader_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$PipedReader$.java$io$PipedReader_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$PipedReader_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$io$PipedReader$.java$io$PipedReader_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedReader_connect_java$io$PipedWriter__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/io/PipedWriter")))
    public func connect(a0: java$io$PipedWriter?) throws -> Void {
        return try java$io$PipedReader$.java$io$PipedReader_connect_java$io$PipedWriter__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PipedReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$PipedReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$PipedReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$PipedReader_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$PipedReader$ = java$io$PipedReader

public class java$io$PipedWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PipedWriter_init_java$io$PipedReader__V = constructor((JObjectType("java/io/PipedReader")))
    public convenience init!(_ a0: java$io$PipedReader?) throws {
        let jobj = try java$io$PipedWriter$.java$io$PipedWriter_init_java$io$PipedReader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PipedWriter_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$PipedWriter$.java$io$PipedWriter_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$PipedWriter_connect_java$io$PipedReader__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/io/PipedReader")))
    public func connect(a0: java$io$PipedReader?) throws -> Void {
        return try java$io$PipedWriter$.java$io$PipedWriter_connect_java$io$PipedReader__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PipedWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PipedWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$PipedWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$PipedWriter_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$PipedWriter$ = java$io$PipedWriter

public class java$io$PrintStream : java$io$FilterOutputStream$, java$lang$Appendable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PrintStream_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$io$OutputStream_Z__V = constructor((JObjectType("java/io/OutputStream"), jboolean.jniType))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: jboolean) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$io$OutputStream_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$io$OutputStream_Z_java$lang$String__V = constructor((JObjectType("java/io/OutputStream"), jboolean.jniType, JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: jboolean, _ a2: java$lang$String?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$io$OutputStream_Z_java$lang$String__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$PrintStream$.java$io$PrintStream_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintStream_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$PrintStream_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$PrintStream_checkError__Z = invoker("checkError", returns: jboolean.jniType)
    public func checkError() throws -> jboolean {
        return try java$io$PrintStream$.java$io$PrintStream_checkError__Z(jobj)()
    }

    private static let java$io$PrintStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PrintStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$PrintStream_print_Z__V = invoker("print", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func print(a0: jboolean) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_Z__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_C__V = invoker("print", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func print(a0: jchar) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_C__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_I__V = invoker("print", returns: JVoid.jniType, arguments: (jint.jniType))
    public func print(a0: jint) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_I__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_J__V = invoker("print", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func print(a0: jlong) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_J__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_F__V = invoker("print", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func print(a0: jfloat) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_F__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_D__V = invoker("print", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func print(a0: jdouble) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_D__V(jobj)(a0)
    }

    private static let java$io$PrintStream_print_AC__V = invoker("print", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func print(a0: [jchar]?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PrintStream_print_java$lang$String__V = invoker("print", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func print(a0: java$lang$String?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintStream_print_java$lang$Object__V = invoker("print", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func print(a0: java$lang$Object?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_print_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintStream_println__V = invoker("println", returns: JVoid.jniType)
    public func println() throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println__V(jobj)()
    }

    private static let java$io$PrintStream_println_Z__V = invoker("println", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func println(a0: jboolean) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_Z__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_C__V = invoker("println", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func println(a0: jchar) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_C__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_I__V = invoker("println", returns: JVoid.jniType, arguments: (jint.jniType))
    public func println(a0: jint) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_I__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_J__V = invoker("println", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func println(a0: jlong) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_J__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_F__V = invoker("println", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func println(a0: jfloat) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_F__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_D__V = invoker("println", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func println(a0: jdouble) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_D__V(jobj)(a0)
    }

    private static let java$io$PrintStream_println_AC__V = invoker("println", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func println(a0: [jchar]?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PrintStream_println_java$lang$String__V = invoker("println", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func println(a0: java$lang$String?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintStream_println_java$lang$Object__V = invoker("println", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func println(a0: java$lang$Object?) throws -> Void {
        return try java$io$PrintStream$.java$io$PrintStream_println_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintStream_printf_java$lang$String_Ajava$lang$Object__java$io$PrintStream = invoker("printf", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func printf(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_printf_java$lang$String_Ajava$lang$Object__java$io$PrintStream(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintStream_printf_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintStream = invoker("printf", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func printf(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_printf_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintStream(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintStream_format_java$lang$String_Ajava$lang$Object__java$io$PrintStream = invoker("format", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_format_java$lang$String_Ajava$lang$Object__java$io$PrintStream(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintStream_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintStream = invoker("format", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintStream(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintStream_append_java$lang$CharSequence__java$io$PrintStream = invoker("append", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_append_java$lang$CharSequence__java$io$PrintStream(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$PrintStream_append_java$lang$CharSequence_I_I__java$io$PrintStream = invoker("append", returns: JObjectType("java/io/PrintStream"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_append_java$lang$CharSequence_I_I__java$io$PrintStream(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$io$PrintStream_append_C__java$io$PrintStream = invoker("append", returns: JObjectType("java/io/PrintStream"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$io$PrintStream$.java$io$PrintStream_append_C__java$io$PrintStream(jobj)(a0))
    }

    private static let java$io$PrintStream_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$PrintStream$.java$io$PrintStream_append_C__java$lang$Appendable(jobj)(a0))
    }

    private static let java$io$PrintStream_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$PrintStream$.java$io$PrintStream_append_java$lang$CharSequence_I_I__java$lang$Appendable(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$io$PrintStream_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$PrintStream$.java$io$PrintStream_append_java$lang$CharSequence__java$lang$Appendable(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$io$PrintStream$ = java$io$PrintStream

public class java$io$PrintWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PrintWriter_init_java$io$Writer__V = constructor((JObjectType("java/io/Writer")))
    public convenience init!(_ a0: java$io$Writer?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$Writer__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$io$Writer_Z__V = constructor((JObjectType("java/io/Writer"), jboolean.jniType))
    public convenience init!(_ a0: java$io$Writer?, _ a1: jboolean) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$Writer_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$io$OutputStream_Z__V = constructor((JObjectType("java/io/OutputStream"), jboolean.jniType))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: jboolean) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$OutputStream_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$PrintWriter$.java$io$PrintWriter_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PrintWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$PrintWriter_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$PrintWriter_checkError__Z = invoker("checkError", returns: jboolean.jniType)
    public func checkError() throws -> jboolean {
        return try java$io$PrintWriter$.java$io$PrintWriter_checkError__Z(jobj)()
    }

    private static let java$io$PrintWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PrintWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$PrintWriter_write_AC__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    private static let java$io$PrintWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$PrintWriter_write_java$lang$String__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$PrintWriter_print_Z__V = invoker("print", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func print(a0: jboolean) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_Z__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_C__V = invoker("print", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func print(a0: jchar) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_C__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_I__V = invoker("print", returns: JVoid.jniType, arguments: (jint.jniType))
    public func print(a0: jint) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_I__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_J__V = invoker("print", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func print(a0: jlong) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_J__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_F__V = invoker("print", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func print(a0: jfloat) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_F__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_D__V = invoker("print", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func print(a0: jdouble) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_D__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_print_AC__V = invoker("print", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func print(a0: [jchar]?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PrintWriter_print_java$lang$String__V = invoker("print", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func print(a0: java$lang$String?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintWriter_print_java$lang$Object__V = invoker("print", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func print(a0: java$lang$Object?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_print_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintWriter_println__V = invoker("println", returns: JVoid.jniType)
    public func println() throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println__V(jobj)()
    }

    private static let java$io$PrintWriter_println_Z__V = invoker("println", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func println(a0: jboolean) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_Z__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_C__V = invoker("println", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func println(a0: jchar) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_C__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_I__V = invoker("println", returns: JVoid.jniType, arguments: (jint.jniType))
    public func println(a0: jint) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_I__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_J__V = invoker("println", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func println(a0: jlong) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_J__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_F__V = invoker("println", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func println(a0: jfloat) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_F__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_D__V = invoker("println", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func println(a0: jdouble) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_D__V(jobj)(a0)
    }

    private static let java$io$PrintWriter_println_AC__V = invoker("println", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func println(a0: [jchar]?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PrintWriter_println_java$lang$String__V = invoker("println", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func println(a0: java$lang$String?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintWriter_println_java$lang$Object__V = invoker("println", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func println(a0: java$lang$Object?) throws -> Void {
        return try java$io$PrintWriter$.java$io$PrintWriter_println_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$PrintWriter_printf_java$lang$String_Ajava$lang$Object__java$io$PrintWriter = invoker("printf", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func printf(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$io$PrintWriter$.java$io$PrintWriter_printf_java$lang$String_Ajava$lang$Object__java$io$PrintWriter(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintWriter_printf_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintWriter = invoker("printf", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func printf(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$io$PrintWriter$.java$io$PrintWriter_printf_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintWriter(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintWriter_format_java$lang$String_Ajava$lang$Object__java$io$PrintWriter = invoker("format", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$io$PrintWriter$.java$io$PrintWriter_format_java$lang$String_Ajava$lang$Object__java$io$PrintWriter(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintWriter_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintWriter = invoker("format", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$io$PrintWriter$.java$io$PrintWriter_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$io$PrintWriter(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$io$PrintWriter_append_java$lang$CharSequence__java$io$PrintWriter = invoker("append", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$PrintWriter_append_java$lang$CharSequence_I_I__java$io$PrintWriter = invoker("append", returns: JObjectType("java/io/PrintWriter"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$PrintWriter_append_C__java$io$PrintWriter = invoker("append", returns: JObjectType("java/io/PrintWriter"), arguments: (jchar.jniType))
    private static let java$io$PrintWriter_append_C__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (jchar.jniType))
    private static let java$io$PrintWriter_append_java$lang$CharSequence_I_I__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$PrintWriter_append_java$lang$CharSequence__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$PrintWriter_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    private static let java$io$PrintWriter_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$PrintWriter_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
}

public typealias java$io$PrintWriter$ = java$io$PrintWriter

public class java$io$PushbackInputStream : java$io$FilterInputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PushbackInputStream_init_java$io$InputStream_I__V = constructor((JObjectType("java/io/InputStream"), jint.jniType))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: jint) throws {
        let jobj = try java$io$PushbackInputStream$.java$io$PushbackInputStream_init_java$io$InputStream_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PushbackInputStream_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$PushbackInputStream$.java$io$PushbackInputStream_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PushbackInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$PushbackInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$PushbackInputStream_unread_I__V = invoker("unread", returns: JVoid.jniType, arguments: (jint.jniType))
    public func unread(a0: jint) throws -> Void {
        return try java$io$PushbackInputStream$.java$io$PushbackInputStream_unread_I__V(jobj)(a0)
    }

    private static let java$io$PushbackInputStream_unread_AB_I_I__V = invoker("unread", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func unread(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$PushbackInputStream$.java$io$PushbackInputStream_unread_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$PushbackInputStream_unread_AB__V = invoker("unread", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func unread(a0: [jbyte]?) throws -> Void {
        return try java$io$PushbackInputStream$.java$io$PushbackInputStream_unread_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PushbackInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$PushbackInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$PushbackInputStream_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$PushbackInputStream_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PushbackInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$PushbackInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$PushbackInputStream$ = java$io$PushbackInputStream

public class java$io$PushbackReader : java$io$FilterReader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$PushbackReader_init_java$io$Reader_I__V = constructor((JObjectType("java/io/Reader"), jint.jniType))
    public convenience init!(_ a0: java$io$Reader?, _ a1: jint) throws {
        let jobj = try java$io$PushbackReader$.java$io$PushbackReader_init_java$io$Reader_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$io$PushbackReader_init_java$io$Reader__V = constructor((JObjectType("java/io/Reader")))
    public convenience init!(_ a0: java$io$Reader?) throws {
        let jobj = try java$io$PushbackReader$.java$io$PushbackReader_init_java$io$Reader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$PushbackReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$PushbackReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$PushbackReader_unread_I__V = invoker("unread", returns: JVoid.jniType, arguments: (jint.jniType))
    public func unread(a0: jint) throws -> Void {
        return try java$io$PushbackReader$.java$io$PushbackReader_unread_I__V(jobj)(a0)
    }

    private static let java$io$PushbackReader_unread_AC_I_I__V = invoker("unread", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public func unread(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$PushbackReader$.java$io$PushbackReader_unread_AC_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$PushbackReader_unread_AC__V = invoker("unread", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func unread(a0: [jchar]?) throws -> Void {
        return try java$io$PushbackReader$.java$io$PushbackReader_unread_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$PushbackReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$PushbackReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$PushbackReader_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$PushbackReader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$PushbackReader_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$PushbackReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
}

public typealias java$io$PushbackReader$ = java$io$PushbackReader

public class java$io$RandomAccessFile : java$lang$Object$, java$io$DataOutput, java$io$DataInput, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$RandomAccessFile_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$RandomAccessFile$.java$io$RandomAccessFile_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$RandomAccessFile_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$io$RandomAccessFile$.java$io$RandomAccessFile_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$RandomAccessFile_getFD__java$io$FileDescriptor = invoker("getFD", returns: JObjectType("java/io/FileDescriptor"))
    public func getFD() throws -> java$io$FileDescriptor? {
        return try java$io$FileDescriptor$(jobj: java$io$RandomAccessFile$.java$io$RandomAccessFile_getFD__java$io$FileDescriptor(jobj)())
    }

    private static let java$io$RandomAccessFile_getChannel__java$nio$channels$FileChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/FileChannel"))
    public func getChannel() throws -> java$nio$channels$FileChannel? {
        return try java$nio$channels$FileChannel$(jobj: java$io$RandomAccessFile$.java$io$RandomAccessFile_getChannel__java$nio$channels$FileChannel(jobj)())
    }

    private static let java$io$RandomAccessFile_read__I = invoker("read", returns: jint.jniType)
    public func read() throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_read__I(jobj)()
    }

    private static let java$io$RandomAccessFile_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func read(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_read_AB_I_I__I(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$RandomAccessFile_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    public func read(a0: [jbyte]?) throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_read_AB__I(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$RandomAccessFile_readFully_AB__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func readFully(a0: [jbyte]?) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readFully_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$RandomAccessFile_readFully_AB_I_I__V = invoker("readFully", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func readFully(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readFully_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$RandomAccessFile_skipBytes_I__I = invoker("skipBytes", returns: jint.jniType, arguments: (jint.jniType))
    public func skipBytes(a0: jint) throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_skipBytes_I__I(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    public func write(a0: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_write_I__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func write(a0: [jbyte]?) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_write_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$RandomAccessFile_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func write(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_write_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$RandomAccessFile_getFilePointer__J = invoker("getFilePointer", returns: jlong.jniType)
    public func getFilePointer() throws -> jlong {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_getFilePointer__J(jobj)()
    }

    private static let java$io$RandomAccessFile_seek_J__V = invoker("seek", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func seek(a0: jlong) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_seek_J__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_length__J = invoker("length", returns: jlong.jniType)
    public func length() throws -> jlong {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_length__J(jobj)()
    }

    private static let java$io$RandomAccessFile_setLength_J__V = invoker("setLength", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setLength(a0: jlong) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_setLength_J__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_close__V(jobj)()
    }

    private static let java$io$RandomAccessFile_readBoolean__Z = invoker("readBoolean", returns: jboolean.jniType)
    public func readBoolean() throws -> jboolean {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readBoolean__Z(jobj)()
    }

    private static let java$io$RandomAccessFile_readByte__B = invoker("readByte", returns: jbyte.jniType)
    public func readByte() throws -> jbyte {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readByte__B(jobj)()
    }

    private static let java$io$RandomAccessFile_readUnsignedByte__I = invoker("readUnsignedByte", returns: jint.jniType)
    public func readUnsignedByte() throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readUnsignedByte__I(jobj)()
    }

    private static let java$io$RandomAccessFile_readShort__S = invoker("readShort", returns: jshort.jniType)
    public func readShort() throws -> jshort {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readShort__S(jobj)()
    }

    private static let java$io$RandomAccessFile_readUnsignedShort__I = invoker("readUnsignedShort", returns: jint.jniType)
    public func readUnsignedShort() throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readUnsignedShort__I(jobj)()
    }

    private static let java$io$RandomAccessFile_readChar__C = invoker("readChar", returns: jchar.jniType)
    public func readChar() throws -> jchar {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readChar__C(jobj)()
    }

    private static let java$io$RandomAccessFile_readInt__I = invoker("readInt", returns: jint.jniType)
    public func readInt() throws -> jint {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readInt__I(jobj)()
    }

    private static let java$io$RandomAccessFile_readLong__J = invoker("readLong", returns: jlong.jniType)
    public func readLong() throws -> jlong {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readLong__J(jobj)()
    }

    private static let java$io$RandomAccessFile_readFloat__F = invoker("readFloat", returns: jfloat.jniType)
    public func readFloat() throws -> jfloat {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readFloat__F(jobj)()
    }

    private static let java$io$RandomAccessFile_readDouble__D = invoker("readDouble", returns: jdouble.jniType)
    public func readDouble() throws -> jdouble {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_readDouble__D(jobj)()
    }

    private static let java$io$RandomAccessFile_readLine__java$lang$String = invoker("readLine", returns: JObjectType("java/lang/String"))
    public func readLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$RandomAccessFile$.java$io$RandomAccessFile_readLine__java$lang$String(jobj)())
    }

    private static let java$io$RandomAccessFile_readUTF__java$lang$String = invoker("readUTF", returns: JObjectType("java/lang/String"))
    public func readUTF() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$io$RandomAccessFile$.java$io$RandomAccessFile_readUTF__java$lang$String(jobj)())
    }

    private static let java$io$RandomAccessFile_writeBoolean_Z__V = invoker("writeBoolean", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func writeBoolean(a0: jboolean) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeBoolean_Z__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeByte_I__V = invoker("writeByte", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeByte(a0: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeByte_I__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeShort_I__V = invoker("writeShort", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeShort(a0: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeShort_I__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeChar_I__V = invoker("writeChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeChar(a0: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeChar_I__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeInt_I__V = invoker("writeInt", returns: JVoid.jniType, arguments: (jint.jniType))
    public func writeInt(a0: jint) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeInt_I__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeLong_J__V = invoker("writeLong", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func writeLong(a0: jlong) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeLong_J__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeFloat_F__V = invoker("writeFloat", returns: JVoid.jniType, arguments: (jfloat.jniType))
    public func writeFloat(a0: jfloat) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeFloat_F__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeDouble_D__V = invoker("writeDouble", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func writeDouble(a0: jdouble) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeDouble_D__V(jobj)(a0)
    }

    private static let java$io$RandomAccessFile_writeBytes_java$lang$String__V = invoker("writeBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeBytes(a0: java$lang$String?) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeBytes_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$RandomAccessFile_writeChars_java$lang$String__V = invoker("writeChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeChars(a0: java$lang$String?) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeChars_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$RandomAccessFile_writeUTF_java$lang$String__V = invoker("writeUTF", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func writeUTF(a0: java$lang$String?) throws -> Void {
        return try java$io$RandomAccessFile$.java$io$RandomAccessFile_writeUTF_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$io$RandomAccessFile$ = java$io$RandomAccessFile

public class java$io$Reader : java$lang$Object$, java$lang$Readable, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Reader_read_java$nio$CharBuffer__I = invoker("read", returns: jint.jniType, arguments: (JObjectType("java/nio/CharBuffer")))
    public func read(a0: java$nio$CharBuffer?) throws -> jint {
        return try java$io$Reader$.java$io$Reader_read_java$nio$CharBuffer__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$Reader_read__I = invoker("read", returns: jint.jniType)
    public func read() throws -> jint {
        return try java$io$Reader$.java$io$Reader_read__I(jobj)()
    }

    private static let java$io$Reader_read_AC__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType)))
    public func read(a0: [jchar]?) throws -> jint {
        return try java$io$Reader$.java$io$Reader_read_AC__I(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$Reader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public func read(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$io$Reader$.java$io$Reader_read_AC_I_I__I(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$Reader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    public func skip(a0: jlong) throws -> jlong {
        return try java$io$Reader$.java$io$Reader_skip_J__J(jobj)(a0)
    }

    private static let java$io$Reader_ready__Z = invoker("ready", returns: jboolean.jniType)
    public func ready() throws -> jboolean {
        return try java$io$Reader$.java$io$Reader_ready__Z(jobj)()
    }

    private static let java$io$Reader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    public func markSupported() throws -> jboolean {
        return try java$io$Reader$.java$io$Reader_markSupported__Z(jobj)()
    }

    private static let java$io$Reader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    public func mark(a0: jint) throws -> Void {
        return try java$io$Reader$.java$io$Reader_mark_I__V(jobj)(a0)
    }

    private static let java$io$Reader_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$io$Reader$.java$io$Reader_reset__V(jobj)()
    }

    private static let java$io$Reader_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$io$Reader$.java$io$Reader_close__V(jobj)()
    }

}

public typealias java$io$Reader$ = java$io$Reader

public class java$io$SequenceInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$SequenceInputStream_init_java$util$Enumeration__V = constructor((JObjectType("java/util/Enumeration")))
    public convenience init!(_ a0: java$util$Enumeration?) throws {
        let jobj = try java$io$SequenceInputStream$.java$io$SequenceInputStream_init_java$util$Enumeration__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$SequenceInputStream_init_java$io$InputStream_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream"), JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: java$io$InputStream?) throws {
        let jobj = try java$io$SequenceInputStream$.java$io$SequenceInputStream_init_java$io$InputStream_java$io$InputStream__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$SequenceInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$SequenceInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$SequenceInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$SequenceInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$SequenceInputStream$ = java$io$SequenceInputStream

public final class java$io$SerialCallbackContext : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$SerialCallbackContext_init_java$lang$Object_java$io$ObjectStreamClass__V = constructor((JObjectType("java/lang/Object"), JObjectType("java/io/ObjectStreamClass")))
    public convenience init!(_ a0: java$lang$Object?, _ a1: java$io$ObjectStreamClass?) throws {
        let jobj = try java$io$SerialCallbackContext$.java$io$SerialCallbackContext_init_java$lang$Object_java$io$ObjectStreamClass__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$SerialCallbackContext_getObj__java$lang$Object = invoker("getObj", returns: JObjectType("java/lang/Object"))
    public func getObj() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$io$SerialCallbackContext$.java$io$SerialCallbackContext_getObj__java$lang$Object(jobj)())
    }

    private static let java$io$SerialCallbackContext_getDesc__java$io$ObjectStreamClass = invoker("getDesc", returns: JObjectType("java/io/ObjectStreamClass"))
    public func getDesc() throws -> java$io$ObjectStreamClass? {
        return try java$io$ObjectStreamClass$(jobj: java$io$SerialCallbackContext$.java$io$SerialCallbackContext_getDesc__java$io$ObjectStreamClass(jobj)())
    }

    private static let java$io$SerialCallbackContext_check__V = invoker("check", returns: JVoid.jniType)
    public func check() throws -> Void {
        return try java$io$SerialCallbackContext$.java$io$SerialCallbackContext_check__V(jobj)()
    }

    private static let java$io$SerialCallbackContext_setUsed__V = invoker("setUsed", returns: JVoid.jniType)
    public func setUsed() throws -> Void {
        return try java$io$SerialCallbackContext$.java$io$SerialCallbackContext_setUsed__V(jobj)()
    }

}

public typealias java$io$SerialCallbackContext$ = java$io$SerialCallbackContext

public protocol java$io$Serializable : JavaObject {
}

public class java$io$Serializable$ : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$io$Serializable {
}

public class java$io$StreamCorruptedException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$StreamCorruptedException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$StreamCorruptedException$.java$io$StreamCorruptedException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$StreamCorruptedException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$StreamCorruptedException$.java$io$StreamCorruptedException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$io$StreamCorruptedException$ = java$io$StreamCorruptedException

public class java$io$StreamTokenizer : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$StreamTokenizer_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$io$StreamTokenizer$.java$io$StreamTokenizer_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$StreamTokenizer_init_java$io$Reader__V = constructor((JObjectType("java/io/Reader")))
    public convenience init!(_ a0: java$io$Reader?) throws {
        let jobj = try java$io$StreamTokenizer$.java$io$StreamTokenizer_init_java$io$Reader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$StreamTokenizer_resetSyntax__V = invoker("resetSyntax", returns: JVoid.jniType)
    public func resetSyntax() throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_resetSyntax__V(jobj)()
    }

    private static let java$io$StreamTokenizer_wordChars_I_I__V = invoker("wordChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func wordChars(a0: jint, _ a1: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_wordChars_I_I__V(jobj)(a0, a1)
    }

    private static let java$io$StreamTokenizer_whitespaceChars_I_I__V = invoker("whitespaceChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func whitespaceChars(a0: jint, _ a1: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_whitespaceChars_I_I__V(jobj)(a0, a1)
    }

    private static let java$io$StreamTokenizer_ordinaryChars_I_I__V = invoker("ordinaryChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func ordinaryChars(a0: jint, _ a1: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_ordinaryChars_I_I__V(jobj)(a0, a1)
    }

    private static let java$io$StreamTokenizer_ordinaryChar_I__V = invoker("ordinaryChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func ordinaryChar(a0: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_ordinaryChar_I__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_commentChar_I__V = invoker("commentChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func commentChar(a0: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_commentChar_I__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_quoteChar_I__V = invoker("quoteChar", returns: JVoid.jniType, arguments: (jint.jniType))
    public func quoteChar(a0: jint) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_quoteChar_I__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_parseNumbers__V = invoker("parseNumbers", returns: JVoid.jniType)
    public func parseNumbers() throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_parseNumbers__V(jobj)()
    }

    private static let java$io$StreamTokenizer_eolIsSignificant_Z__V = invoker("eolIsSignificant", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func eolIsSignificant(a0: jboolean) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_eolIsSignificant_Z__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_slashStarComments_Z__V = invoker("slashStarComments", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func slashStarComments(a0: jboolean) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_slashStarComments_Z__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_slashSlashComments_Z__V = invoker("slashSlashComments", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func slashSlashComments(a0: jboolean) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_slashSlashComments_Z__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_lowerCaseMode_Z__V = invoker("lowerCaseMode", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func lowerCaseMode(a0: jboolean) throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_lowerCaseMode_Z__V(jobj)(a0)
    }

    private static let java$io$StreamTokenizer_nextToken__I = invoker("nextToken", returns: jint.jniType)
    public func nextToken() throws -> jint {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_nextToken__I(jobj)()
    }

    private static let java$io$StreamTokenizer_pushBack__V = invoker("pushBack", returns: JVoid.jniType)
    public func pushBack() throws -> Void {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_pushBack__V(jobj)()
    }

    private static let java$io$StreamTokenizer_lineno__I = invoker("lineno", returns: jint.jniType)
    public func lineno() throws -> jint {
        return try java$io$StreamTokenizer$.java$io$StreamTokenizer_lineno__I(jobj)()
    }

    private static let java$io$StreamTokenizer_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$io$StreamTokenizer$ = java$io$StreamTokenizer

public class java$io$StringBufferInputStream : java$io$InputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$StringBufferInputStream_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$StringBufferInputStream$.java$io$StringBufferInputStream_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$StringBufferInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$StringBufferInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$io$StringBufferInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$StringBufferInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$io$StringBufferInputStream_reset__V = invoker("reset", returns: JVoid.jniType)
}

public typealias java$io$StringBufferInputStream$ = java$io$StringBufferInputStream

public class java$io$StringReader : java$io$Reader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$StringReader_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$StringReader$.java$io$StringReader_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$StringReader_read__I = invoker("read", returns: jint.jniType)
    private static let java$io$StringReader_read_AC_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$StringReader_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$io$StringReader_ready__Z = invoker("ready", returns: jboolean.jniType)
    private static let java$io$StringReader_markSupported__Z = invoker("markSupported", returns: jboolean.jniType)
    private static let java$io$StringReader_mark_I__V = invoker("mark", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$StringReader_reset__V = invoker("reset", returns: JVoid.jniType)
    private static let java$io$StringReader_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$io$StringReader$ = java$io$StringReader

public class java$io$StringWriter : java$io$Writer$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$StringWriter_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$StringWriter$.java$io$StringWriter_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$StringWriter_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$io$StringWriter$.java$io$StringWriter_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$io$StringWriter_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$io$StringWriter_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$io$StringWriter_write_java$lang$String__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$StringWriter_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$io$StringWriter_append_java$lang$CharSequence__java$io$StringWriter = invoker("append", returns: JObjectType("java/io/StringWriter"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$StringWriter_append_java$lang$CharSequence_I_I__java$io$StringWriter = invoker("append", returns: JObjectType("java/io/StringWriter"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$StringWriter_append_C__java$io$StringWriter = invoker("append", returns: JObjectType("java/io/StringWriter"), arguments: (jchar.jniType))
    private static let java$io$StringWriter_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$io$StringWriter_getBuffer__java$lang$StringBuffer = invoker("getBuffer", returns: JObjectType("java/lang/StringBuffer"))
    public func getBuffer() throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$io$StringWriter$.java$io$StringWriter_getBuffer__java$lang$StringBuffer(jobj)())
    }

    private static let java$io$StringWriter_flush__V = invoker("flush", returns: JVoid.jniType)
    private static let java$io$StringWriter_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$io$StringWriter_append_C__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (jchar.jniType))
    private static let java$io$StringWriter_append_java$lang$CharSequence_I_I__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$StringWriter_append_java$lang$CharSequence__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$io$StringWriter_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    private static let java$io$StringWriter_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$io$StringWriter_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
}

public typealias java$io$StringWriter$ = java$io$StringWriter

public class java$io$SyncFailedException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$SyncFailedException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$SyncFailedException$.java$io$SyncFailedException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$SyncFailedException$ = java$io$SyncFailedException

public class java$io$UTFDataFormatException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$UTFDataFormatException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$UTFDataFormatException$.java$io$UTFDataFormatException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$UTFDataFormatException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$UTFDataFormatException$.java$io$UTFDataFormatException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$UTFDataFormatException$ = java$io$UTFDataFormatException

public class java$io$UncheckedIOException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$UncheckedIOException_init_java$lang$String_java$io$IOException__V = constructor((JObjectType("java/lang/String"), JObjectType("java/io/IOException")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$io$IOException?) throws {
        let jobj = try java$io$UncheckedIOException$.java$io$UncheckedIOException_init_java$lang$String_java$io$IOException__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$UncheckedIOException_init_java$io$IOException__V = constructor((JObjectType("java/io/IOException")))
    public convenience init!(_ a0: java$io$IOException?) throws {
        let jobj = try java$io$UncheckedIOException$.java$io$UncheckedIOException_init_java$io$IOException__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$UncheckedIOException_getCause__java$io$IOException = invoker("getCause", returns: JObjectType("java/io/IOException"))
    private static let java$io$UncheckedIOException_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$io$UncheckedIOException$ = java$io$UncheckedIOException

public class java$io$UnixFileSystem : java$io$FileSystem$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$UnixFileSystem_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$UnixFileSystem$.java$io$UnixFileSystem_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$UnixFileSystem_getSeparator__C = invoker("getSeparator", returns: jchar.jniType)
    private static let java$io$UnixFileSystem_getPathSeparator__C = invoker("getPathSeparator", returns: jchar.jniType)
    private static let java$io$UnixFileSystem_normalize_java$lang$String__java$lang$String = invoker("normalize", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_prefixLength_java$lang$String__I = invoker("prefixLength", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_resolve_java$lang$String_java$lang$String__java$lang$String = invoker("resolve", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_getDefaultParent__java$lang$String = invoker("getDefaultParent", returns: JObjectType("java/lang/String"))
    private static let java$io$UnixFileSystem_fromURIPath_java$lang$String__java$lang$String = invoker("fromURIPath", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_isAbsolute_java$io$File__Z = invoker("isAbsolute", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_resolve_java$io$File__java$lang$String = invoker("resolve", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_canonicalize_java$lang$String__java$lang$String = invoker("canonicalize", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_getBooleanAttributes0_java$io$File__I = invoker("getBooleanAttributes0", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
    public func getBooleanAttributes0(a0: java$io$File?) throws -> jint {
        return try java$io$UnixFileSystem$.java$io$UnixFileSystem_getBooleanAttributes0_java$io$File__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$UnixFileSystem_getBooleanAttributes_java$io$File__I = invoker("getBooleanAttributes", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_checkAccess_java$io$File_I__Z = invoker("checkAccess", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jint.jniType))
    private static let java$io$UnixFileSystem_getLastModifiedTime_java$io$File__J = invoker("getLastModifiedTime", returns: jlong.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_getLength_java$io$File__J = invoker("getLength", returns: jlong.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_setPermission_java$io$File_I_Z_Z__Z = invoker("setPermission", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jint.jniType, jboolean.jniType, jboolean.jniType))
    private static let java$io$UnixFileSystem_createFileExclusively_java$lang$String__Z = invoker("createFileExclusively", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$io$UnixFileSystem_delete_java$io$File__Z = invoker("delete", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_list_java$io$File__Ajava$lang$String = invoker("list", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_createDirectory_java$io$File__Z = invoker("createDirectory", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_rename_java$io$File_java$io$File__Z = invoker("rename", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_setLastModifiedTime_java$io$File_J__Z = invoker("setLastModifiedTime", returns: jboolean.jniType, arguments: (JObjectType("java/io/File"), jlong.jniType))
    private static let java$io$UnixFileSystem_setReadOnly_java$io$File__Z = invoker("setReadOnly", returns: jboolean.jniType, arguments: (JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_listRoots__Ajava$io$File = invoker("listRoots", returns: JArray(JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_getSpace_java$io$File_I__J = invoker("getSpace", returns: jlong.jniType, arguments: (JObjectType("java/io/File"), jint.jniType))
    private static let java$io$UnixFileSystem_compare_java$io$File_java$io$File__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/io/File"), JObjectType("java/io/File")))
    private static let java$io$UnixFileSystem_hashCode_java$io$File__I = invoker("hashCode", returns: jint.jniType, arguments: (JObjectType("java/io/File")))
}

public typealias java$io$UnixFileSystem$ = java$io$UnixFileSystem

public class java$io$UnsupportedEncodingException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$UnsupportedEncodingException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$io$UnsupportedEncodingException$.java$io$UnsupportedEncodingException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$io$UnsupportedEncodingException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$io$UnsupportedEncodingException$.java$io$UnsupportedEncodingException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$io$UnsupportedEncodingException$ = java$io$UnsupportedEncodingException

public class java$io$WriteAbortedException : java$io$ObjectStreamException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$WriteAbortedException_init_java$lang$String_java$lang$Exception__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Exception")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Exception?) throws {
        let jobj = try java$io$WriteAbortedException$.java$io$WriteAbortedException_init_java$lang$String_java$lang$Exception__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$io$WriteAbortedException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
    private static let java$io$WriteAbortedException_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$io$WriteAbortedException$ = java$io$WriteAbortedException

public class java$io$Writer : java$lang$Object$, java$lang$Appendable, java$io$Closeable, java$io$Flushable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$io$Writer_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    public func write(a0: jint) throws -> Void {
        return try java$io$Writer$.java$io$Writer_write_I__V(jobj)(a0)
    }

    private static let java$io$Writer_write_AC__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public func write(a0: [jchar]?) throws -> Void {
        return try java$io$Writer$.java$io$Writer_write_AC__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$io$Writer_write_AC_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public func write(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$Writer$.java$io$Writer_write_AC_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$io$Writer_write_java$lang$String__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func write(a0: java$lang$String?) throws -> Void {
        return try java$io$Writer$.java$io$Writer_write_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$io$Writer_write_java$lang$String_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    public func write(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$io$Writer$.java$io$Writer_write_java$lang$String_I_I__V(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$io$Writer_append_java$lang$CharSequence__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: java$io$Writer$.java$io$Writer_append_java$lang$CharSequence__java$io$Writer(jobj)(a0?.jobj ?? nil))
    }

    private static let java$io$Writer_append_java$lang$CharSequence_I_I__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: java$io$Writer$.java$io$Writer_append_java$lang$CharSequence_I_I__java$io$Writer(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$io$Writer_append_C__java$io$Writer = invoker("append", returns: JObjectType("java/io/Writer"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: java$io$Writer$.java$io$Writer_append_C__java$io$Writer(jobj)(a0))
    }

    private static let java$io$Writer_flush__V = invoker("flush", returns: JVoid.jniType)
    public func flush() throws -> Void {
        return try java$io$Writer$.java$io$Writer_flush__V(jobj)()
    }

    private static let java$io$Writer_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$io$Writer$.java$io$Writer_close__V(jobj)()
    }

    private static let java$io$Writer_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$Writer$.java$io$Writer_append_C__java$lang$Appendable(jobj)(a0))
    }

    private static let java$io$Writer_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$Writer$.java$io$Writer_append_java$lang$CharSequence_I_I__java$lang$Appendable(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$io$Writer_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$io$Writer$.java$io$Writer_append_java$lang$CharSequence__java$lang$Appendable(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$io$Writer$ = java$io$Writer

public class java$lang$AbstractMethodError : java$lang$IncompatibleClassChangeError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$AbstractMethodError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$AbstractMethodError$.java$lang$AbstractMethodError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$AbstractMethodError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$AbstractMethodError$.java$lang$AbstractMethodError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$AbstractMethodError$ = java$lang$AbstractMethodError

public class java$lang$AbstractStringBuilder : java$lang$Object$, java$lang$Appendable, java$lang$CharSequence {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$AbstractStringBuilder_length__I = invoker("length", returns: jint.jniType)
    public func length() throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_length__I(jobj)()
    }

    private static let java$lang$AbstractStringBuilder_capacity__I = invoker("capacity", returns: jint.jniType)
    public func capacity() throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_capacity__I(jobj)()
    }

    private static let java$lang$AbstractStringBuilder_ensureCapacity_I__V = invoker("ensureCapacity", returns: JVoid.jniType, arguments: (jint.jniType))
    public func ensureCapacity(a0: jint) throws -> Void {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_ensureCapacity_I__V(jobj)(a0)
    }

    private static let java$lang$AbstractStringBuilder_trimToSize__V = invoker("trimToSize", returns: JVoid.jniType)
    public func trimToSize() throws -> Void {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_trimToSize__V(jobj)()
    }

    private static let java$lang$AbstractStringBuilder_setLength_I__V = invoker("setLength", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setLength(a0: jint) throws -> Void {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_setLength_I__V(jobj)(a0)
    }

    private static let java$lang$AbstractStringBuilder_charAt_I__C = invoker("charAt", returns: jchar.jniType, arguments: (jint.jniType))
    public func charAt(a0: jint) throws -> jchar {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_charAt_I__C(jobj)(a0)
    }

    private static let java$lang$AbstractStringBuilder_codePointAt_I__I = invoker("codePointAt", returns: jint.jniType, arguments: (jint.jniType))
    public func codePointAt(a0: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_codePointAt_I__I(jobj)(a0)
    }

    private static let java$lang$AbstractStringBuilder_codePointBefore_I__I = invoker("codePointBefore", returns: jint.jniType, arguments: (jint.jniType))
    public func codePointBefore(a0: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_codePointBefore_I__I(jobj)(a0)
    }

    private static let java$lang$AbstractStringBuilder_codePointCount_I_I__I = invoker("codePointCount", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func codePointCount(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_codePointCount_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$AbstractStringBuilder_offsetByCodePoints_I_I__I = invoker("offsetByCodePoints", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func offsetByCodePoints(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_offsetByCodePoints_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$AbstractStringBuilder_getChars_I_I_AC_I__V = invoker("getChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JArray(jchar.jniType), jint.jniType))
    public func getChars(a0: jint, _ a1: jint, _ a2: [jchar]?, _ a3: jint) throws -> Void {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_getChars_I_I_AC_I__V(jobj)(a0, a1, a2?.arrayToJArray() ?? nil, a3)
    }

    private static let java$lang$AbstractStringBuilder_setCharAt_I_C__V = invoker("setCharAt", returns: JVoid.jniType, arguments: (jint.jniType, jchar.jniType))
    public func setCharAt(a0: jint, _ a1: jchar) throws -> Void {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_setCharAt_I_C__V(jobj)(a0, a1)
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$Object__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/Object")))
    public func append(a0: java$lang$Object?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$Object__java$lang$AbstractStringBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$String__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/String")))
    public func append(a0: java$lang$String?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$String__java$lang$AbstractStringBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$StringBuffer__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/StringBuffer")))
    public func append(a0: java$lang$StringBuffer?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$StringBuffer__java$lang$AbstractStringBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$CharSequence__java$lang$AbstractStringBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$lang$AbstractStringBuilder_append_AC__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType)))
    public func append(a0: [jchar]?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_AC__java$lang$AbstractStringBuilder(jobj)(a0?.arrayToJArray() ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_append_AC_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public func append(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_AC_I_I__java$lang$AbstractStringBuilder(jobj)(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$lang$AbstractStringBuilder_append_Z__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jboolean.jniType))
    public func append(a0: jboolean) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_Z__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_C__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_C__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    public func append(a0: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_I__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_J__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jlong.jniType))
    public func append(a0: jlong) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_J__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_F__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jfloat.jniType))
    public func append(a0: jfloat) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_F__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_D__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jdouble.jniType))
    public func append(a0: jdouble) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_D__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_delete_I_I__java$lang$AbstractStringBuilder = invoker("delete", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    public func delete(a0: jint, _ a1: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_delete_I_I__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_appendCodePoint_I__java$lang$AbstractStringBuilder = invoker("appendCodePoint", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    public func appendCodePoint(a0: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_appendCodePoint_I__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_deleteCharAt_I__java$lang$AbstractStringBuilder = invoker("deleteCharAt", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    public func deleteCharAt(a0: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_deleteCharAt_I__java$lang$AbstractStringBuilder(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_replace_I_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("replace", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    public func replace(a0: jint, _ a1: jint, _ a2: java$lang$String?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_replace_I_I_java$lang$String__java$lang$AbstractStringBuilder(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_substring_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func substring(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_substring_I__java$lang$String(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_subSequence_I_I__java$lang$CharSequence = invoker("subSequence", returns: JObjectType("java/lang/CharSequence"), arguments: (jint.jniType, jint.jniType))
    public func subSequence(a0: jint, _ a1: jint) throws -> java$lang$CharSequence? {
        return try java$lang$CharSequence$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_subSequence_I_I__java$lang$CharSequence(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_substring_I_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    public func substring(a0: jint, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_substring_I_I__java$lang$String(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_AC_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType, jint.jniType))
    public func insert(a0: jint, _ a1: [jchar]?, _ a2: jint, _ a3: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_AC_I_I__java$lang$AbstractStringBuilder(jobj)(a0, a1?.arrayToJArray() ?? nil, a2, a3))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_java$lang$Object__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public func insert(a0: jint, _ a1: java$lang$Object?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_java$lang$Object__java$lang$AbstractStringBuilder(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/String")))
    public func insert(a0: jint, _ a1: java$lang$String?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_java$lang$String__java$lang$AbstractStringBuilder(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_AC__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType)))
    public func insert(a0: jint, _ a1: [jchar]?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_AC__java$lang$AbstractStringBuilder(jobj)(a0, a1?.arrayToJArray() ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence")))
    public func insert(a0: jint, _ a1: java$lang$CharSequence?) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_java$lang$CharSequence__java$lang$AbstractStringBuilder(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func insert(a0: jint, _ a1: java$lang$CharSequence?, _ a2: jint, _ a3: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder(jobj)(a0, a1?.jobj ?? nil, a2, a3))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_Z__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jboolean.jniType))
    public func insert(a0: jint, _ a1: jboolean) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_Z__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_C__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jchar.jniType))
    public func insert(a0: jint, _ a1: jchar) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_C__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    public func insert(a0: jint, _ a1: jint) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_I__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_J__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jlong.jniType))
    public func insert(a0: jint, _ a1: jlong) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_J__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_F__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jfloat.jniType))
    public func insert(a0: jint, _ a1: jfloat) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_F__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_insert_I_D__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jdouble.jniType))
    public func insert(a0: jint, _ a1: jdouble) throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_insert_I_D__java$lang$AbstractStringBuilder(jobj)(a0, a1))
    }

    private static let java$lang$AbstractStringBuilder_indexOf_java$lang$String__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func indexOf(a0: java$lang$String?) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_indexOf_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$AbstractStringBuilder_indexOf_java$lang$String_I__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func indexOf(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_indexOf_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$AbstractStringBuilder_lastIndexOf_java$lang$String__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func lastIndexOf(a0: java$lang$String?) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_lastIndexOf_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$AbstractStringBuilder_lastIndexOf_java$lang$String_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func lastIndexOf(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_lastIndexOf_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$AbstractStringBuilder_reverse__java$lang$AbstractStringBuilder = invoker("reverse", returns: JObjectType("java/lang/AbstractStringBuilder"))
    public func reverse() throws -> java$lang$AbstractStringBuilder? {
        return try java$lang$AbstractStringBuilder$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_reverse__java$lang$AbstractStringBuilder(jobj)())
    }

    private static let java$lang$AbstractStringBuilder_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$AbstractStringBuilder_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_C__java$lang$Appendable(jobj)(a0))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$CharSequence_I_I__java$lang$Appendable(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$lang$AbstractStringBuilder_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
    public func append(a0: java$lang$CharSequence?) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$AbstractStringBuilder$.java$lang$AbstractStringBuilder_append_java$lang$CharSequence__java$lang$Appendable(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$lang$AbstractStringBuilder$ = java$lang$AbstractStringBuilder

public protocol java$lang$Appendable : JavaObject {
    func append(a0: java$lang$CharSequence?) throws -> java$lang$Appendable?
    func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$Appendable?
    func append(a0: jchar) throws -> java$lang$Appendable?
}

public class java$lang$Appendable$ : java$lang$Object$, java$lang$Appendable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Appendable_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$lang$Appendable_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$Appendable_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
}

public extension java$lang$Appendable {
    func append(a0: java$lang$CharSequence?) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$Appendable$.java$lang$Appendable_append_java$lang$CharSequence__java$lang$Appendable(jobj)(a0?.jobj ?? nil))
    }

    func append(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$Appendable$.java$lang$Appendable_append_java$lang$CharSequence_I_I__java$lang$Appendable(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    func append(a0: jchar) throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$lang$Appendable$.java$lang$Appendable_append_C__java$lang$Appendable(jobj)(a0))
    }

}

public class java$lang$ApplicationShutdownHooks : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$ApplicationShutdownHooks$ = java$lang$ApplicationShutdownHooks

public class java$lang$ArithmeticException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ArithmeticException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ArithmeticException$.java$lang$ArithmeticException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ArithmeticException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ArithmeticException$.java$lang$ArithmeticException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ArithmeticException$ = java$lang$ArithmeticException

public class java$lang$ArrayIndexOutOfBoundsException : java$lang$IndexOutOfBoundsException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ArrayIndexOutOfBoundsException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ArrayIndexOutOfBoundsException$.java$lang$ArrayIndexOutOfBoundsException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ArrayIndexOutOfBoundsException_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$lang$ArrayIndexOutOfBoundsException$.java$lang$ArrayIndexOutOfBoundsException_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$ArrayIndexOutOfBoundsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ArrayIndexOutOfBoundsException$.java$lang$ArrayIndexOutOfBoundsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ArrayIndexOutOfBoundsException$ = java$lang$ArrayIndexOutOfBoundsException

public class java$lang$ArrayStoreException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ArrayStoreException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ArrayStoreException$.java$lang$ArrayStoreException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ArrayStoreException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ArrayStoreException$.java$lang$ArrayStoreException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ArrayStoreException$ = java$lang$ArrayStoreException

public class java$lang$AssertionStatusDirectives : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$AssertionStatusDirectives$ = java$lang$AssertionStatusDirectives

public protocol java$lang$AutoCloseable : JavaObject {
    func close() throws -> Void
}

public class java$lang$AutoCloseable$ : java$lang$Object$, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$AutoCloseable_close__V = invoker("close", returns: JVoid.jniType)
}

public extension java$lang$AutoCloseable {
    func close() throws -> Void {
        return try java$lang$AutoCloseable$.java$lang$AutoCloseable_close__V(jobj)()
    }

}

public final class java$lang$Boolean : java$lang$Object$, java$io$Serializable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Boolean_init_Z__V = constructor((jboolean.jniType))
    public convenience init!(_ a0: jboolean) throws {
        let jobj = try java$lang$Boolean$.java$lang$Boolean_init_Z__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Boolean_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Boolean$.java$lang$Boolean_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Boolean_parseBoolean_java$lang$String__Z = svoker("parseBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseBoolean(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_parseBoolean_java$lang$String__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$Boolean_booleanValue__Z = invoker("booleanValue", returns: jboolean.jniType)
    public func booleanValue() throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_booleanValue__Z(jobj)()
    }

    private static let java$lang$Boolean_valueOf_Z__java$lang$Boolean = svoker("valueOf", returns: JObjectType("java/lang/Boolean"), arguments: (jboolean.jniType))
    public static func valueOf(a0: jboolean) throws -> java$lang$Boolean? {
        return try java$lang$Boolean$(jobj: java$lang$Boolean$.java$lang$Boolean_valueOf_Z__java$lang$Boolean(a0))
    }

    private static let java$lang$Boolean_valueOf_java$lang$String__java$lang$Boolean = svoker("valueOf", returns: JObjectType("java/lang/Boolean"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Boolean? {
        return try java$lang$Boolean$(jobj: java$lang$Boolean$.java$lang$Boolean_valueOf_java$lang$String__java$lang$Boolean(a0?.jobj ?? nil))
    }

    private static let java$lang$Boolean_toString_Z__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType))
    public static func toString(a0: jboolean) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Boolean$.java$lang$Boolean_toString_Z__java$lang$String(a0))
    }

    private static let java$lang$Boolean_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Boolean_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Boolean_hashCode_Z__I = svoker("hashCode", returns: jint.jniType, arguments: (jboolean.jniType))
    public static func hashCode(a0: jboolean) throws -> jint {
        return try java$lang$Boolean$.java$lang$Boolean_hashCode_Z__I(a0)
    }

    private static let java$lang$Boolean_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Boolean_getBoolean_java$lang$String__Z = svoker("getBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public static func getBoolean(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_getBoolean_java$lang$String__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$Boolean_compareTo_java$lang$Boolean__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Boolean")))
    public func compareTo(a0: java$lang$Boolean?) throws -> jint {
        return try java$lang$Boolean$.java$lang$Boolean_compareTo_java$lang$Boolean__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Boolean_compare_Z_Z__I = svoker("compare", returns: jint.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public static func compare(a0: jboolean, _ a1: jboolean) throws -> jint {
        return try java$lang$Boolean$.java$lang$Boolean_compare_Z_Z__I(a0, a1)
    }

    private static let java$lang$Boolean_logicalAnd_Z_Z__Z = svoker("logicalAnd", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public static func logicalAnd(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_logicalAnd_Z_Z__Z(a0, a1)
    }

    private static let java$lang$Boolean_logicalOr_Z_Z__Z = svoker("logicalOr", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public static func logicalOr(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_logicalOr_Z_Z__Z(a0, a1)
    }

    private static let java$lang$Boolean_logicalXor_Z_Z__Z = svoker("logicalXor", returns: jboolean.jniType, arguments: (jboolean.jniType, jboolean.jniType))
    public static func logicalXor(a0: jboolean, _ a1: jboolean) throws -> jboolean {
        return try java$lang$Boolean$.java$lang$Boolean_logicalXor_Z_Z__Z(a0, a1)
    }

    private static let java$lang$Boolean_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Boolean$.java$lang$Boolean_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Boolean$ = java$lang$Boolean

public class java$lang$BootstrapMethodError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$BootstrapMethodError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$BootstrapMethodError$.java$lang$BootstrapMethodError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$BootstrapMethodError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$BootstrapMethodError$.java$lang$BootstrapMethodError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$BootstrapMethodError_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$BootstrapMethodError$.java$lang$BootstrapMethodError_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$BootstrapMethodError_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$BootstrapMethodError$.java$lang$BootstrapMethodError_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$BootstrapMethodError$ = java$lang$BootstrapMethodError

public final class java$lang$Byte : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Byte_toString_B__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jbyte.jniType))
    public static func toString(a0: jbyte) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Byte$.java$lang$Byte_toString_B__java$lang$String(a0))
    }

    private static let java$lang$Byte_valueOf_B__java$lang$Byte = svoker("valueOf", returns: JObjectType("java/lang/Byte"), arguments: (jbyte.jniType))
    public static func valueOf(a0: jbyte) throws -> java$lang$Byte? {
        return try java$lang$Byte$(jobj: java$lang$Byte$.java$lang$Byte_valueOf_B__java$lang$Byte(a0))
    }

    private static let java$lang$Byte_parseByte_java$lang$String_I__B = svoker("parseByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseByte(a0: java$lang$String?, _ a1: jint) throws -> jbyte {
        return try java$lang$Byte$.java$lang$Byte_parseByte_java$lang$String_I__B(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Byte_parseByte_java$lang$String__B = svoker("parseByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseByte(a0: java$lang$String?) throws -> jbyte {
        return try java$lang$Byte$.java$lang$Byte_parseByte_java$lang$String__B(a0?.jobj ?? nil)
    }

    private static let java$lang$Byte_valueOf_java$lang$String_I__java$lang$Byte = svoker("valueOf", returns: JObjectType("java/lang/Byte"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func valueOf(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Byte? {
        return try java$lang$Byte$(jobj: java$lang$Byte$.java$lang$Byte_valueOf_java$lang$String_I__java$lang$Byte(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Byte_valueOf_java$lang$String__java$lang$Byte = svoker("valueOf", returns: JObjectType("java/lang/Byte"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Byte? {
        return try java$lang$Byte$(jobj: java$lang$Byte$.java$lang$Byte_valueOf_java$lang$String__java$lang$Byte(a0?.jobj ?? nil))
    }

    private static let java$lang$Byte_decode_java$lang$String__java$lang$Byte = svoker("decode", returns: JObjectType("java/lang/Byte"), arguments: (JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?) throws -> java$lang$Byte? {
        return try java$lang$Byte$(jobj: java$lang$Byte$.java$lang$Byte_decode_java$lang$String__java$lang$Byte(a0?.jobj ?? nil))
    }

    private static let java$lang$Byte_init_B__V = constructor((jbyte.jniType))
    public convenience init!(_ a0: jbyte) throws {
        let jobj = try java$lang$Byte$.java$lang$Byte_init_B__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Byte_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Byte$.java$lang$Byte_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Byte_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Byte_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Byte_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Byte_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Byte_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Byte_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Byte_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Byte_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Byte_hashCode_B__I = svoker("hashCode", returns: jint.jniType, arguments: (jbyte.jniType))
    public static func hashCode(a0: jbyte) throws -> jint {
        return try java$lang$Byte$.java$lang$Byte_hashCode_B__I(a0)
    }

    private static let java$lang$Byte_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Byte_compareTo_java$lang$Byte__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Byte")))
    public func compareTo(a0: java$lang$Byte?) throws -> jint {
        return try java$lang$Byte$.java$lang$Byte_compareTo_java$lang$Byte__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Byte_compare_B_B__I = svoker("compare", returns: jint.jniType, arguments: (jbyte.jniType, jbyte.jniType))
    public static func compare(a0: jbyte, _ a1: jbyte) throws -> jint {
        return try java$lang$Byte$.java$lang$Byte_compare_B_B__I(a0, a1)
    }

    private static let java$lang$Byte_toUnsignedInt_B__I = svoker("toUnsignedInt", returns: jint.jniType, arguments: (jbyte.jniType))
    public static func toUnsignedInt(a0: jbyte) throws -> jint {
        return try java$lang$Byte$.java$lang$Byte_toUnsignedInt_B__I(a0)
    }

    private static let java$lang$Byte_toUnsignedLong_B__J = svoker("toUnsignedLong", returns: jlong.jniType, arguments: (jbyte.jniType))
    public static func toUnsignedLong(a0: jbyte) throws -> jlong {
        return try java$lang$Byte$.java$lang$Byte_toUnsignedLong_B__J(a0)
    }

    private static let java$lang$Byte_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Byte$.java$lang$Byte_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Byte$ = java$lang$Byte

public protocol java$lang$CharSequence : JavaObject {
    func length() throws -> jint
    func charAt(a0: jint) throws -> jchar
    func subSequence(a0: jint, _ a1: jint) throws -> java$lang$CharSequence?
    func toString() throws -> java$lang$String?
    func chars() throws -> java$util$stream$IntStream?
    func codePoints() throws -> java$util$stream$IntStream?
}

public class java$lang$CharSequence$ : java$lang$Object$, java$lang$CharSequence {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$CharSequence_length__I = invoker("length", returns: jint.jniType)
    private static let java$lang$CharSequence_charAt_I__C = invoker("charAt", returns: jchar.jniType, arguments: (jint.jniType))
    private static let java$lang$CharSequence_subSequence_I_I__java$lang$CharSequence = invoker("subSequence", returns: JObjectType("java/lang/CharSequence"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$CharSequence_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$CharSequence_chars__java$util$stream$IntStream = invoker("chars", returns: JObjectType("java/util/stream/IntStream"))
    private static let java$lang$CharSequence_codePoints__java$util$stream$IntStream = invoker("codePoints", returns: JObjectType("java/util/stream/IntStream"))
}

public extension java$lang$CharSequence {
    func length() throws -> jint {
        return try java$lang$CharSequence$.java$lang$CharSequence_length__I(jobj)()
    }

    func charAt(a0: jint) throws -> jchar {
        return try java$lang$CharSequence$.java$lang$CharSequence_charAt_I__C(jobj)(a0)
    }

    func subSequence(a0: jint, _ a1: jint) throws -> java$lang$CharSequence? {
        return try java$lang$CharSequence$(jobj: java$lang$CharSequence$.java$lang$CharSequence_subSequence_I_I__java$lang$CharSequence(jobj)(a0, a1))
    }

    func toString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$CharSequence$.java$lang$CharSequence_toString__java$lang$String(jobj)())
    }

    func chars() throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$lang$CharSequence$.java$lang$CharSequence_chars__java$util$stream$IntStream(jobj)())
    }

    func codePoints() throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$lang$CharSequence$.java$lang$CharSequence_codePoints__java$util$stream$IntStream(jobj)())
    }

}

public final class java$lang$Character : java$lang$Object$, java$io$Serializable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Character_init_C__V = constructor((jchar.jniType))
    public convenience init!(_ a0: jchar) throws {
        let jobj = try java$lang$Character$.java$lang$Character_init_C__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Character_valueOf_C__java$lang$Character = svoker("valueOf", returns: JObjectType("java/lang/Character"), arguments: (jchar.jniType))
    public static func valueOf(a0: jchar) throws -> java$lang$Character? {
        return try java$lang$Character$(jobj: java$lang$Character$.java$lang$Character_valueOf_C__java$lang$Character(a0))
    }

    private static let java$lang$Character_charValue__C = invoker("charValue", returns: jchar.jniType)
    public func charValue() throws -> jchar {
        return try java$lang$Character$.java$lang$Character_charValue__C(jobj)()
    }

    private static let java$lang$Character_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Character_hashCode_C__I = svoker("hashCode", returns: jint.jniType, arguments: (jchar.jniType))
    public static func hashCode(a0: jchar) throws -> jint {
        return try java$lang$Character$.java$lang$Character_hashCode_C__I(a0)
    }

    private static let java$lang$Character_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Character_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Character_toString_C__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jchar.jniType))
    public static func toString(a0: jchar) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Character$.java$lang$Character_toString_C__java$lang$String(a0))
    }

    private static let java$lang$Character_isValidCodePoint_I__Z = svoker("isValidCodePoint", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isValidCodePoint(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isValidCodePoint_I__Z(a0)
    }

    private static let java$lang$Character_isBmpCodePoint_I__Z = svoker("isBmpCodePoint", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isBmpCodePoint(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isBmpCodePoint_I__Z(a0)
    }

    private static let java$lang$Character_isSupplementaryCodePoint_I__Z = svoker("isSupplementaryCodePoint", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isSupplementaryCodePoint(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSupplementaryCodePoint_I__Z(a0)
    }

    private static let java$lang$Character_isHighSurrogate_C__Z = svoker("isHighSurrogate", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isHighSurrogate(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isHighSurrogate_C__Z(a0)
    }

    private static let java$lang$Character_isLowSurrogate_C__Z = svoker("isLowSurrogate", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isLowSurrogate(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLowSurrogate_C__Z(a0)
    }

    private static let java$lang$Character_isSurrogate_C__Z = svoker("isSurrogate", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isSurrogate(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSurrogate_C__Z(a0)
    }

    private static let java$lang$Character_isSurrogatePair_C_C__Z = svoker("isSurrogatePair", returns: jboolean.jniType, arguments: (jchar.jniType, jchar.jniType))
    public static func isSurrogatePair(a0: jchar, _ a1: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSurrogatePair_C_C__Z(a0, a1)
    }

    private static let java$lang$Character_charCount_I__I = svoker("charCount", returns: jint.jniType, arguments: (jint.jniType))
    public static func charCount(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_charCount_I__I(a0)
    }

    private static let java$lang$Character_toCodePoint_C_C__I = svoker("toCodePoint", returns: jint.jniType, arguments: (jchar.jniType, jchar.jniType))
    public static func toCodePoint(a0: jchar, _ a1: jchar) throws -> jint {
        return try java$lang$Character$.java$lang$Character_toCodePoint_C_C__I(a0, a1)
    }

    private static let java$lang$Character_codePointAt_java$lang$CharSequence_I__I = svoker("codePointAt", returns: jint.jniType, arguments: (JObjectType("java/lang/CharSequence"), jint.jniType))
    public static func codePointAt(a0: java$lang$CharSequence?, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointAt_java$lang$CharSequence_I__I(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Character_codePointAt_AC_I__I = svoker("codePointAt", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType))
    public static func codePointAt(a0: [jchar]?, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointAt_AC_I__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$lang$Character_codePointAt_AC_I_I__I = svoker("codePointAt", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func codePointAt(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointAt_AC_I_I__I(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$lang$Character_codePointBefore_java$lang$CharSequence_I__I = svoker("codePointBefore", returns: jint.jniType, arguments: (JObjectType("java/lang/CharSequence"), jint.jniType))
    public static func codePointBefore(a0: java$lang$CharSequence?, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointBefore_java$lang$CharSequence_I__I(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Character_codePointBefore_AC_I__I = svoker("codePointBefore", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType))
    public static func codePointBefore(a0: [jchar]?, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointBefore_AC_I__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$lang$Character_codePointBefore_AC_I_I__I = svoker("codePointBefore", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func codePointBefore(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointBefore_AC_I_I__I(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$lang$Character_highSurrogate_I__C = svoker("highSurrogate", returns: jchar.jniType, arguments: (jint.jniType))
    public static func highSurrogate(a0: jint) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_highSurrogate_I__C(a0)
    }

    private static let java$lang$Character_lowSurrogate_I__C = svoker("lowSurrogate", returns: jchar.jniType, arguments: (jint.jniType))
    public static func lowSurrogate(a0: jint) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_lowSurrogate_I__C(a0)
    }

    private static let java$lang$Character_toChars_I_AC_I__I = svoker("toChars", returns: jint.jniType, arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType))
    public static func toChars(a0: jint, _ a1: [jchar]?, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_toChars_I_AC_I__I(a0, a1?.arrayToJArray() ?? nil, a2)
    }

    private static let java$lang$Character_toChars_I__AC = svoker("toChars", returns: JArray(jchar.jniType), arguments: (jint.jniType))
    public static func toChars(a0: jint) throws -> [jchar]? {
        return try java$lang$Character$.java$lang$Character_toChars_I__AC(a0).jarrayToArray()
    }

    private static let java$lang$Character_codePointCount_java$lang$CharSequence_I_I__I = svoker("codePointCount", returns: jint.jniType, arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public static func codePointCount(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointCount_java$lang$CharSequence_I_I__I(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$Character_codePointCount_AC_I_I__I = svoker("codePointCount", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func codePointCount(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_codePointCount_AC_I_I__I(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$lang$Character_offsetByCodePoints_java$lang$CharSequence_I_I__I = svoker("offsetByCodePoints", returns: jint.jniType, arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    public static func offsetByCodePoints(a0: java$lang$CharSequence?, _ a1: jint, _ a2: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_offsetByCodePoints_java$lang$CharSequence_I_I__I(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$Character_offsetByCodePoints_AC_I_I_I_I__I = svoker("offsetByCodePoints", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public static func offsetByCodePoints(a0: [jchar]?, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_offsetByCodePoints_AC_I_I_I_I__I(a0?.arrayToJArray() ?? nil, a1, a2, a3, a4)
    }

    private static let java$lang$Character_isLowerCase_C__Z = svoker("isLowerCase", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isLowerCase(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLowerCase_C__Z(a0)
    }

    private static let java$lang$Character_isLowerCase_I__Z = svoker("isLowerCase", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isLowerCase(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLowerCase_I__Z(a0)
    }

    private static let java$lang$Character_isUpperCase_C__Z = svoker("isUpperCase", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isUpperCase(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUpperCase_C__Z(a0)
    }

    private static let java$lang$Character_isUpperCase_I__Z = svoker("isUpperCase", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isUpperCase(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUpperCase_I__Z(a0)
    }

    private static let java$lang$Character_isTitleCase_C__Z = svoker("isTitleCase", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isTitleCase(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isTitleCase_C__Z(a0)
    }

    private static let java$lang$Character_isTitleCase_I__Z = svoker("isTitleCase", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isTitleCase(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isTitleCase_I__Z(a0)
    }

    private static let java$lang$Character_isDigit_C__Z = svoker("isDigit", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isDigit(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isDigit_C__Z(a0)
    }

    private static let java$lang$Character_isDigit_I__Z = svoker("isDigit", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isDigit(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isDigit_I__Z(a0)
    }

    private static let java$lang$Character_isDefined_C__Z = svoker("isDefined", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isDefined(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isDefined_C__Z(a0)
    }

    private static let java$lang$Character_isDefined_I__Z = svoker("isDefined", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isDefined(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isDefined_I__Z(a0)
    }

    private static let java$lang$Character_isLetter_C__Z = svoker("isLetter", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isLetter(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLetter_C__Z(a0)
    }

    private static let java$lang$Character_isLetter_I__Z = svoker("isLetter", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isLetter(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLetter_I__Z(a0)
    }

    private static let java$lang$Character_isLetterOrDigit_C__Z = svoker("isLetterOrDigit", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isLetterOrDigit(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLetterOrDigit_C__Z(a0)
    }

    private static let java$lang$Character_isLetterOrDigit_I__Z = svoker("isLetterOrDigit", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isLetterOrDigit(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isLetterOrDigit_I__Z(a0)
    }

    private static let java$lang$Character_isJavaLetter_C__Z = svoker("isJavaLetter", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isJavaLetter(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaLetter_C__Z(a0)
    }

    private static let java$lang$Character_isJavaLetterOrDigit_C__Z = svoker("isJavaLetterOrDigit", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isJavaLetterOrDigit(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaLetterOrDigit_C__Z(a0)
    }

    private static let java$lang$Character_isAlphabetic_I__Z = svoker("isAlphabetic", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isAlphabetic(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isAlphabetic_I__Z(a0)
    }

    private static let java$lang$Character_isIdeographic_I__Z = svoker("isIdeographic", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isIdeographic(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isIdeographic_I__Z(a0)
    }

    private static let java$lang$Character_isJavaIdentifierStart_C__Z = svoker("isJavaIdentifierStart", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isJavaIdentifierStart(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaIdentifierStart_C__Z(a0)
    }

    private static let java$lang$Character_isJavaIdentifierStart_I__Z = svoker("isJavaIdentifierStart", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isJavaIdentifierStart(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaIdentifierStart_I__Z(a0)
    }

    private static let java$lang$Character_isJavaIdentifierPart_C__Z = svoker("isJavaIdentifierPart", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isJavaIdentifierPart(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaIdentifierPart_C__Z(a0)
    }

    private static let java$lang$Character_isJavaIdentifierPart_I__Z = svoker("isJavaIdentifierPart", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isJavaIdentifierPart(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isJavaIdentifierPart_I__Z(a0)
    }

    private static let java$lang$Character_isUnicodeIdentifierStart_C__Z = svoker("isUnicodeIdentifierStart", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isUnicodeIdentifierStart(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUnicodeIdentifierStart_C__Z(a0)
    }

    private static let java$lang$Character_isUnicodeIdentifierStart_I__Z = svoker("isUnicodeIdentifierStart", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isUnicodeIdentifierStart(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUnicodeIdentifierStart_I__Z(a0)
    }

    private static let java$lang$Character_isUnicodeIdentifierPart_C__Z = svoker("isUnicodeIdentifierPart", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isUnicodeIdentifierPart(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUnicodeIdentifierPart_C__Z(a0)
    }

    private static let java$lang$Character_isUnicodeIdentifierPart_I__Z = svoker("isUnicodeIdentifierPart", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isUnicodeIdentifierPart(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isUnicodeIdentifierPart_I__Z(a0)
    }

    private static let java$lang$Character_isIdentifierIgnorable_C__Z = svoker("isIdentifierIgnorable", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isIdentifierIgnorable(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isIdentifierIgnorable_C__Z(a0)
    }

    private static let java$lang$Character_isIdentifierIgnorable_I__Z = svoker("isIdentifierIgnorable", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isIdentifierIgnorable(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isIdentifierIgnorable_I__Z(a0)
    }

    private static let java$lang$Character_toLowerCase_C__C = svoker("toLowerCase", returns: jchar.jniType, arguments: (jchar.jniType))
    public static func toLowerCase(a0: jchar) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_toLowerCase_C__C(a0)
    }

    private static let java$lang$Character_toLowerCase_I__I = svoker("toLowerCase", returns: jint.jniType, arguments: (jint.jniType))
    public static func toLowerCase(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_toLowerCase_I__I(a0)
    }

    private static let java$lang$Character_toUpperCase_C__C = svoker("toUpperCase", returns: jchar.jniType, arguments: (jchar.jniType))
    public static func toUpperCase(a0: jchar) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_toUpperCase_C__C(a0)
    }

    private static let java$lang$Character_toUpperCase_I__I = svoker("toUpperCase", returns: jint.jniType, arguments: (jint.jniType))
    public static func toUpperCase(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_toUpperCase_I__I(a0)
    }

    private static let java$lang$Character_toTitleCase_C__C = svoker("toTitleCase", returns: jchar.jniType, arguments: (jchar.jniType))
    public static func toTitleCase(a0: jchar) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_toTitleCase_C__C(a0)
    }

    private static let java$lang$Character_toTitleCase_I__I = svoker("toTitleCase", returns: jint.jniType, arguments: (jint.jniType))
    public static func toTitleCase(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_toTitleCase_I__I(a0)
    }

    private static let java$lang$Character_digit_C_I__I = svoker("digit", returns: jint.jniType, arguments: (jchar.jniType, jint.jniType))
    public static func digit(a0: jchar, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_digit_C_I__I(a0, a1)
    }

    private static let java$lang$Character_digit_I_I__I = svoker("digit", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func digit(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_digit_I_I__I(a0, a1)
    }

    private static let java$lang$Character_getNumericValue_C__I = svoker("getNumericValue", returns: jint.jniType, arguments: (jchar.jniType))
    public static func getNumericValue(a0: jchar) throws -> jint {
        return try java$lang$Character$.java$lang$Character_getNumericValue_C__I(a0)
    }

    private static let java$lang$Character_getNumericValue_I__I = svoker("getNumericValue", returns: jint.jniType, arguments: (jint.jniType))
    public static func getNumericValue(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_getNumericValue_I__I(a0)
    }

    private static let java$lang$Character_isSpace_C__Z = svoker("isSpace", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isSpace(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSpace_C__Z(a0)
    }

    private static let java$lang$Character_isSpaceChar_C__Z = svoker("isSpaceChar", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isSpaceChar(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSpaceChar_C__Z(a0)
    }

    private static let java$lang$Character_isSpaceChar_I__Z = svoker("isSpaceChar", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isSpaceChar(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isSpaceChar_I__Z(a0)
    }

    private static let java$lang$Character_isWhitespace_C__Z = svoker("isWhitespace", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isWhitespace(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isWhitespace_C__Z(a0)
    }

    private static let java$lang$Character_isWhitespace_I__Z = svoker("isWhitespace", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isWhitespace(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isWhitespace_I__Z(a0)
    }

    private static let java$lang$Character_isISOControl_C__Z = svoker("isISOControl", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isISOControl(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isISOControl_C__Z(a0)
    }

    private static let java$lang$Character_isISOControl_I__Z = svoker("isISOControl", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isISOControl(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isISOControl_I__Z(a0)
    }

    private static let java$lang$Character_getType_C__I = svoker("getType", returns: jint.jniType, arguments: (jchar.jniType))
    public static func getType(a0: jchar) throws -> jint {
        return try java$lang$Character$.java$lang$Character_getType_C__I(a0)
    }

    private static let java$lang$Character_getType_I__I = svoker("getType", returns: jint.jniType, arguments: (jint.jniType))
    public static func getType(a0: jint) throws -> jint {
        return try java$lang$Character$.java$lang$Character_getType_I__I(a0)
    }

    private static let java$lang$Character_forDigit_I_I__C = svoker("forDigit", returns: jchar.jniType, arguments: (jint.jniType, jint.jniType))
    public static func forDigit(a0: jint, _ a1: jint) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_forDigit_I_I__C(a0, a1)
    }

    private static let java$lang$Character_getDirectionality_C__B = svoker("getDirectionality", returns: jbyte.jniType, arguments: (jchar.jniType))
    public static func getDirectionality(a0: jchar) throws -> jbyte {
        return try java$lang$Character$.java$lang$Character_getDirectionality_C__B(a0)
    }

    private static let java$lang$Character_getDirectionality_I__B = svoker("getDirectionality", returns: jbyte.jniType, arguments: (jint.jniType))
    public static func getDirectionality(a0: jint) throws -> jbyte {
        return try java$lang$Character$.java$lang$Character_getDirectionality_I__B(a0)
    }

    private static let java$lang$Character_isMirrored_C__Z = svoker("isMirrored", returns: jboolean.jniType, arguments: (jchar.jniType))
    public static func isMirrored(a0: jchar) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isMirrored_C__Z(a0)
    }

    private static let java$lang$Character_isMirrored_I__Z = svoker("isMirrored", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isMirrored(a0: jint) throws -> jboolean {
        return try java$lang$Character$.java$lang$Character_isMirrored_I__Z(a0)
    }

    private static let java$lang$Character_compareTo_java$lang$Character__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Character")))
    public func compareTo(a0: java$lang$Character?) throws -> jint {
        return try java$lang$Character$.java$lang$Character_compareTo_java$lang$Character__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Character_compare_C_C__I = svoker("compare", returns: jint.jniType, arguments: (jchar.jniType, jchar.jniType))
    public static func compare(a0: jchar, _ a1: jchar) throws -> jint {
        return try java$lang$Character$.java$lang$Character_compare_C_C__I(a0, a1)
    }

    private static let java$lang$Character_reverseBytes_C__C = svoker("reverseBytes", returns: jchar.jniType, arguments: (jchar.jniType))
    public static func reverseBytes(a0: jchar) throws -> jchar {
        return try java$lang$Character$.java$lang$Character_reverseBytes_C__C(a0)
    }

    private static let java$lang$Character_getName_I__java$lang$String = svoker("getName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func getName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Character$.java$lang$Character_getName_I__java$lang$String(a0))
    }

    private static let java$lang$Character_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Character$.java$lang$Character_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Character$ = java$lang$Character

public class java$lang$CharacterData : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterData$ = java$lang$CharacterData

public class java$lang$CharacterData00 : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterData00$ = java$lang$CharacterData00

public class java$lang$CharacterData01 : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterData01$ = java$lang$CharacterData01

public class java$lang$CharacterData02 : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterData02$ = java$lang$CharacterData02

public class java$lang$CharacterData0E : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterData0E$ = java$lang$CharacterData0E

public class java$lang$CharacterDataLatin1 : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterDataLatin1$ = java$lang$CharacterDataLatin1

public class java$lang$CharacterDataPrivateUse : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterDataPrivateUse$ = java$lang$CharacterDataPrivateUse

public class java$lang$CharacterDataUndefined : java$lang$CharacterData$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$CharacterDataUndefined$ = java$lang$CharacterDataUndefined

public class java$lang$CharacterName : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$CharacterName_get_I__java$lang$String = svoker("get", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func get(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$CharacterName$.java$lang$CharacterName_get_I__java$lang$String(a0))
    }

}

public typealias java$lang$CharacterName$ = java$lang$CharacterName

public final class java$lang$Class : java$lang$Object$, java$io$Serializable, java$lang$reflect$GenericDeclaration, java$lang$reflect$Type, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Class_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Class_toGenericString__java$lang$String = invoker("toGenericString", returns: JObjectType("java/lang/String"))
    public func toGenericString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Class$.java$lang$Class_toGenericString__java$lang$String(jobj)())
    }

    private static let java$lang$Class_forName_java$lang$String__java$lang$Class = svoker("forName", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/String")))
    public static func forName(a0: java$lang$String?) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_forName_java$lang$String__java$lang$Class(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_forName_java$lang$String_Z_java$lang$ClassLoader__java$lang$Class = svoker("forName", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/String"), jboolean.jniType, JObjectType("java/lang/ClassLoader")))
    public static func forName(a0: java$lang$String?, _ a1: jboolean, _ a2: java$lang$ClassLoader?) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_forName_java$lang$String_Z_java$lang$ClassLoader__java$lang$Class(a0?.jobj ?? nil, a1, a2?.jobj ?? nil))
    }

    private static let java$lang$Class_newInstance__java$lang$Object = invoker("newInstance", returns: JObjectType("java/lang/Object"))
    public func newInstance() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$Class$.java$lang$Class_newInstance__java$lang$Object(jobj)())
    }

    private static let java$lang$Class_isInstance_java$lang$Object__Z = invoker("isInstance", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func isInstance(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isInstance_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Class_isAssignableFrom_java$lang$Class__Z = invoker("isAssignableFrom", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public func isAssignableFrom(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isAssignableFrom_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Class_isInterface__Z = invoker("isInterface", returns: jboolean.jniType)
    public func isInterface() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isInterface__Z(jobj)()
    }

    private static let java$lang$Class_isArray__Z = invoker("isArray", returns: jboolean.jniType)
    public func isArray() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isArray__Z(jobj)()
    }

    private static let java$lang$Class_isPrimitive__Z = invoker("isPrimitive", returns: jboolean.jniType)
    public func isPrimitive() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isPrimitive__Z(jobj)()
    }

    private static let java$lang$Class_isAnnotation__Z = invoker("isAnnotation", returns: jboolean.jniType)
    public func isAnnotation() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isAnnotation__Z(jobj)()
    }

    private static let java$lang$Class_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    public func isSynthetic() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isSynthetic__Z(jobj)()
    }

    private static let java$lang$Class_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Class$.java$lang$Class_getName__java$lang$String(jobj)())
    }

    private static let java$lang$Class_getClassLoader__java$lang$ClassLoader = invoker("getClassLoader", returns: JObjectType("java/lang/ClassLoader"))
    public func getClassLoader() throws -> java$lang$ClassLoader? {
        return try java$lang$ClassLoader$(jobj: java$lang$Class$.java$lang$Class_getClassLoader__java$lang$ClassLoader(jobj)())
    }

    private static let java$lang$Class_getTypeParameters__Ajava$lang$reflect$TypeVariable = invoker("getTypeParameters", returns: JArray(JObjectType("java/lang/reflect/TypeVariable")))
    public func getTypeParameters() throws -> [java$lang$reflect$TypeVariable?]? {
        return try java$lang$Class$.java$lang$Class_getTypeParameters__Ajava$lang$reflect$TypeVariable(jobj)().jarrayToArray(java$lang$reflect$TypeVariable$.self)?.map({ $0 as java$lang$reflect$TypeVariable? })
    }

    private static let java$lang$Class_getSuperclass__java$lang$Class = invoker("getSuperclass", returns: JObjectType("java/lang/Class"))
    public func getSuperclass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_getSuperclass__java$lang$Class(jobj)())
    }

    private static let java$lang$Class_getGenericSuperclass__java$lang$reflect$Type = invoker("getGenericSuperclass", returns: JObjectType("java/lang/reflect/Type"))
    public func getGenericSuperclass() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$Class$.java$lang$Class_getGenericSuperclass__java$lang$reflect$Type(jobj)())
    }

    private static let java$lang$Class_getPackage__java$lang$Package = invoker("getPackage", returns: JObjectType("java/lang/Package"))
    public func getPackage() throws -> java$lang$Package? {
        return try java$lang$Package$(jobj: java$lang$Class$.java$lang$Class_getPackage__java$lang$Package(jobj)())
    }

    private static let java$lang$Class_getInterfaces__Ajava$lang$Class = invoker("getInterfaces", returns: JArray(JObjectType("java/lang/Class")))
    public func getInterfaces() throws -> [java$lang$Class?]? {
        return try java$lang$Class$.java$lang$Class_getInterfaces__Ajava$lang$Class(jobj)().jarrayToArray(java$lang$Class$.self)?.map({ $0 as java$lang$Class? })
    }

    private static let java$lang$Class_getGenericInterfaces__Ajava$lang$reflect$Type = invoker("getGenericInterfaces", returns: JArray(JObjectType("java/lang/reflect/Type")))
    public func getGenericInterfaces() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$Class$.java$lang$Class_getGenericInterfaces__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    private static let java$lang$Class_getComponentType__java$lang$Class = invoker("getComponentType", returns: JObjectType("java/lang/Class"))
    public func getComponentType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_getComponentType__java$lang$Class(jobj)())
    }

    private static let java$lang$Class_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    public func getModifiers() throws -> jint {
        return try java$lang$Class$.java$lang$Class_getModifiers__I(jobj)()
    }

    private static let java$lang$Class_getSigners__Ajava$lang$Object = invoker("getSigners", returns: JArray(JObjectType("java/lang/Object")))
    public func getSigners() throws -> [java$lang$Object?]? {
        return try java$lang$Class$.java$lang$Class_getSigners__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$lang$Class_getEnclosingMethod__java$lang$reflect$Method = invoker("getEnclosingMethod", returns: JObjectType("java/lang/reflect/Method"))
    public func getEnclosingMethod() throws -> java$lang$reflect$Method? {
        return try java$lang$reflect$Method$(jobj: java$lang$Class$.java$lang$Class_getEnclosingMethod__java$lang$reflect$Method(jobj)())
    }

    private static let java$lang$Class_getEnclosingConstructor__java$lang$reflect$Constructor = invoker("getEnclosingConstructor", returns: JObjectType("java/lang/reflect/Constructor"))
    public func getEnclosingConstructor() throws -> java$lang$reflect$Constructor? {
        return try java$lang$reflect$Constructor$(jobj: java$lang$Class$.java$lang$Class_getEnclosingConstructor__java$lang$reflect$Constructor(jobj)())
    }

    private static let java$lang$Class_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    public func getDeclaringClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_getDeclaringClass__java$lang$Class(jobj)())
    }

    private static let java$lang$Class_getEnclosingClass__java$lang$Class = invoker("getEnclosingClass", returns: JObjectType("java/lang/Class"))
    public func getEnclosingClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_getEnclosingClass__java$lang$Class(jobj)())
    }

    private static let java$lang$Class_getSimpleName__java$lang$String = invoker("getSimpleName", returns: JObjectType("java/lang/String"))
    public func getSimpleName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Class$.java$lang$Class_getSimpleName__java$lang$String(jobj)())
    }

    private static let java$lang$Class_getTypeName__java$lang$String = invoker("getTypeName", returns: JObjectType("java/lang/String"))
    public func getTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Class$.java$lang$Class_getTypeName__java$lang$String(jobj)())
    }

    private static let java$lang$Class_getCanonicalName__java$lang$String = invoker("getCanonicalName", returns: JObjectType("java/lang/String"))
    public func getCanonicalName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Class$.java$lang$Class_getCanonicalName__java$lang$String(jobj)())
    }

    private static let java$lang$Class_isAnonymousClass__Z = invoker("isAnonymousClass", returns: jboolean.jniType)
    public func isAnonymousClass() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isAnonymousClass__Z(jobj)()
    }

    private static let java$lang$Class_isLocalClass__Z = invoker("isLocalClass", returns: jboolean.jniType)
    public func isLocalClass() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isLocalClass__Z(jobj)()
    }

    private static let java$lang$Class_isMemberClass__Z = invoker("isMemberClass", returns: jboolean.jniType)
    public func isMemberClass() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isMemberClass__Z(jobj)()
    }

    private static let java$lang$Class_getClasses__Ajava$lang$Class = invoker("getClasses", returns: JArray(JObjectType("java/lang/Class")))
    public func getClasses() throws -> [java$lang$Class?]? {
        return try java$lang$Class$.java$lang$Class_getClasses__Ajava$lang$Class(jobj)().jarrayToArray(java$lang$Class$.self)?.map({ $0 as java$lang$Class? })
    }

    private static let java$lang$Class_getFields__Ajava$lang$reflect$Field = invoker("getFields", returns: JArray(JObjectType("java/lang/reflect/Field")))
    public func getFields() throws -> [java$lang$reflect$Field?]? {
        return try java$lang$Class$.java$lang$Class_getFields__Ajava$lang$reflect$Field(jobj)().jarrayToArray(java$lang$reflect$Field$.self)?.map({ $0 as java$lang$reflect$Field? })
    }

    private static let java$lang$Class_getMethods__Ajava$lang$reflect$Method = invoker("getMethods", returns: JArray(JObjectType("java/lang/reflect/Method")))
    public func getMethods() throws -> [java$lang$reflect$Method?]? {
        return try java$lang$Class$.java$lang$Class_getMethods__Ajava$lang$reflect$Method(jobj)().jarrayToArray(java$lang$reflect$Method$.self)?.map({ $0 as java$lang$reflect$Method? })
    }

    private static let java$lang$Class_getConstructors__Ajava$lang$reflect$Constructor = invoker("getConstructors", returns: JArray(JObjectType("java/lang/reflect/Constructor")))
    public func getConstructors() throws -> [java$lang$reflect$Constructor?]? {
        return try java$lang$Class$.java$lang$Class_getConstructors__Ajava$lang$reflect$Constructor(jobj)().jarrayToArray(java$lang$reflect$Constructor$.self)?.map({ $0 as java$lang$reflect$Constructor? })
    }

    private static let java$lang$Class_getField_java$lang$String__java$lang$reflect$Field = invoker("getField", returns: JObjectType("java/lang/reflect/Field"), arguments: (JObjectType("java/lang/String")))
    public func getField(a0: java$lang$String?) throws -> java$lang$reflect$Field? {
        return try java$lang$reflect$Field$(jobj: java$lang$Class$.java$lang$Class_getField_java$lang$String__java$lang$reflect$Field(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getMethod_java$lang$String_Ajava$lang$Class__java$lang$reflect$Method = invoker("getMethod", returns: JObjectType("java/lang/reflect/Method"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Class"))))
    public func getMethod(a0: java$lang$String?, _ a1: [java$lang$Class?]?) throws -> java$lang$reflect$Method? {
        return try java$lang$reflect$Method$(jobj: java$lang$Class$.java$lang$Class_getMethod_java$lang$String_Ajava$lang$Class__java$lang$reflect$Method(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Class_getConstructor_Ajava$lang$Class__java$lang$reflect$Constructor = invoker("getConstructor", returns: JObjectType("java/lang/reflect/Constructor"), arguments: (JArray(JObjectType("java/lang/Class"))))
    public func getConstructor(a0: [java$lang$Class?]?) throws -> java$lang$reflect$Constructor? {
        return try java$lang$reflect$Constructor$(jobj: java$lang$Class$.java$lang$Class_getConstructor_Ajava$lang$Class__java$lang$reflect$Constructor(jobj)(a0?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Class_getDeclaredClasses__Ajava$lang$Class = invoker("getDeclaredClasses", returns: JArray(JObjectType("java/lang/Class")))
    public func getDeclaredClasses() throws -> [java$lang$Class?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredClasses__Ajava$lang$Class(jobj)().jarrayToArray(java$lang$Class$.self)?.map({ $0 as java$lang$Class? })
    }

    private static let java$lang$Class_getDeclaredFields__Ajava$lang$reflect$Field = invoker("getDeclaredFields", returns: JArray(JObjectType("java/lang/reflect/Field")))
    public func getDeclaredFields() throws -> [java$lang$reflect$Field?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredFields__Ajava$lang$reflect$Field(jobj)().jarrayToArray(java$lang$reflect$Field$.self)?.map({ $0 as java$lang$reflect$Field? })
    }

    private static let java$lang$Class_getDeclaredMethods__Ajava$lang$reflect$Method = invoker("getDeclaredMethods", returns: JArray(JObjectType("java/lang/reflect/Method")))
    public func getDeclaredMethods() throws -> [java$lang$reflect$Method?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredMethods__Ajava$lang$reflect$Method(jobj)().jarrayToArray(java$lang$reflect$Method$.self)?.map({ $0 as java$lang$reflect$Method? })
    }

    private static let java$lang$Class_getDeclaredConstructors__Ajava$lang$reflect$Constructor = invoker("getDeclaredConstructors", returns: JArray(JObjectType("java/lang/reflect/Constructor")))
    public func getDeclaredConstructors() throws -> [java$lang$reflect$Constructor?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredConstructors__Ajava$lang$reflect$Constructor(jobj)().jarrayToArray(java$lang$reflect$Constructor$.self)?.map({ $0 as java$lang$reflect$Constructor? })
    }

    private static let java$lang$Class_getDeclaredField_java$lang$String__java$lang$reflect$Field = invoker("getDeclaredField", returns: JObjectType("java/lang/reflect/Field"), arguments: (JObjectType("java/lang/String")))
    public func getDeclaredField(a0: java$lang$String?) throws -> java$lang$reflect$Field? {
        return try java$lang$reflect$Field$(jobj: java$lang$Class$.java$lang$Class_getDeclaredField_java$lang$String__java$lang$reflect$Field(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getDeclaredMethod_java$lang$String_Ajava$lang$Class__java$lang$reflect$Method = invoker("getDeclaredMethod", returns: JObjectType("java/lang/reflect/Method"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Class"))))
    public func getDeclaredMethod(a0: java$lang$String?, _ a1: [java$lang$Class?]?) throws -> java$lang$reflect$Method? {
        return try java$lang$reflect$Method$(jobj: java$lang$Class$.java$lang$Class_getDeclaredMethod_java$lang$String_Ajava$lang$Class__java$lang$reflect$Method(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Class_getDeclaredConstructor_Ajava$lang$Class__java$lang$reflect$Constructor = invoker("getDeclaredConstructor", returns: JObjectType("java/lang/reflect/Constructor"), arguments: (JArray(JObjectType("java/lang/Class"))))
    public func getDeclaredConstructor(a0: [java$lang$Class?]?) throws -> java$lang$reflect$Constructor? {
        return try java$lang$reflect$Constructor$(jobj: java$lang$Class$.java$lang$Class_getDeclaredConstructor_Ajava$lang$Class__java$lang$reflect$Constructor(jobj)(a0?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Class_getResourceAsStream_java$lang$String__java$io$InputStream = invoker("getResourceAsStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    public func getResourceAsStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$Class$.java$lang$Class_getResourceAsStream_java$lang$String__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getResource_java$lang$String__java$net$URL = invoker("getResource", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    public func getResource(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$lang$Class$.java$lang$Class_getResource_java$lang$String__java$net$URL(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getProtectionDomain__java$security$ProtectionDomain = invoker("getProtectionDomain", returns: JObjectType("java/security/ProtectionDomain"))
    public func getProtectionDomain() throws -> java$security$ProtectionDomain? {
        return try java$security$ProtectionDomain$(jobj: java$lang$Class$.java$lang$Class_getProtectionDomain__java$security$ProtectionDomain(jobj)())
    }

    private static let java$lang$Class_desiredAssertionStatus__Z = invoker("desiredAssertionStatus", returns: jboolean.jniType)
    public func desiredAssertionStatus() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_desiredAssertionStatus__Z(jobj)()
    }

    private static let java$lang$Class_isEnum__Z = invoker("isEnum", returns: jboolean.jniType)
    public func isEnum() throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isEnum__Z(jobj)()
    }

    private static let java$lang$Class_getEnumConstants__Ajava$lang$Object = invoker("getEnumConstants", returns: JArray(JObjectType("java/lang/Object")))
    public func getEnumConstants() throws -> [java$lang$Object?]? {
        return try java$lang$Class$.java$lang$Class_getEnumConstants__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$lang$Class_cast_java$lang$Object__java$lang$Object = invoker("cast", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func cast(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$Class$.java$lang$Class_cast_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_asSubclass_java$lang$Class__java$lang$Class = invoker("asSubclass", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/Class")))
    public func asSubclass(a0: java$lang$Class?) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Class$.java$lang$Class_asSubclass_java$lang$Class__java$lang$Class(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$Class$.java$lang$Class_getAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_isAnnotationPresent_java$lang$Class__Z = invoker("isAnnotationPresent", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public func isAnnotationPresent(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$Class$.java$lang$Class_isAnnotationPresent_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Class_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Class$.java$lang$Class_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Class_getAnnotations__Ajava$lang$annotation$Annotation = invoker("getAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Class$.java$lang$Class_getAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Class_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getDeclaredAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$Class$.java$lang$Class_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Class_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Class_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Class$.java$lang$Class_getDeclaredAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Class_getAnnotatedSuperclass__java$lang$reflect$AnnotatedType = invoker("getAnnotatedSuperclass", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    public func getAnnotatedSuperclass() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$Class$.java$lang$Class_getAnnotatedSuperclass__java$lang$reflect$AnnotatedType(jobj)())
    }

    private static let java$lang$Class_getAnnotatedInterfaces__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedInterfaces", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
    public func getAnnotatedInterfaces() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$Class$.java$lang$Class_getAnnotatedInterfaces__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public typealias java$lang$Class$ = java$lang$Class

public class java$lang$ClassCastException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassCastException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ClassCastException$.java$lang$ClassCastException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassCastException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ClassCastException$.java$lang$ClassCastException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ClassCastException$ = java$lang$ClassCastException

public class java$lang$ClassCircularityError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassCircularityError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ClassCircularityError$.java$lang$ClassCircularityError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassCircularityError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ClassCircularityError$.java$lang$ClassCircularityError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ClassCircularityError$ = java$lang$ClassCircularityError

public class java$lang$ClassFormatError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassFormatError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ClassFormatError$.java$lang$ClassFormatError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassFormatError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ClassFormatError$.java$lang$ClassFormatError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ClassFormatError$ = java$lang$ClassFormatError

public class java$lang$ClassLoader : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassLoader_loadClass_java$lang$String__java$lang$Class = invoker("loadClass", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/String")))
    public func loadClass(a0: java$lang$String?) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_loadClass_java$lang$String__java$lang$Class(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getResource_java$lang$String__java$net$URL = invoker("getResource", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    public func getResource(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getResource_java$lang$String__java$net$URL(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getResources_java$lang$String__java$util$Enumeration = invoker("getResources", returns: JObjectType("java/util/Enumeration"), arguments: (JObjectType("java/lang/String")))
    public func getResources(a0: java$lang$String?) throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getResources_java$lang$String__java$util$Enumeration(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getSystemResource_java$lang$String__java$net$URL = svoker("getSystemResource", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    public static func getSystemResource(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getSystemResource_java$lang$String__java$net$URL(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getSystemResources_java$lang$String__java$util$Enumeration = svoker("getSystemResources", returns: JObjectType("java/util/Enumeration"), arguments: (JObjectType("java/lang/String")))
    public static func getSystemResources(a0: java$lang$String?) throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getSystemResources_java$lang$String__java$util$Enumeration(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getResourceAsStream_java$lang$String__java$io$InputStream = invoker("getResourceAsStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    public func getResourceAsStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getResourceAsStream_java$lang$String__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getSystemResourceAsStream_java$lang$String__java$io$InputStream = svoker("getSystemResourceAsStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    public static func getSystemResourceAsStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getSystemResourceAsStream_java$lang$String__java$io$InputStream(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassLoader_getParent__java$lang$ClassLoader = invoker("getParent", returns: JObjectType("java/lang/ClassLoader"))
    public func getParent() throws -> java$lang$ClassLoader? {
        return try java$lang$ClassLoader$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getParent__java$lang$ClassLoader(jobj)())
    }

    private static let java$lang$ClassLoader_getSystemClassLoader__java$lang$ClassLoader = svoker("getSystemClassLoader", returns: JObjectType("java/lang/ClassLoader"))
    public static func getSystemClassLoader() throws -> java$lang$ClassLoader? {
        return try java$lang$ClassLoader$(jobj: java$lang$ClassLoader$.java$lang$ClassLoader_getSystemClassLoader__java$lang$ClassLoader())
    }

    private static let java$lang$ClassLoader_setDefaultAssertionStatus_Z__V = invoker("setDefaultAssertionStatus", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDefaultAssertionStatus(a0: jboolean) throws -> Void {
        return try java$lang$ClassLoader$.java$lang$ClassLoader_setDefaultAssertionStatus_Z__V(jobj)(a0)
    }

    private static let java$lang$ClassLoader_setPackageAssertionStatus_java$lang$String_Z__V = invoker("setPackageAssertionStatus", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jboolean.jniType))
    public func setPackageAssertionStatus(a0: java$lang$String?, _ a1: jboolean) throws -> Void {
        return try java$lang$ClassLoader$.java$lang$ClassLoader_setPackageAssertionStatus_java$lang$String_Z__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$ClassLoader_setClassAssertionStatus_java$lang$String_Z__V = invoker("setClassAssertionStatus", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jboolean.jniType))
    public func setClassAssertionStatus(a0: java$lang$String?, _ a1: jboolean) throws -> Void {
        return try java$lang$ClassLoader$.java$lang$ClassLoader_setClassAssertionStatus_java$lang$String_Z__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$ClassLoader_clearAssertionStatus__V = invoker("clearAssertionStatus", returns: JVoid.jniType)
    public func clearAssertionStatus() throws -> Void {
        return try java$lang$ClassLoader$.java$lang$ClassLoader_clearAssertionStatus__V(jobj)()
    }

}

public typealias java$lang$ClassLoader$ = java$lang$ClassLoader

public class java$lang$ClassLoaderHelper : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$ClassLoaderHelper$ = java$lang$ClassLoaderHelper

public class java$lang$ClassNotFoundException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassNotFoundException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ClassNotFoundException$.java$lang$ClassNotFoundException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassNotFoundException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ClassNotFoundException$.java$lang$ClassNotFoundException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassNotFoundException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$ClassNotFoundException$.java$lang$ClassNotFoundException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ClassNotFoundException_getException__java$lang$Throwable = invoker("getException", returns: JObjectType("java/lang/Throwable"))
    public func getException() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$ClassNotFoundException$.java$lang$ClassNotFoundException_getException__java$lang$Throwable(jobj)())
    }

    private static let java$lang$ClassNotFoundException_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$lang$ClassNotFoundException$ = java$lang$ClassNotFoundException

public class java$lang$ClassValue : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ClassValue_get_java$lang$Class__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class")))
    public func get(a0: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$ClassValue$.java$lang$ClassValue_get_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ClassValue_remove_java$lang$Class__V = invoker("remove", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Class")))
    public func remove(a0: java$lang$Class?) throws -> Void {
        return try java$lang$ClassValue$.java$lang$ClassValue_remove_java$lang$Class__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$ClassValue$ = java$lang$ClassValue

public class java$lang$CloneNotSupportedException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$CloneNotSupportedException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$CloneNotSupportedException$.java$lang$CloneNotSupportedException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$CloneNotSupportedException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$CloneNotSupportedException$.java$lang$CloneNotSupportedException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$CloneNotSupportedException$ = java$lang$CloneNotSupportedException

public protocol java$lang$Cloneable : JavaObject {
}

public class java$lang$Cloneable$ : java$lang$Object$, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$lang$Cloneable {
}

public protocol java$lang$Comparable : JavaObject {
    func compareTo(a0: java$lang$Object?) throws -> jint
}

public class java$lang$Comparable$ : java$lang$Object$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Comparable_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
}

public extension java$lang$Comparable {
    func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Comparable$.java$lang$Comparable_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public final class java$lang$Compiler : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Compiler_compileClass_java$lang$Class__Z = svoker("compileClass", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public static func compileClass(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$Compiler$.java$lang$Compiler_compileClass_java$lang$Class__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$Compiler_compileClasses_java$lang$String__Z = svoker("compileClasses", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public static func compileClasses(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$Compiler$.java$lang$Compiler_compileClasses_java$lang$String__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$Compiler_command_java$lang$Object__java$lang$Object = svoker("command", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public static func command(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$Compiler$.java$lang$Compiler_command_java$lang$Object__java$lang$Object(a0?.jobj ?? nil))
    }

    private static let java$lang$Compiler_enable__V = svoker("enable", returns: JVoid.jniType)
    public static func enable() throws -> Void {
        return try java$lang$Compiler$.java$lang$Compiler_enable__V()
    }

    private static let java$lang$Compiler_disable__V = svoker("disable", returns: JVoid.jniType)
    public static func disable() throws -> Void {
        return try java$lang$Compiler$.java$lang$Compiler_disable__V()
    }

}

public typealias java$lang$Compiler$ = java$lang$Compiler

public final class java$lang$ConditionalSpecialCasing : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$ConditionalSpecialCasing$ = java$lang$ConditionalSpecialCasing

public protocol java$lang$Deprecated : java$lang$annotation$Annotation {
}

public class java$lang$Deprecated$ : java$lang$Object$, java$lang$Deprecated, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$lang$Deprecated {
}

public final class java$lang$Double : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Double_toString_D__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jdouble.jniType))
    public static func toString(a0: jdouble) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Double$.java$lang$Double_toString_D__java$lang$String(a0))
    }

    private static let java$lang$Double_toHexString_D__java$lang$String = svoker("toHexString", returns: JObjectType("java/lang/String"), arguments: (jdouble.jniType))
    public static func toHexString(a0: jdouble) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Double$.java$lang$Double_toHexString_D__java$lang$String(a0))
    }

    private static let java$lang$Double_valueOf_java$lang$String__java$lang$Double = svoker("valueOf", returns: JObjectType("java/lang/Double"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Double? {
        return try java$lang$Double$(jobj: java$lang$Double$.java$lang$Double_valueOf_java$lang$String__java$lang$Double(a0?.jobj ?? nil))
    }

    private static let java$lang$Double_valueOf_D__java$lang$Double = svoker("valueOf", returns: JObjectType("java/lang/Double"), arguments: (jdouble.jniType))
    public static func valueOf(a0: jdouble) throws -> java$lang$Double? {
        return try java$lang$Double$(jobj: java$lang$Double$.java$lang$Double_valueOf_D__java$lang$Double(a0))
    }

    private static let java$lang$Double_parseDouble_java$lang$String__D = svoker("parseDouble", returns: jdouble.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseDouble(a0: java$lang$String?) throws -> jdouble {
        return try java$lang$Double$.java$lang$Double_parseDouble_java$lang$String__D(a0?.jobj ?? nil)
    }

    private static let java$lang$Double_isNaN_D__Z = svoker("isNaN", returns: jboolean.jniType, arguments: (jdouble.jniType))
    public static func isNaN(a0: jdouble) throws -> jboolean {
        return try java$lang$Double$.java$lang$Double_isNaN_D__Z(a0)
    }

    private static let java$lang$Double_isInfinite_D__Z = svoker("isInfinite", returns: jboolean.jniType, arguments: (jdouble.jniType))
    public static func isInfinite(a0: jdouble) throws -> jboolean {
        return try java$lang$Double$.java$lang$Double_isInfinite_D__Z(a0)
    }

    private static let java$lang$Double_isFinite_D__Z = svoker("isFinite", returns: jboolean.jniType, arguments: (jdouble.jniType))
    public static func isFinite(a0: jdouble) throws -> jboolean {
        return try java$lang$Double$.java$lang$Double_isFinite_D__Z(a0)
    }

    private static let java$lang$Double_init_D__V = constructor((jdouble.jniType))
    public convenience init!(_ a0: jdouble) throws {
        let jobj = try java$lang$Double$.java$lang$Double_init_D__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Double_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Double$.java$lang$Double_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Double_isNaN__Z = invoker("isNaN", returns: jboolean.jniType)
    public func isNaN() throws -> jboolean {
        return try java$lang$Double$.java$lang$Double_isNaN__Z(jobj)()
    }

    private static let java$lang$Double_isInfinite__Z = invoker("isInfinite", returns: jboolean.jniType)
    public func isInfinite() throws -> jboolean {
        return try java$lang$Double$.java$lang$Double_isInfinite__Z(jobj)()
    }

    private static let java$lang$Double_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Double_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Double_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Double_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Double_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Double_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Double_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Double_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Double_hashCode_D__I = svoker("hashCode", returns: jint.jniType, arguments: (jdouble.jniType))
    public static func hashCode(a0: jdouble) throws -> jint {
        return try java$lang$Double$.java$lang$Double_hashCode_D__I(a0)
    }

    private static let java$lang$Double_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Double_doubleToLongBits_D__J = svoker("doubleToLongBits", returns: jlong.jniType, arguments: (jdouble.jniType))
    public static func doubleToLongBits(a0: jdouble) throws -> jlong {
        return try java$lang$Double$.java$lang$Double_doubleToLongBits_D__J(a0)
    }

    private static let java$lang$Double_doubleToRawLongBits_D__J = svoker("doubleToRawLongBits", returns: jlong.jniType, arguments: (jdouble.jniType))
    public static func doubleToRawLongBits(a0: jdouble) throws -> jlong {
        return try java$lang$Double$.java$lang$Double_doubleToRawLongBits_D__J(a0)
    }

    private static let java$lang$Double_longBitsToDouble_J__D = svoker("longBitsToDouble", returns: jdouble.jniType, arguments: (jlong.jniType))
    public static func longBitsToDouble(a0: jlong) throws -> jdouble {
        return try java$lang$Double$.java$lang$Double_longBitsToDouble_J__D(a0)
    }

    private static let java$lang$Double_compareTo_java$lang$Double__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Double")))
    public func compareTo(a0: java$lang$Double?) throws -> jint {
        return try java$lang$Double$.java$lang$Double_compareTo_java$lang$Double__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Double_compare_D_D__I = svoker("compare", returns: jint.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func compare(a0: jdouble, _ a1: jdouble) throws -> jint {
        return try java$lang$Double$.java$lang$Double_compare_D_D__I(a0, a1)
    }

    private static let java$lang$Double_sum_D_D__D = svoker("sum", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func sum(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Double$.java$lang$Double_sum_D_D__D(a0, a1)
    }

    private static let java$lang$Double_max_D_D__D = svoker("max", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func max(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Double$.java$lang$Double_max_D_D__D(a0, a1)
    }

    private static let java$lang$Double_min_D_D__D = svoker("min", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func min(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Double$.java$lang$Double_min_D_D__D(a0, a1)
    }

    private static let java$lang$Double_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Double$.java$lang$Double_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Double$ = java$lang$Double

public class java$lang$Enum : java$lang$Object$, java$lang$Comparable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Enum_name__java$lang$String = invoker("name", returns: JObjectType("java/lang/String"))
    public func name() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Enum$.java$lang$Enum_name__java$lang$String(jobj)())
    }

    private static let java$lang$Enum_ordinal__I = invoker("ordinal", returns: jint.jniType)
    public func ordinal() throws -> jint {
        return try java$lang$Enum$.java$lang$Enum_ordinal__I(jobj)()
    }

    private static let java$lang$Enum_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Enum_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Enum_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Enum_compareTo_java$lang$Enum__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Enum")))
    public func compareTo(a0: java$lang$Enum?) throws -> jint {
        return try java$lang$Enum$.java$lang$Enum_compareTo_java$lang$Enum__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Enum_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    public func getDeclaringClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Enum$.java$lang$Enum_getDeclaringClass__java$lang$Class(jobj)())
    }

    private static let java$lang$Enum_valueOf_java$lang$Class_java$lang$String__java$lang$Enum = svoker("valueOf", returns: JObjectType("java/lang/Enum"), arguments: (JObjectType("java/lang/Class"), JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$Class?, _ a1: java$lang$String?) throws -> java$lang$Enum? {
        return try java$lang$Enum$(jobj: java$lang$Enum$.java$lang$Enum_valueOf_java$lang$Class_java$lang$String__java$lang$Enum(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$Enum_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Enum$.java$lang$Enum_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Enum$ = java$lang$Enum

public class java$lang$EnumConstantNotPresentException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$EnumConstantNotPresentException_init_java$lang$Class_java$lang$String__V = constructor((JObjectType("java/lang/Class"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$Class?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$EnumConstantNotPresentException$.java$lang$EnumConstantNotPresentException_init_java$lang$Class_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$EnumConstantNotPresentException_enumType__java$lang$Class = invoker("enumType", returns: JObjectType("java/lang/Class"))
    public func enumType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$EnumConstantNotPresentException$.java$lang$EnumConstantNotPresentException_enumType__java$lang$Class(jobj)())
    }

    private static let java$lang$EnumConstantNotPresentException_constantName__java$lang$String = invoker("constantName", returns: JObjectType("java/lang/String"))
    public func constantName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$EnumConstantNotPresentException$.java$lang$EnumConstantNotPresentException_constantName__java$lang$String(jobj)())
    }

}

public typealias java$lang$EnumConstantNotPresentException$ = java$lang$EnumConstantNotPresentException

public class java$lang$Error : java$lang$Throwable$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Error_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Error$.java$lang$Error_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Error_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Error$.java$lang$Error_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Error_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$Error$.java$lang$Error_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Error_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$Error$.java$lang$Error_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$Error$ = java$lang$Error

public class java$lang$Exception : java$lang$Throwable$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Exception_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Exception$.java$lang$Exception_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Exception_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Exception$.java$lang$Exception_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Exception_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$Exception$.java$lang$Exception_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Exception_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$Exception$.java$lang$Exception_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$Exception$ = java$lang$Exception

public class java$lang$ExceptionInInitializerError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ExceptionInInitializerError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ExceptionInInitializerError$.java$lang$ExceptionInInitializerError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ExceptionInInitializerError_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$ExceptionInInitializerError$.java$lang$ExceptionInInitializerError_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ExceptionInInitializerError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ExceptionInInitializerError$.java$lang$ExceptionInInitializerError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ExceptionInInitializerError_getException__java$lang$Throwable = invoker("getException", returns: JObjectType("java/lang/Throwable"))
    public func getException() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$ExceptionInInitializerError$.java$lang$ExceptionInInitializerError_getException__java$lang$Throwable(jobj)())
    }

    private static let java$lang$ExceptionInInitializerError_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$lang$ExceptionInInitializerError$ = java$lang$ExceptionInInitializerError

public final class java$lang$Float : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Float_toString_F__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jfloat.jniType))
    public static func toString(a0: jfloat) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Float$.java$lang$Float_toString_F__java$lang$String(a0))
    }

    private static let java$lang$Float_toHexString_F__java$lang$String = svoker("toHexString", returns: JObjectType("java/lang/String"), arguments: (jfloat.jniType))
    public static func toHexString(a0: jfloat) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Float$.java$lang$Float_toHexString_F__java$lang$String(a0))
    }

    private static let java$lang$Float_valueOf_java$lang$String__java$lang$Float = svoker("valueOf", returns: JObjectType("java/lang/Float"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Float? {
        return try java$lang$Float$(jobj: java$lang$Float$.java$lang$Float_valueOf_java$lang$String__java$lang$Float(a0?.jobj ?? nil))
    }

    private static let java$lang$Float_valueOf_F__java$lang$Float = svoker("valueOf", returns: JObjectType("java/lang/Float"), arguments: (jfloat.jniType))
    public static func valueOf(a0: jfloat) throws -> java$lang$Float? {
        return try java$lang$Float$(jobj: java$lang$Float$.java$lang$Float_valueOf_F__java$lang$Float(a0))
    }

    private static let java$lang$Float_parseFloat_java$lang$String__F = svoker("parseFloat", returns: jfloat.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseFloat(a0: java$lang$String?) throws -> jfloat {
        return try java$lang$Float$.java$lang$Float_parseFloat_java$lang$String__F(a0?.jobj ?? nil)
    }

    private static let java$lang$Float_isNaN_F__Z = svoker("isNaN", returns: jboolean.jniType, arguments: (jfloat.jniType))
    public static func isNaN(a0: jfloat) throws -> jboolean {
        return try java$lang$Float$.java$lang$Float_isNaN_F__Z(a0)
    }

    private static let java$lang$Float_isInfinite_F__Z = svoker("isInfinite", returns: jboolean.jniType, arguments: (jfloat.jniType))
    public static func isInfinite(a0: jfloat) throws -> jboolean {
        return try java$lang$Float$.java$lang$Float_isInfinite_F__Z(a0)
    }

    private static let java$lang$Float_isFinite_F__Z = svoker("isFinite", returns: jboolean.jniType, arguments: (jfloat.jniType))
    public static func isFinite(a0: jfloat) throws -> jboolean {
        return try java$lang$Float$.java$lang$Float_isFinite_F__Z(a0)
    }

    private static let java$lang$Float_init_F__V = constructor((jfloat.jniType))
    public convenience init!(_ a0: jfloat) throws {
        let jobj = try java$lang$Float$.java$lang$Float_init_F__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Float_init_D__V = constructor((jdouble.jniType))
    public convenience init!(_ a0: jdouble) throws {
        let jobj = try java$lang$Float$.java$lang$Float_init_D__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Float_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Float$.java$lang$Float_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Float_isNaN__Z = invoker("isNaN", returns: jboolean.jniType)
    public func isNaN() throws -> jboolean {
        return try java$lang$Float$.java$lang$Float_isNaN__Z(jobj)()
    }

    private static let java$lang$Float_isInfinite__Z = invoker("isInfinite", returns: jboolean.jniType)
    public func isInfinite() throws -> jboolean {
        return try java$lang$Float$.java$lang$Float_isInfinite__Z(jobj)()
    }

    private static let java$lang$Float_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Float_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Float_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Float_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Float_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Float_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Float_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Float_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Float_hashCode_F__I = svoker("hashCode", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func hashCode(a0: jfloat) throws -> jint {
        return try java$lang$Float$.java$lang$Float_hashCode_F__I(a0)
    }

    private static let java$lang$Float_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Float_floatToIntBits_F__I = svoker("floatToIntBits", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func floatToIntBits(a0: jfloat) throws -> jint {
        return try java$lang$Float$.java$lang$Float_floatToIntBits_F__I(a0)
    }

    private static let java$lang$Float_floatToRawIntBits_F__I = svoker("floatToRawIntBits", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func floatToRawIntBits(a0: jfloat) throws -> jint {
        return try java$lang$Float$.java$lang$Float_floatToRawIntBits_F__I(a0)
    }

    private static let java$lang$Float_intBitsToFloat_I__F = svoker("intBitsToFloat", returns: jfloat.jniType, arguments: (jint.jniType))
    public static func intBitsToFloat(a0: jint) throws -> jfloat {
        return try java$lang$Float$.java$lang$Float_intBitsToFloat_I__F(a0)
    }

    private static let java$lang$Float_compareTo_java$lang$Float__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Float")))
    public func compareTo(a0: java$lang$Float?) throws -> jint {
        return try java$lang$Float$.java$lang$Float_compareTo_java$lang$Float__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Float_compare_F_F__I = svoker("compare", returns: jint.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func compare(a0: jfloat, _ a1: jfloat) throws -> jint {
        return try java$lang$Float$.java$lang$Float_compare_F_F__I(a0, a1)
    }

    private static let java$lang$Float_sum_F_F__F = svoker("sum", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func sum(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Float$.java$lang$Float_sum_F_F__F(a0, a1)
    }

    private static let java$lang$Float_max_F_F__F = svoker("max", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func max(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Float$.java$lang$Float_max_F_F__F(a0, a1)
    }

    private static let java$lang$Float_min_F_F__F = svoker("min", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func min(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Float$.java$lang$Float_min_F_F__F(a0, a1)
    }

    private static let java$lang$Float_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Float$.java$lang$Float_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Float$ = java$lang$Float

public protocol java$lang$FunctionalInterface : java$lang$annotation$Annotation {
}

public class java$lang$FunctionalInterface$ : java$lang$Object$, java$lang$FunctionalInterface, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$lang$FunctionalInterface {
}

public class java$lang$IllegalAccessError : java$lang$IncompatibleClassChangeError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalAccessError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalAccessError$.java$lang$IllegalAccessError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalAccessError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalAccessError$.java$lang$IllegalAccessError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalAccessError$ = java$lang$IllegalAccessError

public class java$lang$IllegalAccessException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalAccessException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalAccessException$.java$lang$IllegalAccessException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalAccessException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalAccessException$.java$lang$IllegalAccessException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalAccessException$ = java$lang$IllegalAccessException

public class java$lang$IllegalArgumentException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalArgumentException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalArgumentException$.java$lang$IllegalArgumentException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalArgumentException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalArgumentException$.java$lang$IllegalArgumentException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalArgumentException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$IllegalArgumentException$.java$lang$IllegalArgumentException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalArgumentException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$IllegalArgumentException$.java$lang$IllegalArgumentException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalArgumentException$ = java$lang$IllegalArgumentException

public class java$lang$IllegalMonitorStateException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalMonitorStateException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalMonitorStateException$.java$lang$IllegalMonitorStateException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalMonitorStateException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalMonitorStateException$.java$lang$IllegalMonitorStateException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalMonitorStateException$ = java$lang$IllegalMonitorStateException

public class java$lang$IllegalStateException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalStateException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalStateException$.java$lang$IllegalStateException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalStateException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalStateException$.java$lang$IllegalStateException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalStateException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$IllegalStateException$.java$lang$IllegalStateException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalStateException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$IllegalStateException$.java$lang$IllegalStateException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalStateException$ = java$lang$IllegalStateException

public class java$lang$IllegalThreadStateException : java$lang$IllegalArgumentException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IllegalThreadStateException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IllegalThreadStateException$.java$lang$IllegalThreadStateException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IllegalThreadStateException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IllegalThreadStateException$.java$lang$IllegalThreadStateException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IllegalThreadStateException$ = java$lang$IllegalThreadStateException

public class java$lang$IncompatibleClassChangeError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IncompatibleClassChangeError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IncompatibleClassChangeError$.java$lang$IncompatibleClassChangeError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IncompatibleClassChangeError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IncompatibleClassChangeError$.java$lang$IncompatibleClassChangeError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IncompatibleClassChangeError$ = java$lang$IncompatibleClassChangeError

public class java$lang$IndexOutOfBoundsException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$IndexOutOfBoundsException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$IndexOutOfBoundsException$.java$lang$IndexOutOfBoundsException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$IndexOutOfBoundsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$IndexOutOfBoundsException$.java$lang$IndexOutOfBoundsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$IndexOutOfBoundsException$ = java$lang$IndexOutOfBoundsException

public class java$lang$InheritableThreadLocal : java$lang$ThreadLocal$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$InheritableThreadLocal_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$InheritableThreadLocal$.java$lang$InheritableThreadLocal_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$lang$InheritableThreadLocal$ = java$lang$InheritableThreadLocal

public class java$lang$InstantiationError : java$lang$IncompatibleClassChangeError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$InstantiationError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$InstantiationError$.java$lang$InstantiationError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$InstantiationError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$InstantiationError$.java$lang$InstantiationError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$InstantiationError$ = java$lang$InstantiationError

public class java$lang$InstantiationException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$InstantiationException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$InstantiationException$.java$lang$InstantiationException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$InstantiationException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$InstantiationException$.java$lang$InstantiationException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$InstantiationException$ = java$lang$InstantiationException

public final class java$lang$Integer : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Integer_toString_I_I__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    public static func toString(a0: jint, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toString_I_I__java$lang$String(a0, a1))
    }

    private static let java$lang$Integer_toUnsignedString_I_I__java$lang$String = svoker("toUnsignedString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    public static func toUnsignedString(a0: jint, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toUnsignedString_I_I__java$lang$String(a0, a1))
    }

    private static let java$lang$Integer_toHexString_I__java$lang$String = svoker("toHexString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toHexString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toHexString_I__java$lang$String(a0))
    }

    private static let java$lang$Integer_toOctalString_I__java$lang$String = svoker("toOctalString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toOctalString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toOctalString_I__java$lang$String(a0))
    }

    private static let java$lang$Integer_toBinaryString_I__java$lang$String = svoker("toBinaryString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toBinaryString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toBinaryString_I__java$lang$String(a0))
    }

    private static let java$lang$Integer_toString_I__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toString_I__java$lang$String(a0))
    }

    private static let java$lang$Integer_toUnsignedString_I__java$lang$String = svoker("toUnsignedString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toUnsignedString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Integer$.java$lang$Integer_toUnsignedString_I__java$lang$String(a0))
    }

    private static let java$lang$Integer_parseInt_java$lang$String_I__I = svoker("parseInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseInt(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_parseInt_java$lang$String_I__I(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Integer_parseInt_java$lang$String__I = svoker("parseInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseInt(a0: java$lang$String?) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_parseInt_java$lang$String__I(a0?.jobj ?? nil)
    }

    private static let java$lang$Integer_parseUnsignedInt_java$lang$String_I__I = svoker("parseUnsignedInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseUnsignedInt(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_parseUnsignedInt_java$lang$String_I__I(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Integer_parseUnsignedInt_java$lang$String__I = svoker("parseUnsignedInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseUnsignedInt(a0: java$lang$String?) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_parseUnsignedInt_java$lang$String__I(a0?.jobj ?? nil)
    }

    private static let java$lang$Integer_valueOf_java$lang$String_I__java$lang$Integer = svoker("valueOf", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func valueOf(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_valueOf_java$lang$String_I__java$lang$Integer(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Integer_valueOf_java$lang$String__java$lang$Integer = svoker("valueOf", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_valueOf_java$lang$String__java$lang$Integer(a0?.jobj ?? nil))
    }

    private static let java$lang$Integer_valueOf_I__java$lang$Integer = svoker("valueOf", returns: JObjectType("java/lang/Integer"), arguments: (jint.jniType))
    public static func valueOf(a0: jint) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_valueOf_I__java$lang$Integer(a0))
    }

    private static let java$lang$Integer_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$lang$Integer$.java$lang$Integer_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Integer_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Integer$.java$lang$Integer_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Integer_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Integer_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Integer_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Integer_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Integer_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Integer_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Integer_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Integer_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Integer_hashCode_I__I = svoker("hashCode", returns: jint.jniType, arguments: (jint.jniType))
    public static func hashCode(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_hashCode_I__I(a0)
    }

    private static let java$lang$Integer_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Integer_getInteger_java$lang$String__java$lang$Integer = svoker("getInteger", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String")))
    public static func getInteger(a0: java$lang$String?) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_getInteger_java$lang$String__java$lang$Integer(a0?.jobj ?? nil))
    }

    private static let java$lang$Integer_getInteger_java$lang$String_I__java$lang$Integer = svoker("getInteger", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func getInteger(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_getInteger_java$lang$String_I__java$lang$Integer(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Integer_getInteger_java$lang$String_java$lang$Integer__java$lang$Integer = svoker("getInteger", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Integer")))
    public static func getInteger(a0: java$lang$String?, _ a1: java$lang$Integer?) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_getInteger_java$lang$String_java$lang$Integer__java$lang$Integer(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$Integer_decode_java$lang$String__java$lang$Integer = svoker("decode", returns: JObjectType("java/lang/Integer"), arguments: (JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?) throws -> java$lang$Integer? {
        return try java$lang$Integer$(jobj: java$lang$Integer$.java$lang$Integer_decode_java$lang$String__java$lang$Integer(a0?.jobj ?? nil))
    }

    private static let java$lang$Integer_compareTo_java$lang$Integer__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Integer")))
    public func compareTo(a0: java$lang$Integer?) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_compareTo_java$lang$Integer__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Integer_compare_I_I__I = svoker("compare", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func compare(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_compare_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_compareUnsigned_I_I__I = svoker("compareUnsigned", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func compareUnsigned(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_compareUnsigned_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_toUnsignedLong_I__J = svoker("toUnsignedLong", returns: jlong.jniType, arguments: (jint.jniType))
    public static func toUnsignedLong(a0: jint) throws -> jlong {
        return try java$lang$Integer$.java$lang$Integer_toUnsignedLong_I__J(a0)
    }

    private static let java$lang$Integer_divideUnsigned_I_I__I = svoker("divideUnsigned", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func divideUnsigned(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_divideUnsigned_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_remainderUnsigned_I_I__I = svoker("remainderUnsigned", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func remainderUnsigned(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_remainderUnsigned_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_highestOneBit_I__I = svoker("highestOneBit", returns: jint.jniType, arguments: (jint.jniType))
    public static func highestOneBit(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_highestOneBit_I__I(a0)
    }

    private static let java$lang$Integer_lowestOneBit_I__I = svoker("lowestOneBit", returns: jint.jniType, arguments: (jint.jniType))
    public static func lowestOneBit(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_lowestOneBit_I__I(a0)
    }

    private static let java$lang$Integer_numberOfLeadingZeros_I__I = svoker("numberOfLeadingZeros", returns: jint.jniType, arguments: (jint.jniType))
    public static func numberOfLeadingZeros(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_numberOfLeadingZeros_I__I(a0)
    }

    private static let java$lang$Integer_numberOfTrailingZeros_I__I = svoker("numberOfTrailingZeros", returns: jint.jniType, arguments: (jint.jniType))
    public static func numberOfTrailingZeros(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_numberOfTrailingZeros_I__I(a0)
    }

    private static let java$lang$Integer_bitCount_I__I = svoker("bitCount", returns: jint.jniType, arguments: (jint.jniType))
    public static func bitCount(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_bitCount_I__I(a0)
    }

    private static let java$lang$Integer_rotateLeft_I_I__I = svoker("rotateLeft", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func rotateLeft(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_rotateLeft_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_rotateRight_I_I__I = svoker("rotateRight", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func rotateRight(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_rotateRight_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_reverse_I__I = svoker("reverse", returns: jint.jniType, arguments: (jint.jniType))
    public static func reverse(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_reverse_I__I(a0)
    }

    private static let java$lang$Integer_signum_I__I = svoker("signum", returns: jint.jniType, arguments: (jint.jniType))
    public static func signum(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_signum_I__I(a0)
    }

    private static let java$lang$Integer_reverseBytes_I__I = svoker("reverseBytes", returns: jint.jniType, arguments: (jint.jniType))
    public static func reverseBytes(a0: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_reverseBytes_I__I(a0)
    }

    private static let java$lang$Integer_sum_I_I__I = svoker("sum", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func sum(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_sum_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_max_I_I__I = svoker("max", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func max(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_max_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_min_I_I__I = svoker("min", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func min(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_min_I_I__I(a0, a1)
    }

    private static let java$lang$Integer_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Integer$.java$lang$Integer_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Integer$ = java$lang$Integer

public class java$lang$InternalError : java$lang$VirtualMachineError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$InternalError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$InternalError$.java$lang$InternalError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$InternalError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$InternalError$.java$lang$InternalError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$InternalError_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$InternalError$.java$lang$InternalError_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$InternalError_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$InternalError$.java$lang$InternalError_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$InternalError$ = java$lang$InternalError

public class java$lang$InterruptedException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$InterruptedException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$InterruptedException$.java$lang$InterruptedException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$InterruptedException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$InterruptedException$.java$lang$InterruptedException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$InterruptedException$ = java$lang$InterruptedException

public protocol java$lang$Iterable : JavaObject {
    func iterator() throws -> java$util$Iterator?
    func forEach(a0: java$util$function$Consumer?) throws -> Void
    func spliterator() throws -> java$util$Spliterator?
}

public class java$lang$Iterable$ : java$lang$Object$, java$lang$Iterable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Iterable_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$lang$Iterable_forEach_java$util$function$Consumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    private static let java$lang$Iterable_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
}

public extension java$lang$Iterable {
    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$lang$Iterable$.java$lang$Iterable_iterator__java$util$Iterator(jobj)())
    }

    func forEach(a0: java$util$function$Consumer?) throws -> Void {
        return try java$lang$Iterable$.java$lang$Iterable_forEach_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

    func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$lang$Iterable$.java$lang$Iterable_spliterator__java$util$Spliterator(jobj)())
    }

}

public class java$lang$LinkageError : java$lang$Error$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$LinkageError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$LinkageError$.java$lang$LinkageError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$LinkageError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$LinkageError$.java$lang$LinkageError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$LinkageError_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$LinkageError$.java$lang$LinkageError_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$LinkageError$ = java$lang$LinkageError

public final class java$lang$Long : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Long_toString_J_I__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType, jint.jniType))
    public static func toString(a0: jlong, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toString_J_I__java$lang$String(a0, a1))
    }

    private static let java$lang$Long_toUnsignedString_J_I__java$lang$String = svoker("toUnsignedString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType, jint.jniType))
    public static func toUnsignedString(a0: jlong, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toUnsignedString_J_I__java$lang$String(a0, a1))
    }

    private static let java$lang$Long_toHexString_J__java$lang$String = svoker("toHexString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func toHexString(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toHexString_J__java$lang$String(a0))
    }

    private static let java$lang$Long_toOctalString_J__java$lang$String = svoker("toOctalString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func toOctalString(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toOctalString_J__java$lang$String(a0))
    }

    private static let java$lang$Long_toBinaryString_J__java$lang$String = svoker("toBinaryString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func toBinaryString(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toBinaryString_J__java$lang$String(a0))
    }

    private static let java$lang$Long_toString_J__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func toString(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toString_J__java$lang$String(a0))
    }

    private static let java$lang$Long_toUnsignedString_J__java$lang$String = svoker("toUnsignedString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func toUnsignedString(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Long$.java$lang$Long_toUnsignedString_J__java$lang$String(a0))
    }

    private static let java$lang$Long_parseLong_java$lang$String_I__J = svoker("parseLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseLong(a0: java$lang$String?, _ a1: jint) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_parseLong_java$lang$String_I__J(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Long_parseLong_java$lang$String__J = svoker("parseLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseLong(a0: java$lang$String?) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_parseLong_java$lang$String__J(a0?.jobj ?? nil)
    }

    private static let java$lang$Long_parseUnsignedLong_java$lang$String_I__J = svoker("parseUnsignedLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseUnsignedLong(a0: java$lang$String?, _ a1: jint) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_parseUnsignedLong_java$lang$String_I__J(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Long_parseUnsignedLong_java$lang$String__J = svoker("parseUnsignedLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseUnsignedLong(a0: java$lang$String?) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_parseUnsignedLong_java$lang$String__J(a0?.jobj ?? nil)
    }

    private static let java$lang$Long_valueOf_java$lang$String_I__java$lang$Long = svoker("valueOf", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func valueOf(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_valueOf_java$lang$String_I__java$lang$Long(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Long_valueOf_java$lang$String__java$lang$Long = svoker("valueOf", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_valueOf_java$lang$String__java$lang$Long(a0?.jobj ?? nil))
    }

    private static let java$lang$Long_valueOf_J__java$lang$Long = svoker("valueOf", returns: JObjectType("java/lang/Long"), arguments: (jlong.jniType))
    public static func valueOf(a0: jlong) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_valueOf_J__java$lang$Long(a0))
    }

    private static let java$lang$Long_decode_java$lang$String__java$lang$Long = svoker("decode", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_decode_java$lang$String__java$lang$Long(a0?.jobj ?? nil))
    }

    private static let java$lang$Long_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$lang$Long$.java$lang$Long_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Long_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Long$.java$lang$Long_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Long_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Long_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Long_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Long_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Long_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Long_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Long_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Long_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Long_hashCode_J__I = svoker("hashCode", returns: jint.jniType, arguments: (jlong.jniType))
    public static func hashCode(a0: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_hashCode_J__I(a0)
    }

    private static let java$lang$Long_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Long_getLong_java$lang$String__java$lang$Long = svoker("getLong", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String")))
    public static func getLong(a0: java$lang$String?) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_getLong_java$lang$String__java$lang$Long(a0?.jobj ?? nil))
    }

    private static let java$lang$Long_getLong_java$lang$String_J__java$lang$Long = svoker("getLong", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String"), jlong.jniType))
    public static func getLong(a0: java$lang$String?, _ a1: jlong) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_getLong_java$lang$String_J__java$lang$Long(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Long_getLong_java$lang$String_java$lang$Long__java$lang$Long = svoker("getLong", returns: JObjectType("java/lang/Long"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Long")))
    public static func getLong(a0: java$lang$String?, _ a1: java$lang$Long?) throws -> java$lang$Long? {
        return try java$lang$Long$(jobj: java$lang$Long$.java$lang$Long_getLong_java$lang$String_java$lang$Long__java$lang$Long(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$Long_compareTo_java$lang$Long__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Long")))
    public func compareTo(a0: java$lang$Long?) throws -> jint {
        return try java$lang$Long$.java$lang$Long_compareTo_java$lang$Long__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Long_compare_J_J__I = svoker("compare", returns: jint.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func compare(a0: jlong, _ a1: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_compare_J_J__I(a0, a1)
    }

    private static let java$lang$Long_compareUnsigned_J_J__I = svoker("compareUnsigned", returns: jint.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func compareUnsigned(a0: jlong, _ a1: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_compareUnsigned_J_J__I(a0, a1)
    }

    private static let java$lang$Long_divideUnsigned_J_J__J = svoker("divideUnsigned", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func divideUnsigned(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_divideUnsigned_J_J__J(a0, a1)
    }

    private static let java$lang$Long_remainderUnsigned_J_J__J = svoker("remainderUnsigned", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func remainderUnsigned(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_remainderUnsigned_J_J__J(a0, a1)
    }

    private static let java$lang$Long_highestOneBit_J__J = svoker("highestOneBit", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func highestOneBit(a0: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_highestOneBit_J__J(a0)
    }

    private static let java$lang$Long_lowestOneBit_J__J = svoker("lowestOneBit", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func lowestOneBit(a0: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_lowestOneBit_J__J(a0)
    }

    private static let java$lang$Long_numberOfLeadingZeros_J__I = svoker("numberOfLeadingZeros", returns: jint.jniType, arguments: (jlong.jniType))
    public static func numberOfLeadingZeros(a0: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_numberOfLeadingZeros_J__I(a0)
    }

    private static let java$lang$Long_numberOfTrailingZeros_J__I = svoker("numberOfTrailingZeros", returns: jint.jniType, arguments: (jlong.jniType))
    public static func numberOfTrailingZeros(a0: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_numberOfTrailingZeros_J__I(a0)
    }

    private static let java$lang$Long_bitCount_J__I = svoker("bitCount", returns: jint.jniType, arguments: (jlong.jniType))
    public static func bitCount(a0: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_bitCount_J__I(a0)
    }

    private static let java$lang$Long_rotateLeft_J_I__J = svoker("rotateLeft", returns: jlong.jniType, arguments: (jlong.jniType, jint.jniType))
    public static func rotateLeft(a0: jlong, _ a1: jint) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_rotateLeft_J_I__J(a0, a1)
    }

    private static let java$lang$Long_rotateRight_J_I__J = svoker("rotateRight", returns: jlong.jniType, arguments: (jlong.jniType, jint.jniType))
    public static func rotateRight(a0: jlong, _ a1: jint) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_rotateRight_J_I__J(a0, a1)
    }

    private static let java$lang$Long_reverse_J__J = svoker("reverse", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func reverse(a0: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_reverse_J__J(a0)
    }

    private static let java$lang$Long_signum_J__I = svoker("signum", returns: jint.jniType, arguments: (jlong.jniType))
    public static func signum(a0: jlong) throws -> jint {
        return try java$lang$Long$.java$lang$Long_signum_J__I(a0)
    }

    private static let java$lang$Long_reverseBytes_J__J = svoker("reverseBytes", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func reverseBytes(a0: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_reverseBytes_J__J(a0)
    }

    private static let java$lang$Long_sum_J_J__J = svoker("sum", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func sum(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_sum_J_J__J(a0, a1)
    }

    private static let java$lang$Long_max_J_J__J = svoker("max", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func max(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_max_J_J__J(a0, a1)
    }

    private static let java$lang$Long_min_J_J__J = svoker("min", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func min(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Long$.java$lang$Long_min_J_J__J(a0, a1)
    }

    private static let java$lang$Long_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Long$.java$lang$Long_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Long$ = java$lang$Long

public final class java$lang$Math : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Math_sin_D__D = svoker("sin", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sin(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_sin_D__D(a0)
    }

    private static let java$lang$Math_cos_D__D = svoker("cos", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cos(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_cos_D__D(a0)
    }

    private static let java$lang$Math_tan_D__D = svoker("tan", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func tan(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_tan_D__D(a0)
    }

    private static let java$lang$Math_asin_D__D = svoker("asin", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func asin(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_asin_D__D(a0)
    }

    private static let java$lang$Math_acos_D__D = svoker("acos", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func acos(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_acos_D__D(a0)
    }

    private static let java$lang$Math_atan_D__D = svoker("atan", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func atan(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_atan_D__D(a0)
    }

    private static let java$lang$Math_toRadians_D__D = svoker("toRadians", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func toRadians(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_toRadians_D__D(a0)
    }

    private static let java$lang$Math_toDegrees_D__D = svoker("toDegrees", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func toDegrees(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_toDegrees_D__D(a0)
    }

    private static let java$lang$Math_exp_D__D = svoker("exp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func exp(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_exp_D__D(a0)
    }

    private static let java$lang$Math_log_D__D = svoker("log", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_log_D__D(a0)
    }

    private static let java$lang$Math_log10_D__D = svoker("log10", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log10(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_log10_D__D(a0)
    }

    private static let java$lang$Math_sqrt_D__D = svoker("sqrt", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sqrt(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_sqrt_D__D(a0)
    }

    private static let java$lang$Math_cbrt_D__D = svoker("cbrt", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cbrt(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_cbrt_D__D(a0)
    }

    private static let java$lang$Math_IEEEremainder_D_D__D = svoker("IEEEremainder", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func IEEEremainder(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_IEEEremainder_D_D__D(a0, a1)
    }

    private static let java$lang$Math_ceil_D__D = svoker("ceil", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func ceil(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_ceil_D__D(a0)
    }

    private static let java$lang$Math_floor_D__D = svoker("floor", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func floor(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_floor_D__D(a0)
    }

    private static let java$lang$Math_rint_D__D = svoker("rint", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func rint(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_rint_D__D(a0)
    }

    private static let java$lang$Math_atan2_D_D__D = svoker("atan2", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func atan2(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_atan2_D_D__D(a0, a1)
    }

    private static let java$lang$Math_pow_D_D__D = svoker("pow", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func pow(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_pow_D_D__D(a0, a1)
    }

    private static let java$lang$Math_round_F__I = svoker("round", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func round(a0: jfloat) throws -> jint {
        return try java$lang$Math$.java$lang$Math_round_F__I(a0)
    }

    private static let java$lang$Math_round_D__J = svoker("round", returns: jlong.jniType, arguments: (jdouble.jniType))
    public static func round(a0: jdouble) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_round_D__J(a0)
    }

    private static let java$lang$Math_random__D = svoker("random", returns: jdouble.jniType)
    public static func random() throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_random__D()
    }

    private static let java$lang$Math_addExact_I_I__I = svoker("addExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func addExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_addExact_I_I__I(a0, a1)
    }

    private static let java$lang$Math_addExact_J_J__J = svoker("addExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func addExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_addExact_J_J__J(a0, a1)
    }

    private static let java$lang$Math_subtractExact_I_I__I = svoker("subtractExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func subtractExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_subtractExact_I_I__I(a0, a1)
    }

    private static let java$lang$Math_subtractExact_J_J__J = svoker("subtractExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func subtractExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_subtractExact_J_J__J(a0, a1)
    }

    private static let java$lang$Math_multiplyExact_I_I__I = svoker("multiplyExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func multiplyExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_multiplyExact_I_I__I(a0, a1)
    }

    private static let java$lang$Math_multiplyExact_J_J__J = svoker("multiplyExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func multiplyExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_multiplyExact_J_J__J(a0, a1)
    }

    private static let java$lang$Math_incrementExact_I__I = svoker("incrementExact", returns: jint.jniType, arguments: (jint.jniType))
    public static func incrementExact(a0: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_incrementExact_I__I(a0)
    }

    private static let java$lang$Math_incrementExact_J__J = svoker("incrementExact", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func incrementExact(a0: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_incrementExact_J__J(a0)
    }

    private static let java$lang$Math_decrementExact_I__I = svoker("decrementExact", returns: jint.jniType, arguments: (jint.jniType))
    public static func decrementExact(a0: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_decrementExact_I__I(a0)
    }

    private static let java$lang$Math_decrementExact_J__J = svoker("decrementExact", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func decrementExact(a0: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_decrementExact_J__J(a0)
    }

    private static let java$lang$Math_negateExact_I__I = svoker("negateExact", returns: jint.jniType, arguments: (jint.jniType))
    public static func negateExact(a0: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_negateExact_I__I(a0)
    }

    private static let java$lang$Math_negateExact_J__J = svoker("negateExact", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func negateExact(a0: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_negateExact_J__J(a0)
    }

    private static let java$lang$Math_toIntExact_J__I = svoker("toIntExact", returns: jint.jniType, arguments: (jlong.jniType))
    public static func toIntExact(a0: jlong) throws -> jint {
        return try java$lang$Math$.java$lang$Math_toIntExact_J__I(a0)
    }

    private static let java$lang$Math_floorDiv_I_I__I = svoker("floorDiv", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func floorDiv(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_floorDiv_I_I__I(a0, a1)
    }

    private static let java$lang$Math_floorDiv_J_J__J = svoker("floorDiv", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func floorDiv(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_floorDiv_J_J__J(a0, a1)
    }

    private static let java$lang$Math_floorMod_I_I__I = svoker("floorMod", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func floorMod(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_floorMod_I_I__I(a0, a1)
    }

    private static let java$lang$Math_floorMod_J_J__J = svoker("floorMod", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func floorMod(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_floorMod_J_J__J(a0, a1)
    }

    private static let java$lang$Math_abs_I__I = svoker("abs", returns: jint.jniType, arguments: (jint.jniType))
    public static func abs(a0: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_abs_I__I(a0)
    }

    private static let java$lang$Math_abs_J__J = svoker("abs", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func abs(a0: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_abs_J__J(a0)
    }

    private static let java$lang$Math_abs_F__F = svoker("abs", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func abs(a0: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_abs_F__F(a0)
    }

    private static let java$lang$Math_abs_D__D = svoker("abs", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func abs(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_abs_D__D(a0)
    }

    private static let java$lang$Math_max_I_I__I = svoker("max", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func max(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_max_I_I__I(a0, a1)
    }

    private static let java$lang$Math_max_J_J__J = svoker("max", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func max(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_max_J_J__J(a0, a1)
    }

    private static let java$lang$Math_max_F_F__F = svoker("max", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func max(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_max_F_F__F(a0, a1)
    }

    private static let java$lang$Math_max_D_D__D = svoker("max", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func max(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_max_D_D__D(a0, a1)
    }

    private static let java$lang$Math_min_I_I__I = svoker("min", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func min(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$Math$.java$lang$Math_min_I_I__I(a0, a1)
    }

    private static let java$lang$Math_min_J_J__J = svoker("min", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func min(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$Math$.java$lang$Math_min_J_J__J(a0, a1)
    }

    private static let java$lang$Math_min_F_F__F = svoker("min", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func min(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_min_F_F__F(a0, a1)
    }

    private static let java$lang$Math_min_D_D__D = svoker("min", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func min(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_min_D_D__D(a0, a1)
    }

    private static let java$lang$Math_ulp_D__D = svoker("ulp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func ulp(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_ulp_D__D(a0)
    }

    private static let java$lang$Math_ulp_F__F = svoker("ulp", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func ulp(a0: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_ulp_F__F(a0)
    }

    private static let java$lang$Math_signum_D__D = svoker("signum", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func signum(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_signum_D__D(a0)
    }

    private static let java$lang$Math_signum_F__F = svoker("signum", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func signum(a0: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_signum_F__F(a0)
    }

    private static let java$lang$Math_sinh_D__D = svoker("sinh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sinh(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_sinh_D__D(a0)
    }

    private static let java$lang$Math_cosh_D__D = svoker("cosh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cosh(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_cosh_D__D(a0)
    }

    private static let java$lang$Math_tanh_D__D = svoker("tanh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func tanh(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_tanh_D__D(a0)
    }

    private static let java$lang$Math_hypot_D_D__D = svoker("hypot", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func hypot(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_hypot_D_D__D(a0, a1)
    }

    private static let java$lang$Math_expm1_D__D = svoker("expm1", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func expm1(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_expm1_D__D(a0)
    }

    private static let java$lang$Math_log1p_D__D = svoker("log1p", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log1p(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_log1p_D__D(a0)
    }

    private static let java$lang$Math_copySign_D_D__D = svoker("copySign", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func copySign(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_copySign_D_D__D(a0, a1)
    }

    private static let java$lang$Math_copySign_F_F__F = svoker("copySign", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func copySign(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_copySign_F_F__F(a0, a1)
    }

    private static let java$lang$Math_getExponent_F__I = svoker("getExponent", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func getExponent(a0: jfloat) throws -> jint {
        return try java$lang$Math$.java$lang$Math_getExponent_F__I(a0)
    }

    private static let java$lang$Math_getExponent_D__I = svoker("getExponent", returns: jint.jniType, arguments: (jdouble.jniType))
    public static func getExponent(a0: jdouble) throws -> jint {
        return try java$lang$Math$.java$lang$Math_getExponent_D__I(a0)
    }

    private static let java$lang$Math_nextAfter_D_D__D = svoker("nextAfter", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func nextAfter(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_nextAfter_D_D__D(a0, a1)
    }

    private static let java$lang$Math_nextAfter_F_D__F = svoker("nextAfter", returns: jfloat.jniType, arguments: (jfloat.jniType, jdouble.jniType))
    public static func nextAfter(a0: jfloat, _ a1: jdouble) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_nextAfter_F_D__F(a0, a1)
    }

    private static let java$lang$Math_nextUp_D__D = svoker("nextUp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func nextUp(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_nextUp_D__D(a0)
    }

    private static let java$lang$Math_nextUp_F__F = svoker("nextUp", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func nextUp(a0: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_nextUp_F__F(a0)
    }

    private static let java$lang$Math_nextDown_D__D = svoker("nextDown", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func nextDown(a0: jdouble) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_nextDown_D__D(a0)
    }

    private static let java$lang$Math_nextDown_F__F = svoker("nextDown", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func nextDown(a0: jfloat) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_nextDown_F__F(a0)
    }

    private static let java$lang$Math_scalb_D_I__D = svoker("scalb", returns: jdouble.jniType, arguments: (jdouble.jniType, jint.jniType))
    public static func scalb(a0: jdouble, _ a1: jint) throws -> jdouble {
        return try java$lang$Math$.java$lang$Math_scalb_D_I__D(a0, a1)
    }

    private static let java$lang$Math_scalb_F_I__F = svoker("scalb", returns: jfloat.jniType, arguments: (jfloat.jniType, jint.jniType))
    public static func scalb(a0: jfloat, _ a1: jint) throws -> jfloat {
        return try java$lang$Math$.java$lang$Math_scalb_F_I__F(a0, a1)
    }

}

public typealias java$lang$Math$ = java$lang$Math

public class java$lang$NegativeArraySizeException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NegativeArraySizeException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NegativeArraySizeException$.java$lang$NegativeArraySizeException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NegativeArraySizeException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NegativeArraySizeException$.java$lang$NegativeArraySizeException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NegativeArraySizeException$ = java$lang$NegativeArraySizeException

public class java$lang$NoClassDefFoundError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NoClassDefFoundError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NoClassDefFoundError$.java$lang$NoClassDefFoundError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NoClassDefFoundError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NoClassDefFoundError$.java$lang$NoClassDefFoundError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NoClassDefFoundError$ = java$lang$NoClassDefFoundError

public class java$lang$NoSuchFieldError : java$lang$IncompatibleClassChangeError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NoSuchFieldError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NoSuchFieldError$.java$lang$NoSuchFieldError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NoSuchFieldError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NoSuchFieldError$.java$lang$NoSuchFieldError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NoSuchFieldError$ = java$lang$NoSuchFieldError

public class java$lang$NoSuchFieldException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NoSuchFieldException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NoSuchFieldException$.java$lang$NoSuchFieldException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NoSuchFieldException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NoSuchFieldException$.java$lang$NoSuchFieldException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NoSuchFieldException$ = java$lang$NoSuchFieldException

public class java$lang$NoSuchMethodError : java$lang$IncompatibleClassChangeError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NoSuchMethodError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NoSuchMethodError$.java$lang$NoSuchMethodError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NoSuchMethodError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NoSuchMethodError$.java$lang$NoSuchMethodError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NoSuchMethodError$ = java$lang$NoSuchMethodError

public class java$lang$NoSuchMethodException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NoSuchMethodException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NoSuchMethodException$.java$lang$NoSuchMethodException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NoSuchMethodException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NoSuchMethodException$.java$lang$NoSuchMethodException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NoSuchMethodException$ = java$lang$NoSuchMethodException

public class java$lang$NullPointerException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NullPointerException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NullPointerException$.java$lang$NullPointerException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NullPointerException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NullPointerException$.java$lang$NullPointerException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NullPointerException$ = java$lang$NullPointerException

public class java$lang$Number : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Number_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Number$.java$lang$Number_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Number_intValue__I = invoker("intValue", returns: jint.jniType)
    public func intValue() throws -> jint {
        return try java$lang$Number$.java$lang$Number_intValue__I(jobj)()
    }

    private static let java$lang$Number_longValue__J = invoker("longValue", returns: jlong.jniType)
    public func longValue() throws -> jlong {
        return try java$lang$Number$.java$lang$Number_longValue__J(jobj)()
    }

    private static let java$lang$Number_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    public func floatValue() throws -> jfloat {
        return try java$lang$Number$.java$lang$Number_floatValue__F(jobj)()
    }

    private static let java$lang$Number_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    public func doubleValue() throws -> jdouble {
        return try java$lang$Number$.java$lang$Number_doubleValue__D(jobj)()
    }

    private static let java$lang$Number_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    public func byteValue() throws -> jbyte {
        return try java$lang$Number$.java$lang$Number_byteValue__B(jobj)()
    }

    private static let java$lang$Number_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    public func shortValue() throws -> jshort {
        return try java$lang$Number$.java$lang$Number_shortValue__S(jobj)()
    }

}

public typealias java$lang$Number$ = java$lang$Number

public class java$lang$NumberFormatException : java$lang$IllegalArgumentException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$NumberFormatException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$NumberFormatException$.java$lang$NumberFormatException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$NumberFormatException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$NumberFormatException$.java$lang$NumberFormatException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$NumberFormatException$ = java$lang$NumberFormatException

public class java$lang$Object : JavaObject {
    public let jobj: jobject

    public required init?(jobj: jobject) {
        self.jobj = jobj == nil ? nil : JVM.sharedJVM.newGlobalRef(jobj)
        if jobj == nil { return nil }
    }

    deinit { 
        if self.jobj != nil { JVM.sharedJVM.deleteGlobalRef(self.jobj) }
    }

    private static let java$lang$Object_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Object$.java$lang$Object_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Object_getClass__java$lang$Class = invoker("getClass", returns: JObjectType("java/lang/Class"))
    public func getClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$Object$.java$lang$Object_getClass__java$lang$Class(jobj)())
    }

    private static let java$lang$Object_hashCode__I = invoker("hashCode", returns: jint.jniType)
    public func hashCode() throws -> jint {
        return try java$lang$Object$.java$lang$Object_hashCode__I(jobj)()
    }

    private static let java$lang$Object_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$Object$.java$lang$Object_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Object_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    public func toString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Object$.java$lang$Object_toString__java$lang$String(jobj)())
    }

    private static let java$lang$Object_notify__V = invoker("notify", returns: JVoid.jniType)
    public func notify() throws -> Void {
        return try java$lang$Object$.java$lang$Object_notify__V(jobj)()
    }

    private static let java$lang$Object_notifyAll__V = invoker("notifyAll", returns: JVoid.jniType)
    public func notifyAll() throws -> Void {
        return try java$lang$Object$.java$lang$Object_notifyAll__V(jobj)()
    }

    private static let java$lang$Object_wait_J__V = invoker("wait", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func wait(a0: jlong) throws -> Void {
        return try java$lang$Object$.java$lang$Object_wait_J__V(jobj)(a0)
    }

    private static let java$lang$Object_wait_J_I__V = invoker("wait", returns: JVoid.jniType, arguments: (jlong.jniType, jint.jniType))
    public func wait(a0: jlong, _ a1: jint) throws -> Void {
        return try java$lang$Object$.java$lang$Object_wait_J_I__V(jobj)(a0, a1)
    }

    private static let java$lang$Object_wait__V = invoker("wait", returns: JVoid.jniType)
    public func wait() throws -> Void {
        return try java$lang$Object$.java$lang$Object_wait__V(jobj)()
    }

}

public typealias java$lang$Object$ = java$lang$Object

public class java$lang$OutOfMemoryError : java$lang$VirtualMachineError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$OutOfMemoryError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$OutOfMemoryError$.java$lang$OutOfMemoryError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$OutOfMemoryError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$OutOfMemoryError$.java$lang$OutOfMemoryError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$OutOfMemoryError$ = java$lang$OutOfMemoryError

public protocol java$lang$Override : java$lang$annotation$Annotation {
}

public class java$lang$Override$ : java$lang$Object$, java$lang$Override, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$lang$Override {
}

public class java$lang$Package : java$lang$Object$, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Package_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getName__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getSpecificationTitle__java$lang$String = invoker("getSpecificationTitle", returns: JObjectType("java/lang/String"))
    public func getSpecificationTitle() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getSpecificationTitle__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getSpecificationVersion__java$lang$String = invoker("getSpecificationVersion", returns: JObjectType("java/lang/String"))
    public func getSpecificationVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getSpecificationVersion__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getSpecificationVendor__java$lang$String = invoker("getSpecificationVendor", returns: JObjectType("java/lang/String"))
    public func getSpecificationVendor() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getSpecificationVendor__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getImplementationTitle__java$lang$String = invoker("getImplementationTitle", returns: JObjectType("java/lang/String"))
    public func getImplementationTitle() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getImplementationTitle__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getImplementationVersion__java$lang$String = invoker("getImplementationVersion", returns: JObjectType("java/lang/String"))
    public func getImplementationVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getImplementationVersion__java$lang$String(jobj)())
    }

    private static let java$lang$Package_getImplementationVendor__java$lang$String = invoker("getImplementationVendor", returns: JObjectType("java/lang/String"))
    public func getImplementationVendor() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Package$.java$lang$Package_getImplementationVendor__java$lang$String(jobj)())
    }

    private static let java$lang$Package_isSealed__Z = invoker("isSealed", returns: jboolean.jniType)
    public func isSealed() throws -> jboolean {
        return try java$lang$Package$.java$lang$Package_isSealed__Z(jobj)()
    }

    private static let java$lang$Package_isSealed_java$net$URL__Z = invoker("isSealed", returns: jboolean.jniType, arguments: (JObjectType("java/net/URL")))
    public func isSealed(a0: java$net$URL?) throws -> jboolean {
        return try java$lang$Package$.java$lang$Package_isSealed_java$net$URL__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Package_isCompatibleWith_java$lang$String__Z = invoker("isCompatibleWith", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func isCompatibleWith(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$Package$.java$lang$Package_isCompatibleWith_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Package_getPackage_java$lang$String__java$lang$Package = svoker("getPackage", returns: JObjectType("java/lang/Package"), arguments: (JObjectType("java/lang/String")))
    public static func getPackage(a0: java$lang$String?) throws -> java$lang$Package? {
        return try java$lang$Package$(jobj: java$lang$Package$.java$lang$Package_getPackage_java$lang$String__java$lang$Package(a0?.jobj ?? nil))
    }

    private static let java$lang$Package_getPackages__Ajava$lang$Package = svoker("getPackages", returns: JArray(JObjectType("java/lang/Package")))
    public static func getPackages() throws -> [java$lang$Package?]? {
        return try java$lang$Package$.java$lang$Package_getPackages__Ajava$lang$Package().jarrayToArray(java$lang$Package$.self)?.map({ $0 as java$lang$Package? })
    }

    private static let java$lang$Package_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Package_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Package_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$Package$.java$lang$Package_getAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Package_isAnnotationPresent_java$lang$Class__Z = invoker("isAnnotationPresent", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public func isAnnotationPresent(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$Package$.java$lang$Package_isAnnotationPresent_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Package_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Package$.java$lang$Package_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Package_getAnnotations__Ajava$lang$annotation$Annotation = invoker("getAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Package$.java$lang$Package_getAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Package_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getDeclaredAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$Package$.java$lang$Package_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Package_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Package$.java$lang$Package_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$Package_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$Package$.java$lang$Package_getDeclaredAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

}

public typealias java$lang$Package$ = java$lang$Package

public class java$lang$Process : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Process_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Process$.java$lang$Process_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Process_getOutputStream__java$io$OutputStream = invoker("getOutputStream", returns: JObjectType("java/io/OutputStream"))
    public func getOutputStream() throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$lang$Process$.java$lang$Process_getOutputStream__java$io$OutputStream(jobj)())
    }

    private static let java$lang$Process_getInputStream__java$io$InputStream = invoker("getInputStream", returns: JObjectType("java/io/InputStream"))
    public func getInputStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$Process$.java$lang$Process_getInputStream__java$io$InputStream(jobj)())
    }

    private static let java$lang$Process_getErrorStream__java$io$InputStream = invoker("getErrorStream", returns: JObjectType("java/io/InputStream"))
    public func getErrorStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$Process$.java$lang$Process_getErrorStream__java$io$InputStream(jobj)())
    }

    private static let java$lang$Process_waitFor__I = invoker("waitFor", returns: jint.jniType)
    public func waitFor() throws -> jint {
        return try java$lang$Process$.java$lang$Process_waitFor__I(jobj)()
    }

    private static let java$lang$Process_waitFor_J_java$util$concurrent$TimeUnit__Z = invoker("waitFor", returns: jboolean.jniType, arguments: (jlong.jniType, JObjectType("java/util/concurrent/TimeUnit")))
    public func waitFor(a0: jlong, _ a1: java$util$concurrent$TimeUnit?) throws -> jboolean {
        return try java$lang$Process$.java$lang$Process_waitFor_J_java$util$concurrent$TimeUnit__Z(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$lang$Process_exitValue__I = invoker("exitValue", returns: jint.jniType)
    public func exitValue() throws -> jint {
        return try java$lang$Process$.java$lang$Process_exitValue__I(jobj)()
    }

    private static let java$lang$Process_destroy__V = invoker("destroy", returns: JVoid.jniType)
    public func destroy() throws -> Void {
        return try java$lang$Process$.java$lang$Process_destroy__V(jobj)()
    }

    private static let java$lang$Process_destroyForcibly__java$lang$Process = invoker("destroyForcibly", returns: JObjectType("java/lang/Process"))
    public func destroyForcibly() throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Process$.java$lang$Process_destroyForcibly__java$lang$Process(jobj)())
    }

    private static let java$lang$Process_isAlive__Z = invoker("isAlive", returns: jboolean.jniType)
    public func isAlive() throws -> jboolean {
        return try java$lang$Process$.java$lang$Process_isAlive__Z(jobj)()
    }

}

public typealias java$lang$Process$ = java$lang$Process

public final class java$lang$ProcessBuilder : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ProcessBuilder_init_java$util$List__V = constructor((JObjectType("java/util/List")))
    public convenience init!(_ a0: java$util$List?) throws {
        let jobj = try java$lang$ProcessBuilder$.java$lang$ProcessBuilder_init_java$util$List__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ProcessBuilder_init_Ajava$lang$String__V = constructor((JArray(JObjectType("java/lang/String"))))
    public convenience init!(_ a0: [java$lang$String?]?) throws {
        let jobj = try java$lang$ProcessBuilder$.java$lang$ProcessBuilder_init_Ajava$lang$String__V(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ProcessBuilder_command_java$util$List__java$lang$ProcessBuilder = invoker("command", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/util/List")))
    public func command(a0: java$util$List?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_command_java$util$List__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_command_Ajava$lang$String__java$lang$ProcessBuilder = invoker("command", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JArray(JObjectType("java/lang/String"))))
    public func command(a0: [java$lang$String?]?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_command_Ajava$lang$String__java$lang$ProcessBuilder(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$ProcessBuilder_command__java$util$List = invoker("command", returns: JObjectType("java/util/List"))
    public func command() throws -> java$util$List? {
        return try java$util$List$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_command__java$util$List(jobj)())
    }

    private static let java$lang$ProcessBuilder_environment__java$util$Map = invoker("environment", returns: JObjectType("java/util/Map"))
    public func environment() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_environment__java$util$Map(jobj)())
    }

    private static let java$lang$ProcessBuilder_directory__java$io$File = invoker("directory", returns: JObjectType("java/io/File"))
    public func directory() throws -> java$io$File? {
        return try java$io$File$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_directory__java$io$File(jobj)())
    }

    private static let java$lang$ProcessBuilder_directory_java$io$File__java$lang$ProcessBuilder = invoker("directory", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/io/File")))
    public func directory(a0: java$io$File?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_directory_java$io$File__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectInput_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder = invoker("redirectInput", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/lang/ProcessBuilder$Redirect")))
    public func redirectInput(a0: java$lang$ProcessBuilder$Redirect?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectInput_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectOutput_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder = invoker("redirectOutput", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/lang/ProcessBuilder$Redirect")))
    public func redirectOutput(a0: java$lang$ProcessBuilder$Redirect?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectOutput_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectError_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder = invoker("redirectError", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/lang/ProcessBuilder$Redirect")))
    public func redirectError(a0: java$lang$ProcessBuilder$Redirect?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectError_java$lang$ProcessBuilder$Redirect__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectInput_java$io$File__java$lang$ProcessBuilder = invoker("redirectInput", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/io/File")))
    public func redirectInput(a0: java$io$File?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectInput_java$io$File__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectOutput_java$io$File__java$lang$ProcessBuilder = invoker("redirectOutput", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/io/File")))
    public func redirectOutput(a0: java$io$File?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectOutput_java$io$File__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectError_java$io$File__java$lang$ProcessBuilder = invoker("redirectError", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (JObjectType("java/io/File")))
    public func redirectError(a0: java$io$File?) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectError_java$io$File__java$lang$ProcessBuilder(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$ProcessBuilder_redirectInput__java$lang$ProcessBuilder$Redirect = invoker("redirectInput", returns: JObjectType("java/lang/ProcessBuilder$Redirect"))
    public func redirectInput() throws -> java$lang$ProcessBuilder$Redirect? {
        return try java$lang$ProcessBuilder$Redirect$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectInput__java$lang$ProcessBuilder$Redirect(jobj)())
    }

    private static let java$lang$ProcessBuilder_redirectOutput__java$lang$ProcessBuilder$Redirect = invoker("redirectOutput", returns: JObjectType("java/lang/ProcessBuilder$Redirect"))
    public func redirectOutput() throws -> java$lang$ProcessBuilder$Redirect? {
        return try java$lang$ProcessBuilder$Redirect$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectOutput__java$lang$ProcessBuilder$Redirect(jobj)())
    }

    private static let java$lang$ProcessBuilder_redirectError__java$lang$ProcessBuilder$Redirect = invoker("redirectError", returns: JObjectType("java/lang/ProcessBuilder$Redirect"))
    public func redirectError() throws -> java$lang$ProcessBuilder$Redirect? {
        return try java$lang$ProcessBuilder$Redirect$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectError__java$lang$ProcessBuilder$Redirect(jobj)())
    }

    private static let java$lang$ProcessBuilder_inheritIO__java$lang$ProcessBuilder = invoker("inheritIO", returns: JObjectType("java/lang/ProcessBuilder"))
    public func inheritIO() throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_inheritIO__java$lang$ProcessBuilder(jobj)())
    }

    private static let java$lang$ProcessBuilder_redirectErrorStream__Z = invoker("redirectErrorStream", returns: jboolean.jniType)
    public func redirectErrorStream() throws -> jboolean {
        return try java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectErrorStream__Z(jobj)()
    }

    private static let java$lang$ProcessBuilder_redirectErrorStream_Z__java$lang$ProcessBuilder = invoker("redirectErrorStream", returns: JObjectType("java/lang/ProcessBuilder"), arguments: (jboolean.jniType))
    public func redirectErrorStream(a0: jboolean) throws -> java$lang$ProcessBuilder? {
        return try java$lang$ProcessBuilder$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_redirectErrorStream_Z__java$lang$ProcessBuilder(jobj)(a0))
    }

    private static let java$lang$ProcessBuilder_start__java$lang$Process = invoker("start", returns: JObjectType("java/lang/Process"))
    public func start() throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$ProcessBuilder$.java$lang$ProcessBuilder_start__java$lang$Process(jobj)())
    }

}

public typealias java$lang$ProcessBuilder$ = java$lang$ProcessBuilder

public final class java$lang$ProcessEnvironment : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$ProcessEnvironment$ = java$lang$ProcessEnvironment

public final class java$lang$ProcessImpl : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$ProcessImpl$ = java$lang$ProcessImpl

public protocol java$lang$Readable : JavaObject {
    func read(a0: java$nio$CharBuffer?) throws -> jint
}

public class java$lang$Readable$ : java$lang$Object$, java$lang$Readable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Readable_read_java$nio$CharBuffer__I = invoker("read", returns: jint.jniType, arguments: (JObjectType("java/nio/CharBuffer")))
}

public extension java$lang$Readable {
    func read(a0: java$nio$CharBuffer?) throws -> jint {
        return try java$lang$Readable$.java$lang$Readable_read_java$nio$CharBuffer__I(jobj)(a0?.jobj ?? nil)
    }

}

public class java$lang$ReflectiveOperationException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ReflectiveOperationException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ReflectiveOperationException$.java$lang$ReflectiveOperationException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ReflectiveOperationException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ReflectiveOperationException$.java$lang$ReflectiveOperationException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ReflectiveOperationException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$ReflectiveOperationException$.java$lang$ReflectiveOperationException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ReflectiveOperationException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$ReflectiveOperationException$.java$lang$ReflectiveOperationException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ReflectiveOperationException$ = java$lang$ReflectiveOperationException

public protocol java$lang$Runnable : JavaObject {
    func run() throws -> Void
}

public class java$lang$Runnable$ : java$lang$Object$, java$lang$Runnable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Runnable_run__V = invoker("run", returns: JVoid.jniType)
}

public extension java$lang$Runnable {
    func run() throws -> Void {
        return try java$lang$Runnable$.java$lang$Runnable_run__V(jobj)()
    }

}

public class java$lang$Runtime : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Runtime_getRuntime__java$lang$Runtime = svoker("getRuntime", returns: JObjectType("java/lang/Runtime"))
    public static func getRuntime() throws -> java$lang$Runtime? {
        return try java$lang$Runtime$(jobj: java$lang$Runtime$.java$lang$Runtime_getRuntime__java$lang$Runtime())
    }

    private static let java$lang$Runtime_exit_I__V = invoker("exit", returns: JVoid.jniType, arguments: (jint.jniType))
    public func exit(a0: jint) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_exit_I__V(jobj)(a0)
    }

    private static let java$lang$Runtime_addShutdownHook_java$lang$Thread__V = invoker("addShutdownHook", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Thread")))
    public func addShutdownHook(a0: java$lang$Thread?) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_addShutdownHook_java$lang$Thread__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Runtime_removeShutdownHook_java$lang$Thread__Z = invoker("removeShutdownHook", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Thread")))
    public func removeShutdownHook(a0: java$lang$Thread?) throws -> jboolean {
        return try java$lang$Runtime$.java$lang$Runtime_removeShutdownHook_java$lang$Thread__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Runtime_halt_I__V = invoker("halt", returns: JVoid.jniType, arguments: (jint.jniType))
    public func halt(a0: jint) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_halt_I__V(jobj)(a0)
    }

    private static let java$lang$Runtime_runFinalizersOnExit_Z__V = svoker("runFinalizersOnExit", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public static func runFinalizersOnExit(a0: jboolean) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_runFinalizersOnExit_Z__V(a0)
    }

    private static let java$lang$Runtime_exec_java$lang$String__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JObjectType("java/lang/String")))
    public func exec(a0: java$lang$String?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_java$lang$String__java$lang$Process(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Runtime_exec_java$lang$String_Ajava$lang$String__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    public func exec(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_java$lang$String_Ajava$lang$String__java$lang$Process(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Runtime_exec_java$lang$String_Ajava$lang$String_java$io$File__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String")), JObjectType("java/io/File")))
    public func exec(a0: java$lang$String?, _ a1: [java$lang$String?]?, _ a2: java$io$File?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_java$lang$String_Ajava$lang$String_java$io$File__java$lang$Process(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a2?.jobj ?? nil))
    }

    private static let java$lang$Runtime_exec_Ajava$lang$String__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JArray(JObjectType("java/lang/String"))))
    public func exec(a0: [java$lang$String?]?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_Ajava$lang$String__java$lang$Process(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Runtime_exec_Ajava$lang$String_Ajava$lang$String__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JArray(JObjectType("java/lang/String")), JArray(JObjectType("java/lang/String"))))
    public func exec(a0: [java$lang$String?]?, _ a1: [java$lang$String?]?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_Ajava$lang$String_Ajava$lang$String__java$lang$Process(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$Runtime_exec_Ajava$lang$String_Ajava$lang$String_java$io$File__java$lang$Process = invoker("exec", returns: JObjectType("java/lang/Process"), arguments: (JArray(JObjectType("java/lang/String")), JArray(JObjectType("java/lang/String")), JObjectType("java/io/File")))
    public func exec(a0: [java$lang$String?]?, _ a1: [java$lang$String?]?, _ a2: java$io$File?) throws -> java$lang$Process? {
        return try java$lang$Process$(jobj: java$lang$Runtime$.java$lang$Runtime_exec_Ajava$lang$String_Ajava$lang$String_java$io$File__java$lang$Process(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a2?.jobj ?? nil))
    }

    private static let java$lang$Runtime_availableProcessors__I = invoker("availableProcessors", returns: jint.jniType)
    public func availableProcessors() throws -> jint {
        return try java$lang$Runtime$.java$lang$Runtime_availableProcessors__I(jobj)()
    }

    private static let java$lang$Runtime_freeMemory__J = invoker("freeMemory", returns: jlong.jniType)
    public func freeMemory() throws -> jlong {
        return try java$lang$Runtime$.java$lang$Runtime_freeMemory__J(jobj)()
    }

    private static let java$lang$Runtime_totalMemory__J = invoker("totalMemory", returns: jlong.jniType)
    public func totalMemory() throws -> jlong {
        return try java$lang$Runtime$.java$lang$Runtime_totalMemory__J(jobj)()
    }

    private static let java$lang$Runtime_maxMemory__J = invoker("maxMemory", returns: jlong.jniType)
    public func maxMemory() throws -> jlong {
        return try java$lang$Runtime$.java$lang$Runtime_maxMemory__J(jobj)()
    }

    private static let java$lang$Runtime_gc__V = invoker("gc", returns: JVoid.jniType)
    public func gc() throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_gc__V(jobj)()
    }

    private static let java$lang$Runtime_runFinalization__V = invoker("runFinalization", returns: JVoid.jniType)
    public func runFinalization() throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_runFinalization__V(jobj)()
    }

    private static let java$lang$Runtime_traceInstructions_Z__V = invoker("traceInstructions", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func traceInstructions(a0: jboolean) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_traceInstructions_Z__V(jobj)(a0)
    }

    private static let java$lang$Runtime_traceMethodCalls_Z__V = invoker("traceMethodCalls", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func traceMethodCalls(a0: jboolean) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_traceMethodCalls_Z__V(jobj)(a0)
    }

    private static let java$lang$Runtime_load_java$lang$String__V = invoker("load", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func load(a0: java$lang$String?) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_load_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Runtime_loadLibrary_java$lang$String__V = invoker("loadLibrary", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func loadLibrary(a0: java$lang$String?) throws -> Void {
        return try java$lang$Runtime$.java$lang$Runtime_loadLibrary_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Runtime_getLocalizedInputStream_java$io$InputStream__java$io$InputStream = invoker("getLocalizedInputStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/io/InputStream")))
    public func getLocalizedInputStream(a0: java$io$InputStream?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$lang$Runtime$.java$lang$Runtime_getLocalizedInputStream_java$io$InputStream__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Runtime_getLocalizedOutputStream_java$io$OutputStream__java$io$OutputStream = invoker("getLocalizedOutputStream", returns: JObjectType("java/io/OutputStream"), arguments: (JObjectType("java/io/OutputStream")))
    public func getLocalizedOutputStream(a0: java$io$OutputStream?) throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$lang$Runtime$.java$lang$Runtime_getLocalizedOutputStream_java$io$OutputStream__java$io$OutputStream(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$lang$Runtime$ = java$lang$Runtime

public class java$lang$RuntimeException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$RuntimeException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$RuntimeException$.java$lang$RuntimeException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$RuntimeException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$RuntimeException$.java$lang$RuntimeException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$RuntimeException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$RuntimeException$.java$lang$RuntimeException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$RuntimeException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$RuntimeException$.java$lang$RuntimeException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$RuntimeException$ = java$lang$RuntimeException

public protocol java$lang$SafeVarargs : java$lang$annotation$Annotation {
}

public class java$lang$SafeVarargs$ : java$lang$Object$, java$lang$SafeVarargs, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$lang$SafeVarargs {
}

public class java$lang$SecurityException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$SecurityException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$SecurityException$.java$lang$SecurityException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$SecurityException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$SecurityException$.java$lang$SecurityException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$SecurityException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$SecurityException$.java$lang$SecurityException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$SecurityException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$SecurityException$.java$lang$SecurityException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$SecurityException$ = java$lang$SecurityException

public class java$lang$SecurityManager : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$SecurityManager_getInCheck__Z = invoker("getInCheck", returns: jboolean.jniType)
    public func getInCheck() throws -> jboolean {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_getInCheck__Z(jobj)()
    }

    private static let java$lang$SecurityManager_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$SecurityManager$.java$lang$SecurityManager_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$SecurityManager_getSecurityContext__java$lang$Object = invoker("getSecurityContext", returns: JObjectType("java/lang/Object"))
    public func getSecurityContext() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$SecurityManager$.java$lang$SecurityManager_getSecurityContext__java$lang$Object(jobj)())
    }

    private static let java$lang$SecurityManager_checkPermission_java$security$Permission__V = invoker("checkPermission", returns: JVoid.jniType, arguments: (JObjectType("java/security/Permission")))
    public func checkPermission(a0: java$security$Permission?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPermission_java$security$Permission__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkPermission_java$security$Permission_java$lang$Object__V = invoker("checkPermission", returns: JVoid.jniType, arguments: (JObjectType("java/security/Permission"), JObjectType("java/lang/Object")))
    public func checkPermission(a0: java$security$Permission?, _ a1: java$lang$Object?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPermission_java$security$Permission_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkCreateClassLoader__V = invoker("checkCreateClassLoader", returns: JVoid.jniType)
    public func checkCreateClassLoader() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkCreateClassLoader__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkAccess_java$lang$Thread__V = invoker("checkAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Thread")))
    public func checkAccess(a0: java$lang$Thread?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkAccess_java$lang$Thread__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkAccess_java$lang$ThreadGroup__V = invoker("checkAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/ThreadGroup")))
    public func checkAccess(a0: java$lang$ThreadGroup?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkAccess_java$lang$ThreadGroup__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkExit_I__V = invoker("checkExit", returns: JVoid.jniType, arguments: (jint.jniType))
    public func checkExit(a0: jint) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkExit_I__V(jobj)(a0)
    }

    private static let java$lang$SecurityManager_checkExec_java$lang$String__V = invoker("checkExec", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkExec(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkExec_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkLink_java$lang$String__V = invoker("checkLink", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkLink(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkLink_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkRead_java$io$FileDescriptor__V = invoker("checkRead", returns: JVoid.jniType, arguments: (JObjectType("java/io/FileDescriptor")))
    public func checkRead(a0: java$io$FileDescriptor?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkRead_java$io$FileDescriptor__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkRead_java$lang$String__V = invoker("checkRead", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkRead(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkRead_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkRead_java$lang$String_java$lang$Object__V = invoker("checkRead", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    public func checkRead(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkRead_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkWrite_java$io$FileDescriptor__V = invoker("checkWrite", returns: JVoid.jniType, arguments: (JObjectType("java/io/FileDescriptor")))
    public func checkWrite(a0: java$io$FileDescriptor?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkWrite_java$io$FileDescriptor__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkWrite_java$lang$String__V = invoker("checkWrite", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkWrite(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkWrite_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkDelete_java$lang$String__V = invoker("checkDelete", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkDelete(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkDelete_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkConnect_java$lang$String_I__V = invoker("checkConnect", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func checkConnect(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkConnect_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$SecurityManager_checkConnect_java$lang$String_I_java$lang$Object__V = invoker("checkConnect", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/Object")))
    public func checkConnect(a0: java$lang$String?, _ a1: jint, _ a2: java$lang$Object?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkConnect_java$lang$String_I_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkListen_I__V = invoker("checkListen", returns: JVoid.jniType, arguments: (jint.jniType))
    public func checkListen(a0: jint) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkListen_I__V(jobj)(a0)
    }

    private static let java$lang$SecurityManager_checkAccept_java$lang$String_I__V = invoker("checkAccept", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func checkAccept(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkAccept_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$SecurityManager_checkMulticast_java$net$InetAddress__V = invoker("checkMulticast", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress")))
    public func checkMulticast(a0: java$net$InetAddress?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkMulticast_java$net$InetAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkMulticast_java$net$InetAddress_B__V = invoker("checkMulticast", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress"), jbyte.jniType))
    public func checkMulticast(a0: java$net$InetAddress?, _ a1: jbyte) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkMulticast_java$net$InetAddress_B__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$SecurityManager_checkPropertiesAccess__V = invoker("checkPropertiesAccess", returns: JVoid.jniType)
    public func checkPropertiesAccess() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPropertiesAccess__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkPropertyAccess_java$lang$String__V = invoker("checkPropertyAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkPropertyAccess(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPropertyAccess_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkTopLevelWindow_java$lang$Object__Z = invoker("checkTopLevelWindow", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func checkTopLevelWindow(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkTopLevelWindow_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkPrintJobAccess__V = invoker("checkPrintJobAccess", returns: JVoid.jniType)
    public func checkPrintJobAccess() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPrintJobAccess__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkSystemClipboardAccess__V = invoker("checkSystemClipboardAccess", returns: JVoid.jniType)
    public func checkSystemClipboardAccess() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkSystemClipboardAccess__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkAwtEventQueueAccess__V = invoker("checkAwtEventQueueAccess", returns: JVoid.jniType)
    public func checkAwtEventQueueAccess() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkAwtEventQueueAccess__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkPackageAccess_java$lang$String__V = invoker("checkPackageAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkPackageAccess(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPackageAccess_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkPackageDefinition_java$lang$String__V = invoker("checkPackageDefinition", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkPackageDefinition(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkPackageDefinition_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_checkSetFactory__V = invoker("checkSetFactory", returns: JVoid.jniType)
    public func checkSetFactory() throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkSetFactory__V(jobj)()
    }

    private static let java$lang$SecurityManager_checkMemberAccess_java$lang$Class_I__V = invoker("checkMemberAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Class"), jint.jniType))
    public func checkMemberAccess(a0: java$lang$Class?, _ a1: jint) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkMemberAccess_java$lang$Class_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$SecurityManager_checkSecurityAccess_java$lang$String__V = invoker("checkSecurityAccess", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func checkSecurityAccess(a0: java$lang$String?) throws -> Void {
        return try java$lang$SecurityManager$.java$lang$SecurityManager_checkSecurityAccess_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$SecurityManager_getThreadGroup__java$lang$ThreadGroup = invoker("getThreadGroup", returns: JObjectType("java/lang/ThreadGroup"))
    public func getThreadGroup() throws -> java$lang$ThreadGroup? {
        return try java$lang$ThreadGroup$(jobj: java$lang$SecurityManager$.java$lang$SecurityManager_getThreadGroup__java$lang$ThreadGroup(jobj)())
    }

}

public typealias java$lang$SecurityManager$ = java$lang$SecurityManager

public final class java$lang$Short : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Short_toString_S__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jshort.jniType))
    public static func toString(a0: jshort) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Short$.java$lang$Short_toString_S__java$lang$String(a0))
    }

    private static let java$lang$Short_parseShort_java$lang$String_I__S = svoker("parseShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func parseShort(a0: java$lang$String?, _ a1: jint) throws -> jshort {
        return try java$lang$Short$.java$lang$Short_parseShort_java$lang$String_I__S(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$Short_parseShort_java$lang$String__S = svoker("parseShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parseShort(a0: java$lang$String?) throws -> jshort {
        return try java$lang$Short$.java$lang$Short_parseShort_java$lang$String__S(a0?.jobj ?? nil)
    }

    private static let java$lang$Short_valueOf_java$lang$String_I__java$lang$Short = svoker("valueOf", returns: JObjectType("java/lang/Short"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func valueOf(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Short? {
        return try java$lang$Short$(jobj: java$lang$Short$.java$lang$Short_valueOf_java$lang$String_I__java$lang$Short(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$Short_valueOf_java$lang$String__java$lang$Short = svoker("valueOf", returns: JObjectType("java/lang/Short"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$lang$Short? {
        return try java$lang$Short$(jobj: java$lang$Short$.java$lang$Short_valueOf_java$lang$String__java$lang$Short(a0?.jobj ?? nil))
    }

    private static let java$lang$Short_valueOf_S__java$lang$Short = svoker("valueOf", returns: JObjectType("java/lang/Short"), arguments: (jshort.jniType))
    public static func valueOf(a0: jshort) throws -> java$lang$Short? {
        return try java$lang$Short$(jobj: java$lang$Short$.java$lang$Short_valueOf_S__java$lang$Short(a0))
    }

    private static let java$lang$Short_decode_java$lang$String__java$lang$Short = svoker("decode", returns: JObjectType("java/lang/Short"), arguments: (JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?) throws -> java$lang$Short? {
        return try java$lang$Short$(jobj: java$lang$Short$.java$lang$Short_decode_java$lang$String__java$lang$Short(a0?.jobj ?? nil))
    }

    private static let java$lang$Short_init_S__V = constructor((jshort.jniType))
    public convenience init!(_ a0: jshort) throws {
        let jobj = try java$lang$Short$.java$lang$Short_init_S__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$Short_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Short$.java$lang$Short_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Short_byteValue__B = invoker("byteValue", returns: jbyte.jniType)
    private static let java$lang$Short_shortValue__S = invoker("shortValue", returns: jshort.jniType)
    private static let java$lang$Short_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$lang$Short_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$lang$Short_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$lang$Short_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$lang$Short_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Short_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$Short_hashCode_S__I = svoker("hashCode", returns: jint.jniType, arguments: (jshort.jniType))
    public static func hashCode(a0: jshort) throws -> jint {
        return try java$lang$Short$.java$lang$Short_hashCode_S__I(a0)
    }

    private static let java$lang$Short_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$Short_compareTo_java$lang$Short__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Short")))
    public func compareTo(a0: java$lang$Short?) throws -> jint {
        return try java$lang$Short$.java$lang$Short_compareTo_java$lang$Short__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Short_compare_S_S__I = svoker("compare", returns: jint.jniType, arguments: (jshort.jniType, jshort.jniType))
    public static func compare(a0: jshort, _ a1: jshort) throws -> jint {
        return try java$lang$Short$.java$lang$Short_compare_S_S__I(a0, a1)
    }

    private static let java$lang$Short_reverseBytes_S__S = svoker("reverseBytes", returns: jshort.jniType, arguments: (jshort.jniType))
    public static func reverseBytes(a0: jshort) throws -> jshort {
        return try java$lang$Short$.java$lang$Short_reverseBytes_S__S(a0)
    }

    private static let java$lang$Short_toUnsignedInt_S__I = svoker("toUnsignedInt", returns: jint.jniType, arguments: (jshort.jniType))
    public static func toUnsignedInt(a0: jshort) throws -> jint {
        return try java$lang$Short$.java$lang$Short_toUnsignedInt_S__I(a0)
    }

    private static let java$lang$Short_toUnsignedLong_S__J = svoker("toUnsignedLong", returns: jlong.jniType, arguments: (jshort.jniType))
    public static func toUnsignedLong(a0: jshort) throws -> jlong {
        return try java$lang$Short$.java$lang$Short_toUnsignedLong_S__J(a0)
    }

    private static let java$lang$Short_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$Short$.java$lang$Short_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Short$ = java$lang$Short

public class java$lang$Shutdown : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$Shutdown$ = java$lang$Shutdown

public class java$lang$StackOverflowError : java$lang$VirtualMachineError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StackOverflowError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$StackOverflowError$.java$lang$StackOverflowError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$StackOverflowError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$StackOverflowError$.java$lang$StackOverflowError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$StackOverflowError$ = java$lang$StackOverflowError

public final class java$lang$StackTraceElement : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StackTraceElement_init_java$lang$String_java$lang$String_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jint) throws {
        let jobj = try java$lang$StackTraceElement$.java$lang$StackTraceElement_init_java$lang$String_java$lang$String_java$lang$String_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
        self.init(jobj: jobj)
    }

    private static let java$lang$StackTraceElement_getFileName__java$lang$String = invoker("getFileName", returns: JObjectType("java/lang/String"))
    public func getFileName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$StackTraceElement$.java$lang$StackTraceElement_getFileName__java$lang$String(jobj)())
    }

    private static let java$lang$StackTraceElement_getLineNumber__I = invoker("getLineNumber", returns: jint.jniType)
    public func getLineNumber() throws -> jint {
        return try java$lang$StackTraceElement$.java$lang$StackTraceElement_getLineNumber__I(jobj)()
    }

    private static let java$lang$StackTraceElement_getClassName__java$lang$String = invoker("getClassName", returns: JObjectType("java/lang/String"))
    public func getClassName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$StackTraceElement$.java$lang$StackTraceElement_getClassName__java$lang$String(jobj)())
    }

    private static let java$lang$StackTraceElement_getMethodName__java$lang$String = invoker("getMethodName", returns: JObjectType("java/lang/String"))
    public func getMethodName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$StackTraceElement$.java$lang$StackTraceElement_getMethodName__java$lang$String(jobj)())
    }

    private static let java$lang$StackTraceElement_isNativeMethod__Z = invoker("isNativeMethod", returns: jboolean.jniType)
    public func isNativeMethod() throws -> jboolean {
        return try java$lang$StackTraceElement$.java$lang$StackTraceElement_isNativeMethod__Z(jobj)()
    }

    private static let java$lang$StackTraceElement_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$StackTraceElement_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$StackTraceElement_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$lang$StackTraceElement$ = java$lang$StackTraceElement

public final class java$lang$StrictMath : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StrictMath_sin_D__D = svoker("sin", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sin(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_sin_D__D(a0)
    }

    private static let java$lang$StrictMath_cos_D__D = svoker("cos", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cos(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_cos_D__D(a0)
    }

    private static let java$lang$StrictMath_tan_D__D = svoker("tan", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func tan(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_tan_D__D(a0)
    }

    private static let java$lang$StrictMath_asin_D__D = svoker("asin", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func asin(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_asin_D__D(a0)
    }

    private static let java$lang$StrictMath_acos_D__D = svoker("acos", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func acos(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_acos_D__D(a0)
    }

    private static let java$lang$StrictMath_atan_D__D = svoker("atan", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func atan(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_atan_D__D(a0)
    }

    private static let java$lang$StrictMath_toRadians_D__D = svoker("toRadians", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func toRadians(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_toRadians_D__D(a0)
    }

    private static let java$lang$StrictMath_toDegrees_D__D = svoker("toDegrees", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func toDegrees(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_toDegrees_D__D(a0)
    }

    private static let java$lang$StrictMath_exp_D__D = svoker("exp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func exp(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_exp_D__D(a0)
    }

    private static let java$lang$StrictMath_log_D__D = svoker("log", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_log_D__D(a0)
    }

    private static let java$lang$StrictMath_log10_D__D = svoker("log10", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log10(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_log10_D__D(a0)
    }

    private static let java$lang$StrictMath_sqrt_D__D = svoker("sqrt", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sqrt(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_sqrt_D__D(a0)
    }

    private static let java$lang$StrictMath_cbrt_D__D = svoker("cbrt", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cbrt(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_cbrt_D__D(a0)
    }

    private static let java$lang$StrictMath_IEEEremainder_D_D__D = svoker("IEEEremainder", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func IEEEremainder(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_IEEEremainder_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_ceil_D__D = svoker("ceil", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func ceil(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_ceil_D__D(a0)
    }

    private static let java$lang$StrictMath_floor_D__D = svoker("floor", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func floor(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_floor_D__D(a0)
    }

    private static let java$lang$StrictMath_rint_D__D = svoker("rint", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func rint(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_rint_D__D(a0)
    }

    private static let java$lang$StrictMath_atan2_D_D__D = svoker("atan2", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func atan2(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_atan2_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_pow_D_D__D = svoker("pow", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func pow(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_pow_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_round_F__I = svoker("round", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func round(a0: jfloat) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_round_F__I(a0)
    }

    private static let java$lang$StrictMath_round_D__J = svoker("round", returns: jlong.jniType, arguments: (jdouble.jniType))
    public static func round(a0: jdouble) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_round_D__J(a0)
    }

    private static let java$lang$StrictMath_random__D = svoker("random", returns: jdouble.jniType)
    public static func random() throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_random__D()
    }

    private static let java$lang$StrictMath_addExact_I_I__I = svoker("addExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func addExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_addExact_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_addExact_J_J__J = svoker("addExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func addExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_addExact_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_subtractExact_I_I__I = svoker("subtractExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func subtractExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_subtractExact_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_subtractExact_J_J__J = svoker("subtractExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func subtractExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_subtractExact_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_multiplyExact_I_I__I = svoker("multiplyExact", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func multiplyExact(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_multiplyExact_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_multiplyExact_J_J__J = svoker("multiplyExact", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func multiplyExact(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_multiplyExact_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_toIntExact_J__I = svoker("toIntExact", returns: jint.jniType, arguments: (jlong.jniType))
    public static func toIntExact(a0: jlong) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_toIntExact_J__I(a0)
    }

    private static let java$lang$StrictMath_floorDiv_I_I__I = svoker("floorDiv", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func floorDiv(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_floorDiv_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_floorDiv_J_J__J = svoker("floorDiv", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func floorDiv(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_floorDiv_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_floorMod_I_I__I = svoker("floorMod", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func floorMod(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_floorMod_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_floorMod_J_J__J = svoker("floorMod", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func floorMod(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_floorMod_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_abs_I__I = svoker("abs", returns: jint.jniType, arguments: (jint.jniType))
    public static func abs(a0: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_abs_I__I(a0)
    }

    private static let java$lang$StrictMath_abs_J__J = svoker("abs", returns: jlong.jniType, arguments: (jlong.jniType))
    public static func abs(a0: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_abs_J__J(a0)
    }

    private static let java$lang$StrictMath_abs_F__F = svoker("abs", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func abs(a0: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_abs_F__F(a0)
    }

    private static let java$lang$StrictMath_abs_D__D = svoker("abs", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func abs(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_abs_D__D(a0)
    }

    private static let java$lang$StrictMath_max_I_I__I = svoker("max", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func max(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_max_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_max_J_J__J = svoker("max", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func max(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_max_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_max_F_F__F = svoker("max", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func max(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_max_F_F__F(a0, a1)
    }

    private static let java$lang$StrictMath_max_D_D__D = svoker("max", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func max(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_max_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_min_I_I__I = svoker("min", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public static func min(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_min_I_I__I(a0, a1)
    }

    private static let java$lang$StrictMath_min_J_J__J = svoker("min", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public static func min(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$lang$StrictMath$.java$lang$StrictMath_min_J_J__J(a0, a1)
    }

    private static let java$lang$StrictMath_min_F_F__F = svoker("min", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func min(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_min_F_F__F(a0, a1)
    }

    private static let java$lang$StrictMath_min_D_D__D = svoker("min", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func min(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_min_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_ulp_D__D = svoker("ulp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func ulp(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_ulp_D__D(a0)
    }

    private static let java$lang$StrictMath_ulp_F__F = svoker("ulp", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func ulp(a0: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_ulp_F__F(a0)
    }

    private static let java$lang$StrictMath_signum_D__D = svoker("signum", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func signum(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_signum_D__D(a0)
    }

    private static let java$lang$StrictMath_signum_F__F = svoker("signum", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func signum(a0: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_signum_F__F(a0)
    }

    private static let java$lang$StrictMath_sinh_D__D = svoker("sinh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func sinh(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_sinh_D__D(a0)
    }

    private static let java$lang$StrictMath_cosh_D__D = svoker("cosh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func cosh(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_cosh_D__D(a0)
    }

    private static let java$lang$StrictMath_tanh_D__D = svoker("tanh", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func tanh(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_tanh_D__D(a0)
    }

    private static let java$lang$StrictMath_hypot_D_D__D = svoker("hypot", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func hypot(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_hypot_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_expm1_D__D = svoker("expm1", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func expm1(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_expm1_D__D(a0)
    }

    private static let java$lang$StrictMath_log1p_D__D = svoker("log1p", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func log1p(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_log1p_D__D(a0)
    }

    private static let java$lang$StrictMath_copySign_D_D__D = svoker("copySign", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func copySign(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_copySign_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_copySign_F_F__F = svoker("copySign", returns: jfloat.jniType, arguments: (jfloat.jniType, jfloat.jniType))
    public static func copySign(a0: jfloat, _ a1: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_copySign_F_F__F(a0, a1)
    }

    private static let java$lang$StrictMath_getExponent_F__I = svoker("getExponent", returns: jint.jniType, arguments: (jfloat.jniType))
    public static func getExponent(a0: jfloat) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_getExponent_F__I(a0)
    }

    private static let java$lang$StrictMath_getExponent_D__I = svoker("getExponent", returns: jint.jniType, arguments: (jdouble.jniType))
    public static func getExponent(a0: jdouble) throws -> jint {
        return try java$lang$StrictMath$.java$lang$StrictMath_getExponent_D__I(a0)
    }

    private static let java$lang$StrictMath_nextAfter_D_D__D = svoker("nextAfter", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public static func nextAfter(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextAfter_D_D__D(a0, a1)
    }

    private static let java$lang$StrictMath_nextAfter_F_D__F = svoker("nextAfter", returns: jfloat.jniType, arguments: (jfloat.jniType, jdouble.jniType))
    public static func nextAfter(a0: jfloat, _ a1: jdouble) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextAfter_F_D__F(a0, a1)
    }

    private static let java$lang$StrictMath_nextUp_D__D = svoker("nextUp", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func nextUp(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextUp_D__D(a0)
    }

    private static let java$lang$StrictMath_nextUp_F__F = svoker("nextUp", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func nextUp(a0: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextUp_F__F(a0)
    }

    private static let java$lang$StrictMath_nextDown_D__D = svoker("nextDown", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func nextDown(a0: jdouble) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextDown_D__D(a0)
    }

    private static let java$lang$StrictMath_nextDown_F__F = svoker("nextDown", returns: jfloat.jniType, arguments: (jfloat.jniType))
    public static func nextDown(a0: jfloat) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_nextDown_F__F(a0)
    }

    private static let java$lang$StrictMath_scalb_D_I__D = svoker("scalb", returns: jdouble.jniType, arguments: (jdouble.jniType, jint.jniType))
    public static func scalb(a0: jdouble, _ a1: jint) throws -> jdouble {
        return try java$lang$StrictMath$.java$lang$StrictMath_scalb_D_I__D(a0, a1)
    }

    private static let java$lang$StrictMath_scalb_F_I__F = svoker("scalb", returns: jfloat.jniType, arguments: (jfloat.jniType, jint.jniType))
    public static func scalb(a0: jfloat, _ a1: jint) throws -> jfloat {
        return try java$lang$StrictMath$.java$lang$StrictMath_scalb_F_I__F(a0, a1)
    }

}

public typealias java$lang$StrictMath$ = java$lang$StrictMath

public final class java$lang$String : java$lang$Object$, java$io$Serializable, java$lang$Comparable, java$lang$CharSequence {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$String_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$String$.java$lang$String_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AC__V = constructor((JArray(jchar.jniType)))
    public convenience init!(_ a0: [jchar]?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AC__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AC_I_I__V = constructor((JArray(jchar.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jchar]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AC_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AI_I_I__V = constructor((JArray(jint.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jint]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AI_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_I_I_I__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: jint) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_I_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_I__V = constructor((JArray(jbyte.jniType), jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_I__V(a0?.arrayToJArray() ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_I_I_java$lang$String__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: java$lang$String?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_I_I_java$lang$String__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_I_I_java$nio$charset$Charset__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType, JObjectType("java/nio/charset/Charset")))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: java$nio$charset$Charset?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_I_I_java$nio$charset$Charset__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_java$lang$String__V = constructor((JArray(jbyte.jniType), JObjectType("java/lang/String")))
    public convenience init!(_ a0: [jbyte]?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_java$lang$String__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_java$nio$charset$Charset__V = constructor((JArray(jbyte.jniType), JObjectType("java/nio/charset/Charset")))
    public convenience init!(_ a0: [jbyte]?, _ a1: java$nio$charset$Charset?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_java$nio$charset$Charset__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB_I_I__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_AB__V = constructor((JArray(jbyte.jniType)))
    public convenience init!(_ a0: [jbyte]?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_AB__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_java$lang$StringBuffer__V = constructor((JObjectType("java/lang/StringBuffer")))
    public convenience init!(_ a0: java$lang$StringBuffer?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_java$lang$StringBuffer__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_init_java$lang$StringBuilder__V = constructor((JObjectType("java/lang/StringBuilder")))
    public convenience init!(_ a0: java$lang$StringBuilder?) throws {
        let jobj = try java$lang$String$.java$lang$String_init_java$lang$StringBuilder__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$String_length__I = invoker("length", returns: jint.jniType)
    public func length() throws -> jint {
        return try java$lang$String$.java$lang$String_length__I(jobj)()
    }

    private static let java$lang$String_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try java$lang$String$.java$lang$String_isEmpty__Z(jobj)()
    }

    private static let java$lang$String_charAt_I__C = invoker("charAt", returns: jchar.jniType, arguments: (jint.jniType))
    public func charAt(a0: jint) throws -> jchar {
        return try java$lang$String$.java$lang$String_charAt_I__C(jobj)(a0)
    }

    private static let java$lang$String_codePointAt_I__I = invoker("codePointAt", returns: jint.jniType, arguments: (jint.jniType))
    public func codePointAt(a0: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_codePointAt_I__I(jobj)(a0)
    }

    private static let java$lang$String_codePointBefore_I__I = invoker("codePointBefore", returns: jint.jniType, arguments: (jint.jniType))
    public func codePointBefore(a0: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_codePointBefore_I__I(jobj)(a0)
    }

    private static let java$lang$String_codePointCount_I_I__I = invoker("codePointCount", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func codePointCount(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_codePointCount_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$String_offsetByCodePoints_I_I__I = invoker("offsetByCodePoints", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func offsetByCodePoints(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_offsetByCodePoints_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$String_getChars_I_I_AC_I__V = invoker("getChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JArray(jchar.jniType), jint.jniType))
    public func getChars(a0: jint, _ a1: jint, _ a2: [jchar]?, _ a3: jint) throws -> Void {
        return try java$lang$String$.java$lang$String_getChars_I_I_AC_I__V(jobj)(a0, a1, a2?.arrayToJArray() ?? nil, a3)
    }

    private static let java$lang$String_getBytes_I_I_AB_I__V = invoker("getBytes", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JArray(jbyte.jniType), jint.jniType))
    public func getBytes(a0: jint, _ a1: jint, _ a2: [jbyte]?, _ a3: jint) throws -> Void {
        return try java$lang$String$.java$lang$String_getBytes_I_I_AB_I__V(jobj)(a0, a1, a2?.arrayToJArray() ?? nil, a3)
    }

    private static let java$lang$String_getBytes_java$lang$String__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/String")))
    public func getBytes(a0: java$lang$String?) throws -> [jbyte]? {
        return try java$lang$String$.java$lang$String_getBytes_java$lang$String__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    private static let java$lang$String_getBytes_java$nio$charset$Charset__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/nio/charset/Charset")))
    public func getBytes(a0: java$nio$charset$Charset?) throws -> [jbyte]? {
        return try java$lang$String$.java$lang$String_getBytes_java$nio$charset$Charset__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    private static let java$lang$String_getBytes__AB = invoker("getBytes", returns: JArray(jbyte.jniType))
    public func getBytes() throws -> [jbyte]? {
        return try java$lang$String$.java$lang$String_getBytes__AB(jobj)().jarrayToArray()
    }

    private static let java$lang$String_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$String_contentEquals_java$lang$StringBuffer__Z = invoker("contentEquals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/StringBuffer")))
    public func contentEquals(a0: java$lang$StringBuffer?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_contentEquals_java$lang$StringBuffer__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_contentEquals_java$lang$CharSequence__Z = invoker("contentEquals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/CharSequence")))
    public func contentEquals(a0: java$lang$CharSequence?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_contentEquals_java$lang$CharSequence__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_equalsIgnoreCase_java$lang$String__Z = invoker("equalsIgnoreCase", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func equalsIgnoreCase(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_equalsIgnoreCase_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_compareTo_java$lang$String__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func compareTo(a0: java$lang$String?) throws -> jint {
        return try java$lang$String$.java$lang$String_compareTo_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_compareToIgnoreCase_java$lang$String__I = invoker("compareToIgnoreCase", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func compareToIgnoreCase(a0: java$lang$String?) throws -> jint {
        return try java$lang$String$.java$lang$String_compareToIgnoreCase_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_regionMatches_I_java$lang$String_I_I__Z = invoker("regionMatches", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    public func regionMatches(a0: jint, _ a1: java$lang$String?, _ a2: jint, _ a3: jint) throws -> jboolean {
        return try java$lang$String$.java$lang$String_regionMatches_I_java$lang$String_I_I__Z(jobj)(a0, a1?.jobj ?? nil, a2, a3)
    }

    private static let java$lang$String_regionMatches_Z_I_java$lang$String_I_I__Z = invoker("regionMatches", returns: jboolean.jniType, arguments: (jboolean.jniType, jint.jniType, JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    public func regionMatches(a0: jboolean, _ a1: jint, _ a2: java$lang$String?, _ a3: jint, _ a4: jint) throws -> jboolean {
        return try java$lang$String$.java$lang$String_regionMatches_Z_I_java$lang$String_I_I__Z(jobj)(a0, a1, a2?.jobj ?? nil, a3, a4)
    }

    private static let java$lang$String_startsWith_java$lang$String_I__Z = invoker("startsWith", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func startsWith(a0: java$lang$String?, _ a1: jint) throws -> jboolean {
        return try java$lang$String$.java$lang$String_startsWith_java$lang$String_I__Z(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$String_startsWith_java$lang$String__Z = invoker("startsWith", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func startsWith(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_startsWith_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_endsWith_java$lang$String__Z = invoker("endsWith", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func endsWith(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_endsWith_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$String_indexOf_I__I = invoker("indexOf", returns: jint.jniType, arguments: (jint.jniType))
    public func indexOf(a0: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_indexOf_I__I(jobj)(a0)
    }

    private static let java$lang$String_indexOf_I_I__I = invoker("indexOf", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func indexOf(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_indexOf_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$String_lastIndexOf_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (jint.jniType))
    public func lastIndexOf(a0: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_lastIndexOf_I__I(jobj)(a0)
    }

    private static let java$lang$String_lastIndexOf_I_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func lastIndexOf(a0: jint, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_lastIndexOf_I_I__I(jobj)(a0, a1)
    }

    private static let java$lang$String_indexOf_java$lang$String__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func indexOf(a0: java$lang$String?) throws -> jint {
        return try java$lang$String$.java$lang$String_indexOf_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_indexOf_java$lang$String_I__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func indexOf(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_indexOf_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$String_lastIndexOf_java$lang$String__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func lastIndexOf(a0: java$lang$String?) throws -> jint {
        return try java$lang$String$.java$lang$String_lastIndexOf_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_lastIndexOf_java$lang$String_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func lastIndexOf(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$lang$String$.java$lang$String_lastIndexOf_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$String_substring_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func substring(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_substring_I__java$lang$String(jobj)(a0))
    }

    private static let java$lang$String_substring_I_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    public func substring(a0: jint, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_substring_I_I__java$lang$String(jobj)(a0, a1))
    }

    private static let java$lang$String_subSequence_I_I__java$lang$CharSequence = invoker("subSequence", returns: JObjectType("java/lang/CharSequence"), arguments: (jint.jniType, jint.jniType))
    public func subSequence(a0: jint, _ a1: jint) throws -> java$lang$CharSequence? {
        return try java$lang$CharSequence$(jobj: java$lang$String$.java$lang$String_subSequence_I_I__java$lang$CharSequence(jobj)(a0, a1))
    }

    private static let java$lang$String_concat_java$lang$String__java$lang$String = invoker("concat", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func concat(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_concat_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$String_replace_C_C__java$lang$String = invoker("replace", returns: JObjectType("java/lang/String"), arguments: (jchar.jniType, jchar.jniType))
    public func replace(a0: jchar, _ a1: jchar) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_replace_C_C__java$lang$String(jobj)(a0, a1))
    }

    private static let java$lang$String_matches_java$lang$String__Z = invoker("matches", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func matches(a0: java$lang$String?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_matches_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_contains_java$lang$CharSequence__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/CharSequence")))
    public func contains(a0: java$lang$CharSequence?) throws -> jboolean {
        return try java$lang$String$.java$lang$String_contains_java$lang$CharSequence__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$String_replaceFirst_java$lang$String_java$lang$String__java$lang$String = invoker("replaceFirst", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func replaceFirst(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_replaceFirst_java$lang$String_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$String_replaceAll_java$lang$String_java$lang$String__java$lang$String = invoker("replaceAll", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func replaceAll(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_replaceAll_java$lang$String_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$String_replace_java$lang$CharSequence_java$lang$CharSequence__java$lang$String = invoker("replace", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/CharSequence"), JObjectType("java/lang/CharSequence")))
    public func replace(a0: java$lang$CharSequence?, _ a1: java$lang$CharSequence?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_replace_java$lang$CharSequence_java$lang$CharSequence__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$String_split_java$lang$String_I__Ajava$lang$String = invoker("split", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func split(a0: java$lang$String?, _ a1: jint) throws -> [java$lang$String?]? {
        return try java$lang$String$.java$lang$String_split_java$lang$String_I__Ajava$lang$String(jobj)(a0?.jobj ?? nil, a1).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$lang$String_split_java$lang$String__Ajava$lang$String = invoker("split", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/lang/String")))
    public func split(a0: java$lang$String?) throws -> [java$lang$String?]? {
        return try java$lang$String$.java$lang$String_split_java$lang$String__Ajava$lang$String(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$lang$String_join_java$lang$CharSequence_Ajava$lang$CharSequence__java$lang$String = svoker("join", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/CharSequence"), JArray(JObjectType("java/lang/CharSequence"))))
    public static func join(a0: java$lang$CharSequence?, _ a1: [java$lang$CharSequence?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_join_java$lang$CharSequence_Ajava$lang$CharSequence__java$lang$String(a0?.jobj ?? nil, a1?.map({ java$lang$CharSequence$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$String_join_java$lang$CharSequence_java$lang$Iterable__java$lang$String = svoker("join", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/CharSequence"), JObjectType("java/lang/Iterable")))
    public static func join(a0: java$lang$CharSequence?, _ a1: java$lang$Iterable?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_join_java$lang$CharSequence_java$lang$Iterable__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$String_toLowerCase_java$util$Locale__java$lang$String = invoker("toLowerCase", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func toLowerCase(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_toLowerCase_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$String_toLowerCase__java$lang$String = invoker("toLowerCase", returns: JObjectType("java/lang/String"))
    public func toLowerCase() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_toLowerCase__java$lang$String(jobj)())
    }

    private static let java$lang$String_toUpperCase_java$util$Locale__java$lang$String = invoker("toUpperCase", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func toUpperCase(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_toUpperCase_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$String_toUpperCase__java$lang$String = invoker("toUpperCase", returns: JObjectType("java/lang/String"))
    public func toUpperCase() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_toUpperCase__java$lang$String(jobj)())
    }

    private static let java$lang$String_trim__java$lang$String = invoker("trim", returns: JObjectType("java/lang/String"))
    public func trim() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_trim__java$lang$String(jobj)())
    }

    private static let java$lang$String_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$String_toCharArray__AC = invoker("toCharArray", returns: JArray(jchar.jniType))
    public func toCharArray() throws -> [jchar]? {
        return try java$lang$String$.java$lang$String_toCharArray__AC(jobj)().jarrayToArray()
    }

    private static let java$lang$String_format_java$lang$String_Ajava$lang$Object__java$lang$String = svoker("format", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public static func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_format_java$lang$String_Ajava$lang$Object__java$lang$String(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$String_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$lang$String = svoker("format", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public static func format(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$String_valueOf_java$lang$Object__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/Object")))
    public static func valueOf(a0: java$lang$Object?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_java$lang$Object__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$lang$String_valueOf_AC__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (JArray(jchar.jniType)))
    public static func valueOf(a0: [jchar]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_AC__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$lang$String_valueOf_AC_I_I__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func valueOf(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_AC_I_I__java$lang$String(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$lang$String_copyValueOf_AC_I_I__java$lang$String = svoker("copyValueOf", returns: JObjectType("java/lang/String"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func copyValueOf(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_copyValueOf_AC_I_I__java$lang$String(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$lang$String_copyValueOf_AC__java$lang$String = svoker("copyValueOf", returns: JObjectType("java/lang/String"), arguments: (JArray(jchar.jniType)))
    public static func copyValueOf(a0: [jchar]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_copyValueOf_AC__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$lang$String_valueOf_Z__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType))
    public static func valueOf(a0: jboolean) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_Z__java$lang$String(a0))
    }

    private static let java$lang$String_valueOf_C__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jchar.jniType))
    public static func valueOf(a0: jchar) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_C__java$lang$String(a0))
    }

    private static let java$lang$String_valueOf_I__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func valueOf(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_I__java$lang$String(a0))
    }

    private static let java$lang$String_valueOf_J__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public static func valueOf(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_J__java$lang$String(a0))
    }

    private static let java$lang$String_valueOf_F__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jfloat.jniType))
    public static func valueOf(a0: jfloat) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_F__java$lang$String(a0))
    }

    private static let java$lang$String_valueOf_D__java$lang$String = svoker("valueOf", returns: JObjectType("java/lang/String"), arguments: (jdouble.jniType))
    public static func valueOf(a0: jdouble) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_valueOf_D__java$lang$String(a0))
    }

    private static let java$lang$String_intern__java$lang$String = invoker("intern", returns: JObjectType("java/lang/String"))
    public func intern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$String$.java$lang$String_intern__java$lang$String(jobj)())
    }

    private static let java$lang$String_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$lang$String$.java$lang$String_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$String$ = java$lang$String

public final class java$lang$StringBuffer : java$lang$AbstractStringBuilder$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StringBuffer_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$StringBuffer$.java$lang$StringBuffer_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuffer_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$lang$StringBuffer$.java$lang$StringBuffer_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuffer_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$StringBuffer$.java$lang$StringBuffer_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuffer_init_java$lang$CharSequence__V = constructor((JObjectType("java/lang/CharSequence")))
    public convenience init!(_ a0: java$lang$CharSequence?) throws {
        let jobj = try java$lang$StringBuffer$.java$lang$StringBuffer_init_java$lang$CharSequence__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuffer_length__I = invoker("length", returns: jint.jniType)
    private static let java$lang$StringBuffer_capacity__I = invoker("capacity", returns: jint.jniType)
    private static let java$lang$StringBuffer_ensureCapacity_I__V = invoker("ensureCapacity", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuffer_trimToSize__V = invoker("trimToSize", returns: JVoid.jniType)
    private static let java$lang$StringBuffer_setLength_I__V = invoker("setLength", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuffer_charAt_I__C = invoker("charAt", returns: jchar.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuffer_codePointAt_I__I = invoker("codePointAt", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuffer_codePointBefore_I__I = invoker("codePointBefore", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuffer_codePointCount_I_I__I = invoker("codePointCount", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_offsetByCodePoints_I_I__I = invoker("offsetByCodePoints", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_getChars_I_I_AC_I__V = invoker("getChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JArray(jchar.jniType), jint.jniType))
    private static let java$lang$StringBuffer_setCharAt_I_C__V = invoker("setCharAt", returns: JVoid.jniType, arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuffer_append_java$lang$Object__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$StringBuffer_append_java$lang$String__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_append_java$lang$StringBuffer__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/StringBuffer")))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence_I_I__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_AC__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JArray(jchar.jniType)))
    private static let java$lang$StringBuffer_append_AC_I_I__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_Z__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jboolean.jniType))
    private static let java$lang$StringBuffer_append_C__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jchar.jniType))
    private static let java$lang$StringBuffer_append_I__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_appendCodePoint_I__java$lang$StringBuffer = invoker("appendCodePoint", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_append_J__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jlong.jniType))
    private static let java$lang$StringBuffer_append_F__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jfloat.jniType))
    private static let java$lang$StringBuffer_append_D__java$lang$StringBuffer = invoker("append", returns: JObjectType("java/lang/StringBuffer"), arguments: (jdouble.jniType))
    private static let java$lang$StringBuffer_delete_I_I__java$lang$StringBuffer = invoker("delete", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_deleteCharAt_I__java$lang$StringBuffer = invoker("deleteCharAt", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_replace_I_I_java$lang$String__java$lang$StringBuffer = invoker("replace", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_substring_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_subSequence_I_I__java$lang$CharSequence = invoker("subSequence", returns: JObjectType("java/lang/CharSequence"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_substring_I_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_AC_I_I__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_java$lang$Object__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$lang$StringBuffer_insert_I_java$lang$String__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_insert_I_AC__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JArray(jchar.jniType)))
    private static let java$lang$StringBuffer_insert_I_java$lang$CharSequence__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuffer_insert_I_java$lang$CharSequence_I_I__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_Z__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jboolean.jniType))
    private static let java$lang$StringBuffer_insert_I_C__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuffer_insert_I_I__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_J__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jlong.jniType))
    private static let java$lang$StringBuffer_insert_I_F__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jfloat.jniType))
    private static let java$lang$StringBuffer_insert_I_D__java$lang$StringBuffer = invoker("insert", returns: JObjectType("java/lang/StringBuffer"), arguments: (jint.jniType, jdouble.jniType))
    private static let java$lang$StringBuffer_indexOf_java$lang$String__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_indexOf_java$lang$String_I__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$lang$StringBuffer_lastIndexOf_java$lang$String__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_lastIndexOf_java$lang$String_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$lang$StringBuffer_reverse__java$lang$StringBuffer = invoker("reverse", returns: JObjectType("java/lang/StringBuffer"))
    private static let java$lang$StringBuffer_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$StringBuffer_reverse__java$lang$AbstractStringBuilder = invoker("reverse", returns: JObjectType("java/lang/AbstractStringBuilder"))
    private static let java$lang$StringBuffer_insert_I_D__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jdouble.jniType))
    private static let java$lang$StringBuffer_insert_I_F__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jfloat.jniType))
    private static let java$lang$StringBuffer_insert_I_J__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jlong.jniType))
    private static let java$lang$StringBuffer_insert_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_C__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuffer_insert_I_Z__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jboolean.jniType))
    private static let java$lang$StringBuffer_insert_I_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_insert_I_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuffer_insert_I_AC__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType)))
    private static let java$lang$StringBuffer_insert_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_insert_I_java$lang$Object__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$lang$StringBuffer_insert_I_AC_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_replace_I_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("replace", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_deleteCharAt_I__java$lang$AbstractStringBuilder = invoker("deleteCharAt", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_appendCodePoint_I__java$lang$AbstractStringBuilder = invoker("appendCodePoint", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_delete_I_I__java$lang$AbstractStringBuilder = invoker("delete", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_D__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jdouble.jniType))
    private static let java$lang$StringBuffer_append_F__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jfloat.jniType))
    private static let java$lang$StringBuffer_append_J__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jlong.jniType))
    private static let java$lang$StringBuffer_append_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuffer_append_C__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jchar.jniType))
    private static let java$lang$StringBuffer_append_Z__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jboolean.jniType))
    private static let java$lang$StringBuffer_append_AC_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_AC__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType)))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuffer_append_java$lang$StringBuffer__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/StringBuffer")))
    private static let java$lang$StringBuffer_append_java$lang$String__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuffer_append_java$lang$Object__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$StringBuffer_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuffer_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
}

public typealias java$lang$StringBuffer$ = java$lang$StringBuffer

public final class java$lang$StringBuilder : java$lang$AbstractStringBuilder$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StringBuilder_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$StringBuilder$.java$lang$StringBuilder_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuilder_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$lang$StringBuilder$.java$lang$StringBuilder_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuilder_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$StringBuilder$.java$lang$StringBuilder_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuilder_init_java$lang$CharSequence__V = constructor((JObjectType("java/lang/CharSequence")))
    public convenience init!(_ a0: java$lang$CharSequence?) throws {
        let jobj = try java$lang$StringBuilder$.java$lang$StringBuilder_init_java$lang$CharSequence__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringBuilder_append_java$lang$Object__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$StringBuilder_append_java$lang$String__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_append_java$lang$StringBuffer__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JObjectType("java/lang/StringBuffer")))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence_I_I__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_AC__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JArray(jchar.jniType)))
    private static let java$lang$StringBuilder_append_AC_I_I__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_Z__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jboolean.jniType))
    private static let java$lang$StringBuilder_append_C__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jchar.jniType))
    private static let java$lang$StringBuilder_append_I__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_append_J__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jlong.jniType))
    private static let java$lang$StringBuilder_append_F__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jfloat.jniType))
    private static let java$lang$StringBuilder_append_D__java$lang$StringBuilder = invoker("append", returns: JObjectType("java/lang/StringBuilder"), arguments: (jdouble.jniType))
    private static let java$lang$StringBuilder_appendCodePoint_I__java$lang$StringBuilder = invoker("appendCodePoint", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_delete_I_I__java$lang$StringBuilder = invoker("delete", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_deleteCharAt_I__java$lang$StringBuilder = invoker("deleteCharAt", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_replace_I_I_java$lang$String__java$lang$StringBuilder = invoker("replace", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_insert_I_AC_I_I__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_insert_I_java$lang$Object__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$lang$StringBuilder_insert_I_java$lang$String__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_insert_I_AC__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType)))
    private static let java$lang$StringBuilder_insert_I_java$lang$CharSequence__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuilder_insert_I_java$lang$CharSequence_I_I__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_insert_I_Z__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jboolean.jniType))
    private static let java$lang$StringBuilder_insert_I_C__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuilder_insert_I_I__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_insert_I_J__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jlong.jniType))
    private static let java$lang$StringBuilder_insert_I_F__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jfloat.jniType))
    private static let java$lang$StringBuilder_insert_I_D__java$lang$StringBuilder = invoker("insert", returns: JObjectType("java/lang/StringBuilder"), arguments: (jint.jniType, jdouble.jniType))
    private static let java$lang$StringBuilder_indexOf_java$lang$String__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_indexOf_java$lang$String_I__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$lang$StringBuilder_lastIndexOf_java$lang$String__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_lastIndexOf_java$lang$String_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$lang$StringBuilder_reverse__java$lang$StringBuilder = invoker("reverse", returns: JObjectType("java/lang/StringBuilder"))
    private static let java$lang$StringBuilder_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$StringBuilder_reverse__java$lang$AbstractStringBuilder = invoker("reverse", returns: JObjectType("java/lang/AbstractStringBuilder"))
    private static let java$lang$StringBuilder_insert_I_D__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jdouble.jniType))
    private static let java$lang$StringBuilder_insert_I_F__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jfloat.jniType))
    private static let java$lang$StringBuilder_insert_I_J__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jlong.jniType))
    private static let java$lang$StringBuilder_insert_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_insert_I_C__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuilder_insert_I_Z__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jboolean.jniType))
    private static let java$lang$StringBuilder_insert_I_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_insert_I_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuilder_insert_I_AC__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType)))
    private static let java$lang$StringBuilder_insert_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_insert_I_java$lang$Object__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$lang$StringBuilder_insert_I_AC_I_I__java$lang$AbstractStringBuilder = invoker("insert", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_substring_I_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_subSequence_I_I__java$lang$CharSequence = invoker("subSequence", returns: JObjectType("java/lang/CharSequence"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_substring_I__java$lang$String = invoker("substring", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_replace_I_I_java$lang$String__java$lang$AbstractStringBuilder = invoker("replace", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_deleteCharAt_I__java$lang$AbstractStringBuilder = invoker("deleteCharAt", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_appendCodePoint_I__java$lang$AbstractStringBuilder = invoker("appendCodePoint", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_delete_I_I__java$lang$AbstractStringBuilder = invoker("delete", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_D__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jdouble.jniType))
    private static let java$lang$StringBuilder_append_F__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jfloat.jniType))
    private static let java$lang$StringBuilder_append_J__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jlong.jniType))
    private static let java$lang$StringBuilder_append_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jint.jniType))
    private static let java$lang$StringBuilder_append_C__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jchar.jniType))
    private static let java$lang$StringBuilder_append_Z__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (jboolean.jniType))
    private static let java$lang$StringBuilder_append_AC_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_AC__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JArray(jchar.jniType)))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence_I_I__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/CharSequence")))
    private static let java$lang$StringBuilder_append_java$lang$StringBuffer__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/StringBuffer")))
    private static let java$lang$StringBuilder_append_java$lang$String__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/String")))
    private static let java$lang$StringBuilder_append_java$lang$Object__java$lang$AbstractStringBuilder = invoker("append", returns: JObjectType("java/lang/AbstractStringBuilder"), arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$StringBuilder_setCharAt_I_C__V = invoker("setCharAt", returns: JVoid.jniType, arguments: (jint.jniType, jchar.jniType))
    private static let java$lang$StringBuilder_getChars_I_I_AC_I__V = invoker("getChars", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JArray(jchar.jniType), jint.jniType))
    private static let java$lang$StringBuilder_offsetByCodePoints_I_I__I = invoker("offsetByCodePoints", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_codePointCount_I_I__I = invoker("codePointCount", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_codePointBefore_I__I = invoker("codePointBefore", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuilder_codePointAt_I__I = invoker("codePointAt", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuilder_charAt_I__C = invoker("charAt", returns: jchar.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuilder_setLength_I__V = invoker("setLength", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuilder_trimToSize__V = invoker("trimToSize", returns: JVoid.jniType)
    private static let java$lang$StringBuilder_ensureCapacity_I__V = invoker("ensureCapacity", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$lang$StringBuilder_capacity__I = invoker("capacity", returns: jint.jniType)
    private static let java$lang$StringBuilder_length__I = invoker("length", returns: jint.jniType)
    private static let java$lang$StringBuilder_append_C__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (jchar.jniType))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence_I_I__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence"), jint.jniType, jint.jniType))
    private static let java$lang$StringBuilder_append_java$lang$CharSequence__java$lang$Appendable = invoker("append", returns: JObjectType("java/lang/Appendable"), arguments: (JObjectType("java/lang/CharSequence")))
}

public typealias java$lang$StringBuilder$ = java$lang$StringBuilder

public class java$lang$StringCoding : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$StringCoding$ = java$lang$StringCoding

public class java$lang$StringIndexOutOfBoundsException : java$lang$IndexOutOfBoundsException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$StringIndexOutOfBoundsException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$StringIndexOutOfBoundsException$.java$lang$StringIndexOutOfBoundsException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$StringIndexOutOfBoundsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$StringIndexOutOfBoundsException$.java$lang$StringIndexOutOfBoundsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$StringIndexOutOfBoundsException_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$lang$StringIndexOutOfBoundsException$.java$lang$StringIndexOutOfBoundsException_init_I__V(a0)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$StringIndexOutOfBoundsException$ = java$lang$StringIndexOutOfBoundsException

public protocol java$lang$SuppressWarnings : java$lang$annotation$Annotation {
    func value() throws -> [java$lang$String?]?
}

public class java$lang$SuppressWarnings$ : java$lang$Object$, java$lang$SuppressWarnings, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$SuppressWarnings_value__Ajava$lang$String = invoker("value", returns: JArray(JObjectType("java/lang/String")))
}

public extension java$lang$SuppressWarnings {
    func value() throws -> [java$lang$String?]? {
        return try java$lang$SuppressWarnings$.java$lang$SuppressWarnings_value__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

}

public final class java$lang$System : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$System_setIn_java$io$InputStream__V = svoker("setIn", returns: JVoid.jniType, arguments: (JObjectType("java/io/InputStream")))
    public static func setIn(a0: java$io$InputStream?) throws -> Void {
        return try java$lang$System$.java$lang$System_setIn_java$io$InputStream__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_setOut_java$io$PrintStream__V = svoker("setOut", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintStream")))
    public static func setOut(a0: java$io$PrintStream?) throws -> Void {
        return try java$lang$System$.java$lang$System_setOut_java$io$PrintStream__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_setErr_java$io$PrintStream__V = svoker("setErr", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintStream")))
    public static func setErr(a0: java$io$PrintStream?) throws -> Void {
        return try java$lang$System$.java$lang$System_setErr_java$io$PrintStream__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_console__java$io$Console = svoker("console", returns: JObjectType("java/io/Console"))
    public static func console() throws -> java$io$Console? {
        return try java$io$Console$(jobj: java$lang$System$.java$lang$System_console__java$io$Console())
    }

    private static let java$lang$System_inheritedChannel__java$nio$channels$Channel = svoker("inheritedChannel", returns: JObjectType("java/nio/channels/Channel"))
    public static func inheritedChannel() throws -> java$nio$channels$Channel? {
        return try java$nio$channels$Channel$(jobj: java$lang$System$.java$lang$System_inheritedChannel__java$nio$channels$Channel())
    }

    private static let java$lang$System_setSecurityManager_java$lang$SecurityManager__V = svoker("setSecurityManager", returns: JVoid.jniType, arguments: (JObjectType("java/lang/SecurityManager")))
    public static func setSecurityManager(a0: java$lang$SecurityManager?) throws -> Void {
        return try java$lang$System$.java$lang$System_setSecurityManager_java$lang$SecurityManager__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_getSecurityManager__java$lang$SecurityManager = svoker("getSecurityManager", returns: JObjectType("java/lang/SecurityManager"))
    public static func getSecurityManager() throws -> java$lang$SecurityManager? {
        return try java$lang$SecurityManager$(jobj: java$lang$System$.java$lang$System_getSecurityManager__java$lang$SecurityManager())
    }

    private static let java$lang$System_currentTimeMillis__J = svoker("currentTimeMillis", returns: jlong.jniType)
    public static func currentTimeMillis() throws -> jlong {
        return try java$lang$System$.java$lang$System_currentTimeMillis__J()
    }

    private static let java$lang$System_nanoTime__J = svoker("nanoTime", returns: jlong.jniType)
    public static func nanoTime() throws -> jlong {
        return try java$lang$System$.java$lang$System_nanoTime__J()
    }

    private static let java$lang$System_arraycopy_java$lang$Object_I_java$lang$Object_I_I__V = svoker("arraycopy", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, JObjectType("java/lang/Object"), jint.jniType, jint.jniType))
    public static func arraycopy(a0: java$lang$Object?, _ a1: jint, _ a2: java$lang$Object?, _ a3: jint, _ a4: jint) throws -> Void {
        return try java$lang$System$.java$lang$System_arraycopy_java$lang$Object_I_java$lang$Object_I_I__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3, a4)
    }

    private static let java$lang$System_identityHashCode_java$lang$Object__I = svoker("identityHashCode", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func identityHashCode(a0: java$lang$Object?) throws -> jint {
        return try java$lang$System$.java$lang$System_identityHashCode_java$lang$Object__I(a0?.jobj ?? nil)
    }

    private static let java$lang$System_getProperties__java$util$Properties = svoker("getProperties", returns: JObjectType("java/util/Properties"))
    public static func getProperties() throws -> java$util$Properties? {
        return try java$util$Properties$(jobj: java$lang$System$.java$lang$System_getProperties__java$util$Properties())
    }

    private static let java$lang$System_lineSeparator__java$lang$String = svoker("lineSeparator", returns: JObjectType("java/lang/String"))
    public static func lineSeparator() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_lineSeparator__java$lang$String())
    }

    private static let java$lang$System_setProperties_java$util$Properties__V = svoker("setProperties", returns: JVoid.jniType, arguments: (JObjectType("java/util/Properties")))
    public static func setProperties(a0: java$util$Properties?) throws -> Void {
        return try java$lang$System$.java$lang$System_setProperties_java$util$Properties__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_getProperty_java$lang$String__java$lang$String = svoker("getProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func getProperty(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_getProperty_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$lang$System_getProperty_java$lang$String_java$lang$String__java$lang$String = svoker("getProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func getProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_getProperty_java$lang$String_java$lang$String__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$System_setProperty_java$lang$String_java$lang$String__java$lang$String = svoker("setProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func setProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_setProperty_java$lang$String_java$lang$String__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$System_clearProperty_java$lang$String__java$lang$String = svoker("clearProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func clearProperty(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_clearProperty_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$lang$System_getenv_java$lang$String__java$lang$String = svoker("getenv", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func getenv(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_getenv_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$lang$System_getenv__java$util$Map = svoker("getenv", returns: JObjectType("java/util/Map"))
    public static func getenv() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$lang$System$.java$lang$System_getenv__java$util$Map())
    }

    private static let java$lang$System_exit_I__V = svoker("exit", returns: JVoid.jniType, arguments: (jint.jniType))
    public static func exit(a0: jint) throws -> Void {
        return try java$lang$System$.java$lang$System_exit_I__V(a0)
    }

    private static let java$lang$System_gc__V = svoker("gc", returns: JVoid.jniType)
    public static func gc() throws -> Void {
        return try java$lang$System$.java$lang$System_gc__V()
    }

    private static let java$lang$System_runFinalization__V = svoker("runFinalization", returns: JVoid.jniType)
    public static func runFinalization() throws -> Void {
        return try java$lang$System$.java$lang$System_runFinalization__V()
    }

    private static let java$lang$System_runFinalizersOnExit_Z__V = svoker("runFinalizersOnExit", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public static func runFinalizersOnExit(a0: jboolean) throws -> Void {
        return try java$lang$System$.java$lang$System_runFinalizersOnExit_Z__V(a0)
    }

    private static let java$lang$System_load_java$lang$String__V = svoker("load", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public static func load(a0: java$lang$String?) throws -> Void {
        return try java$lang$System$.java$lang$System_load_java$lang$String__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_loadLibrary_java$lang$String__V = svoker("loadLibrary", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public static func loadLibrary(a0: java$lang$String?) throws -> Void {
        return try java$lang$System$.java$lang$System_loadLibrary_java$lang$String__V(a0?.jobj ?? nil)
    }

    private static let java$lang$System_mapLibraryName_java$lang$String__java$lang$String = svoker("mapLibraryName", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func mapLibraryName(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$System$.java$lang$System_mapLibraryName_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

}

public typealias java$lang$System$ = java$lang$System

public class java$lang$SystemClassLoaderAction : java$lang$Object$, java$security$PrivilegedExceptionAction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$SystemClassLoaderAction_run__java$lang$ClassLoader = invoker("run", returns: JObjectType("java/lang/ClassLoader"))
    public func run() throws -> java$lang$ClassLoader? {
        return try java$lang$ClassLoader$(jobj: java$lang$SystemClassLoaderAction$.java$lang$SystemClassLoaderAction_run__java$lang$ClassLoader(jobj)())
    }

    private static let java$lang$SystemClassLoaderAction_run__java$lang$Object = invoker("run", returns: JObjectType("java/lang/Object"))
    public func run() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$SystemClassLoaderAction$.java$lang$SystemClassLoaderAction_run__java$lang$Object(jobj)())
    }

}

public typealias java$lang$SystemClassLoaderAction$ = java$lang$SystemClassLoaderAction

public class java$lang$Terminator : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$Terminator$ = java$lang$Terminator

public class java$lang$Thread : java$lang$Object$, java$lang$Runnable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Thread_currentThread__java$lang$Thread = svoker("currentThread", returns: JObjectType("java/lang/Thread"))
    public static func currentThread() throws -> java$lang$Thread? {
        return try java$lang$Thread$(jobj: java$lang$Thread$.java$lang$Thread_currentThread__java$lang$Thread())
    }

    private static let java$lang$Thread_yield__V = svoker("yield", returns: JVoid.jniType)
    public static func yield() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_yield__V()
    }

    private static let java$lang$Thread_sleep_J__V = svoker("sleep", returns: JVoid.jniType, arguments: (jlong.jniType))
    public static func sleep(a0: jlong) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_sleep_J__V(a0)
    }

    private static let java$lang$Thread_sleep_J_I__V = svoker("sleep", returns: JVoid.jniType, arguments: (jlong.jniType, jint.jniType))
    public static func sleep(a0: jlong, _ a1: jint) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_sleep_J_I__V(a0, a1)
    }

    private static let java$lang$Thread_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$Runnable__V = constructor((JObjectType("java/lang/Runnable")))
    public convenience init!(_ a0: java$lang$Runnable?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$Runnable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable__V = constructor((JObjectType("java/lang/ThreadGroup"), JObjectType("java/lang/Runnable")))
    public convenience init!(_ a0: java$lang$ThreadGroup?, _ a1: java$lang$Runnable?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$ThreadGroup_java$lang$String__V = constructor((JObjectType("java/lang/ThreadGroup"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$ThreadGroup?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$ThreadGroup_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$Runnable_java$lang$String__V = constructor((JObjectType("java/lang/Runnable"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$Runnable?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$Runnable_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable_java$lang$String__V = constructor((JObjectType("java/lang/ThreadGroup"), JObjectType("java/lang/Runnable"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$ThreadGroup?, _ a1: java$lang$Runnable?, _ a2: java$lang$String?) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable_java$lang$String_J__V = constructor((JObjectType("java/lang/ThreadGroup"), JObjectType("java/lang/Runnable"), JObjectType("java/lang/String"), jlong.jniType))
    public convenience init!(_ a0: java$lang$ThreadGroup?, _ a1: java$lang$Runnable?, _ a2: java$lang$String?, _ a3: jlong) throws {
        let jobj = try java$lang$Thread$.java$lang$Thread_init_java$lang$ThreadGroup_java$lang$Runnable_java$lang$String_J__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
        self.init(jobj: jobj)
    }

    private static let java$lang$Thread_start__V = invoker("start", returns: JVoid.jniType)
    public func start() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_start__V(jobj)()
    }

    private static let java$lang$Thread_run__V = invoker("run", returns: JVoid.jniType)
    public func run() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_run__V(jobj)()
    }

    private static let java$lang$Thread_stop__V = invoker("stop", returns: JVoid.jniType)
    public func stop() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_stop__V(jobj)()
    }

    private static let java$lang$Thread_stop_java$lang$Throwable__V = invoker("stop", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Throwable")))
    public func stop(a0: java$lang$Throwable?) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_stop_java$lang$Throwable__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Thread_interrupt__V = invoker("interrupt", returns: JVoid.jniType)
    public func interrupt() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_interrupt__V(jobj)()
    }

    private static let java$lang$Thread_interrupted__Z = svoker("interrupted", returns: jboolean.jniType)
    public static func interrupted() throws -> jboolean {
        return try java$lang$Thread$.java$lang$Thread_interrupted__Z()
    }

    private static let java$lang$Thread_isInterrupted__Z = invoker("isInterrupted", returns: jboolean.jniType)
    public func isInterrupted() throws -> jboolean {
        return try java$lang$Thread$.java$lang$Thread_isInterrupted__Z(jobj)()
    }

    private static let java$lang$Thread_destroy__V = invoker("destroy", returns: JVoid.jniType)
    public func destroy() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_destroy__V(jobj)()
    }

    private static let java$lang$Thread_isAlive__Z = invoker("isAlive", returns: jboolean.jniType)
    public func isAlive() throws -> jboolean {
        return try java$lang$Thread$.java$lang$Thread_isAlive__Z(jobj)()
    }

    private static let java$lang$Thread_suspend__V = invoker("suspend", returns: JVoid.jniType)
    public func suspend() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_suspend__V(jobj)()
    }

    private static let java$lang$Thread_resume__V = invoker("resume", returns: JVoid.jniType)
    public func resume() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_resume__V(jobj)()
    }

    private static let java$lang$Thread_setPriority_I__V = invoker("setPriority", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setPriority(a0: jint) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setPriority_I__V(jobj)(a0)
    }

    private static let java$lang$Thread_getPriority__I = invoker("getPriority", returns: jint.jniType)
    public func getPriority() throws -> jint {
        return try java$lang$Thread$.java$lang$Thread_getPriority__I(jobj)()
    }

    private static let java$lang$Thread_setName_java$lang$String__V = invoker("setName", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setName(a0: java$lang$String?) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setName_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Thread_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Thread$.java$lang$Thread_getName__java$lang$String(jobj)())
    }

    private static let java$lang$Thread_getThreadGroup__java$lang$ThreadGroup = invoker("getThreadGroup", returns: JObjectType("java/lang/ThreadGroup"))
    public func getThreadGroup() throws -> java$lang$ThreadGroup? {
        return try java$lang$ThreadGroup$(jobj: java$lang$Thread$.java$lang$Thread_getThreadGroup__java$lang$ThreadGroup(jobj)())
    }

    private static let java$lang$Thread_activeCount__I = svoker("activeCount", returns: jint.jniType)
    public static func activeCount() throws -> jint {
        return try java$lang$Thread$.java$lang$Thread_activeCount__I()
    }

    private static let java$lang$Thread_enumerate_Ajava$lang$Thread__I = svoker("enumerate", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Thread"))))
    public static func enumerate(a0: [java$lang$Thread?]?) throws -> jint {
        return try java$lang$Thread$.java$lang$Thread_enumerate_Ajava$lang$Thread__I(a0?.map({ java$lang$Thread$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$lang$Thread_countStackFrames__I = invoker("countStackFrames", returns: jint.jniType)
    public func countStackFrames() throws -> jint {
        return try java$lang$Thread$.java$lang$Thread_countStackFrames__I(jobj)()
    }

    private static let java$lang$Thread_join_J__V = invoker("join", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func join(a0: jlong) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_join_J__V(jobj)(a0)
    }

    private static let java$lang$Thread_join_J_I__V = invoker("join", returns: JVoid.jniType, arguments: (jlong.jniType, jint.jniType))
    public func join(a0: jlong, _ a1: jint) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_join_J_I__V(jobj)(a0, a1)
    }

    private static let java$lang$Thread_join__V = invoker("join", returns: JVoid.jniType)
    public func join() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_join__V(jobj)()
    }

    private static let java$lang$Thread_dumpStack__V = svoker("dumpStack", returns: JVoid.jniType)
    public static func dumpStack() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_dumpStack__V()
    }

    private static let java$lang$Thread_setDaemon_Z__V = invoker("setDaemon", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDaemon(a0: jboolean) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setDaemon_Z__V(jobj)(a0)
    }

    private static let java$lang$Thread_isDaemon__Z = invoker("isDaemon", returns: jboolean.jniType)
    public func isDaemon() throws -> jboolean {
        return try java$lang$Thread$.java$lang$Thread_isDaemon__Z(jobj)()
    }

    private static let java$lang$Thread_checkAccess__V = invoker("checkAccess", returns: JVoid.jniType)
    public func checkAccess() throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_checkAccess__V(jobj)()
    }

    private static let java$lang$Thread_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Thread_getContextClassLoader__java$lang$ClassLoader = invoker("getContextClassLoader", returns: JObjectType("java/lang/ClassLoader"))
    public func getContextClassLoader() throws -> java$lang$ClassLoader? {
        return try java$lang$ClassLoader$(jobj: java$lang$Thread$.java$lang$Thread_getContextClassLoader__java$lang$ClassLoader(jobj)())
    }

    private static let java$lang$Thread_setContextClassLoader_java$lang$ClassLoader__V = invoker("setContextClassLoader", returns: JVoid.jniType, arguments: (JObjectType("java/lang/ClassLoader")))
    public func setContextClassLoader(a0: java$lang$ClassLoader?) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setContextClassLoader_java$lang$ClassLoader__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Thread_holdsLock_java$lang$Object__Z = svoker("holdsLock", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func holdsLock(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$Thread$.java$lang$Thread_holdsLock_java$lang$Object__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$Thread_getStackTrace__Ajava$lang$StackTraceElement = invoker("getStackTrace", returns: JArray(JObjectType("java/lang/StackTraceElement")))
    public func getStackTrace() throws -> [java$lang$StackTraceElement?]? {
        return try java$lang$Thread$.java$lang$Thread_getStackTrace__Ajava$lang$StackTraceElement(jobj)().jarrayToArray(java$lang$StackTraceElement$.self)?.map({ $0 as java$lang$StackTraceElement? })
    }

    private static let java$lang$Thread_getAllStackTraces__java$util$Map = svoker("getAllStackTraces", returns: JObjectType("java/util/Map"))
    public static func getAllStackTraces() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$lang$Thread$.java$lang$Thread_getAllStackTraces__java$util$Map())
    }

    private static let java$lang$Thread_getId__J = invoker("getId", returns: jlong.jniType)
    public func getId() throws -> jlong {
        return try java$lang$Thread$.java$lang$Thread_getId__J(jobj)()
    }

    private static let java$lang$Thread_getState__java$lang$Thread$State = invoker("getState", returns: JObjectType("java/lang/Thread$State"))
    public func getState() throws -> java$lang$Thread$State? {
        return try java$lang$Thread$State$(jobj: java$lang$Thread$.java$lang$Thread_getState__java$lang$Thread$State(jobj)())
    }

    private static let java$lang$Thread_setDefaultUncaughtExceptionHandler_java$lang$Thread$UncaughtExceptionHandler__V = svoker("setDefaultUncaughtExceptionHandler", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Thread$UncaughtExceptionHandler")))
    public static func setDefaultUncaughtExceptionHandler(a0: java$lang$Thread$UncaughtExceptionHandler?) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setDefaultUncaughtExceptionHandler_java$lang$Thread$UncaughtExceptionHandler__V(a0?.jobj ?? nil)
    }

    private static let java$lang$Thread_getDefaultUncaughtExceptionHandler__java$lang$Thread$UncaughtExceptionHandler = svoker("getDefaultUncaughtExceptionHandler", returns: JObjectType("java/lang/Thread$UncaughtExceptionHandler"))
    public static func getDefaultUncaughtExceptionHandler() throws -> java$lang$Thread$UncaughtExceptionHandler? {
        return try java$lang$Thread$UncaughtExceptionHandler$(jobj: java$lang$Thread$.java$lang$Thread_getDefaultUncaughtExceptionHandler__java$lang$Thread$UncaughtExceptionHandler())
    }

    private static let java$lang$Thread_getUncaughtExceptionHandler__java$lang$Thread$UncaughtExceptionHandler = invoker("getUncaughtExceptionHandler", returns: JObjectType("java/lang/Thread$UncaughtExceptionHandler"))
    public func getUncaughtExceptionHandler() throws -> java$lang$Thread$UncaughtExceptionHandler? {
        return try java$lang$Thread$UncaughtExceptionHandler$(jobj: java$lang$Thread$.java$lang$Thread_getUncaughtExceptionHandler__java$lang$Thread$UncaughtExceptionHandler(jobj)())
    }

    private static let java$lang$Thread_setUncaughtExceptionHandler_java$lang$Thread$UncaughtExceptionHandler__V = invoker("setUncaughtExceptionHandler", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Thread$UncaughtExceptionHandler")))
    public func setUncaughtExceptionHandler(a0: java$lang$Thread$UncaughtExceptionHandler?) throws -> Void {
        return try java$lang$Thread$.java$lang$Thread_setUncaughtExceptionHandler_java$lang$Thread$UncaughtExceptionHandler__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$lang$Thread$ = java$lang$Thread

public class java$lang$ThreadDeath : java$lang$Error$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ThreadDeath_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ThreadDeath$.java$lang$ThreadDeath_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$lang$ThreadDeath$ = java$lang$ThreadDeath

public class java$lang$ThreadGroup : java$lang$Object$, java$lang$Thread$UncaughtExceptionHandler {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ThreadGroup_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$ThreadGroup$.java$lang$ThreadGroup_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ThreadGroup_init_java$lang$ThreadGroup_java$lang$String__V = constructor((JObjectType("java/lang/ThreadGroup"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$ThreadGroup?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$ThreadGroup$.java$lang$ThreadGroup_init_java$lang$ThreadGroup_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$ThreadGroup_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$ThreadGroup$.java$lang$ThreadGroup_getName__java$lang$String(jobj)())
    }

    private static let java$lang$ThreadGroup_getParent__java$lang$ThreadGroup = invoker("getParent", returns: JObjectType("java/lang/ThreadGroup"))
    public func getParent() throws -> java$lang$ThreadGroup? {
        return try java$lang$ThreadGroup$(jobj: java$lang$ThreadGroup$.java$lang$ThreadGroup_getParent__java$lang$ThreadGroup(jobj)())
    }

    private static let java$lang$ThreadGroup_getMaxPriority__I = invoker("getMaxPriority", returns: jint.jniType)
    public func getMaxPriority() throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_getMaxPriority__I(jobj)()
    }

    private static let java$lang$ThreadGroup_isDaemon__Z = invoker("isDaemon", returns: jboolean.jniType)
    public func isDaemon() throws -> jboolean {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_isDaemon__Z(jobj)()
    }

    private static let java$lang$ThreadGroup_isDestroyed__Z = invoker("isDestroyed", returns: jboolean.jniType)
    public func isDestroyed() throws -> jboolean {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_isDestroyed__Z(jobj)()
    }

    private static let java$lang$ThreadGroup_setDaemon_Z__V = invoker("setDaemon", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDaemon(a0: jboolean) throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_setDaemon_Z__V(jobj)(a0)
    }

    private static let java$lang$ThreadGroup_setMaxPriority_I__V = invoker("setMaxPriority", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMaxPriority(a0: jint) throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_setMaxPriority_I__V(jobj)(a0)
    }

    private static let java$lang$ThreadGroup_parentOf_java$lang$ThreadGroup__Z = invoker("parentOf", returns: jboolean.jniType, arguments: (JObjectType("java/lang/ThreadGroup")))
    public func parentOf(a0: java$lang$ThreadGroup?) throws -> jboolean {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_parentOf_java$lang$ThreadGroup__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$ThreadGroup_checkAccess__V = invoker("checkAccess", returns: JVoid.jniType)
    public func checkAccess() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_checkAccess__V(jobj)()
    }

    private static let java$lang$ThreadGroup_activeCount__I = invoker("activeCount", returns: jint.jniType)
    public func activeCount() throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_activeCount__I(jobj)()
    }

    private static let java$lang$ThreadGroup_enumerate_Ajava$lang$Thread__I = invoker("enumerate", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Thread"))))
    public func enumerate(a0: [java$lang$Thread?]?) throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_enumerate_Ajava$lang$Thread__I(jobj)(a0?.map({ java$lang$Thread$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$lang$ThreadGroup_enumerate_Ajava$lang$Thread_Z__I = invoker("enumerate", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Thread")), jboolean.jniType))
    public func enumerate(a0: [java$lang$Thread?]?, _ a1: jboolean) throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_enumerate_Ajava$lang$Thread_Z__I(jobj)(a0?.map({ java$lang$Thread$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1)
    }

    private static let java$lang$ThreadGroup_activeGroupCount__I = invoker("activeGroupCount", returns: jint.jniType)
    public func activeGroupCount() throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_activeGroupCount__I(jobj)()
    }

    private static let java$lang$ThreadGroup_enumerate_Ajava$lang$ThreadGroup__I = invoker("enumerate", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/ThreadGroup"))))
    public func enumerate(a0: [java$lang$ThreadGroup?]?) throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_enumerate_Ajava$lang$ThreadGroup__I(jobj)(a0?.map({ java$lang$ThreadGroup$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$lang$ThreadGroup_enumerate_Ajava$lang$ThreadGroup_Z__I = invoker("enumerate", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/ThreadGroup")), jboolean.jniType))
    public func enumerate(a0: [java$lang$ThreadGroup?]?, _ a1: jboolean) throws -> jint {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_enumerate_Ajava$lang$ThreadGroup_Z__I(jobj)(a0?.map({ java$lang$ThreadGroup$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1)
    }

    private static let java$lang$ThreadGroup_stop__V = invoker("stop", returns: JVoid.jniType)
    public func stop() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_stop__V(jobj)()
    }

    private static let java$lang$ThreadGroup_interrupt__V = invoker("interrupt", returns: JVoid.jniType)
    public func interrupt() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_interrupt__V(jobj)()
    }

    private static let java$lang$ThreadGroup_suspend__V = invoker("suspend", returns: JVoid.jniType)
    public func suspend() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_suspend__V(jobj)()
    }

    private static let java$lang$ThreadGroup_resume__V = invoker("resume", returns: JVoid.jniType)
    public func resume() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_resume__V(jobj)()
    }

    private static let java$lang$ThreadGroup_destroy__V = invoker("destroy", returns: JVoid.jniType)
    public func destroy() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_destroy__V(jobj)()
    }

    private static let java$lang$ThreadGroup_list__V = invoker("list", returns: JVoid.jniType)
    public func list() throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_list__V(jobj)()
    }

    private static let java$lang$ThreadGroup_uncaughtException_java$lang$Thread_java$lang$Throwable__V = invoker("uncaughtException", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Thread"), JObjectType("java/lang/Throwable")))
    public func uncaughtException(a0: java$lang$Thread?, _ a1: java$lang$Throwable?) throws -> Void {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_uncaughtException_java$lang$Thread_java$lang$Throwable__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$ThreadGroup_allowThreadSuspension_Z__Z = invoker("allowThreadSuspension", returns: jboolean.jniType, arguments: (jboolean.jniType))
    public func allowThreadSuspension(a0: jboolean) throws -> jboolean {
        return try java$lang$ThreadGroup$.java$lang$ThreadGroup_allowThreadSuspension_Z__Z(jobj)(a0)
    }

    private static let java$lang$ThreadGroup_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$lang$ThreadGroup$ = java$lang$ThreadGroup

public class java$lang$ThreadLocal : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$ThreadLocal_withInitial_java$util$function$Supplier__java$lang$ThreadLocal = svoker("withInitial", returns: JObjectType("java/lang/ThreadLocal"), arguments: (JObjectType("java/util/function/Supplier")))
    public static func withInitial(a0: java$util$function$Supplier?) throws -> java$lang$ThreadLocal? {
        return try java$lang$ThreadLocal$(jobj: java$lang$ThreadLocal$.java$lang$ThreadLocal_withInitial_java$util$function$Supplier__java$lang$ThreadLocal(a0?.jobj ?? nil))
    }

    private static let java$lang$ThreadLocal_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$ThreadLocal$.java$lang$ThreadLocal_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$ThreadLocal_get__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"))
    public func get() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$ThreadLocal$.java$lang$ThreadLocal_get__java$lang$Object(jobj)())
    }

    private static let java$lang$ThreadLocal_set_java$lang$Object__V = invoker("set", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func set(a0: java$lang$Object?) throws -> Void {
        return try java$lang$ThreadLocal$.java$lang$ThreadLocal_set_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$ThreadLocal_remove__V = invoker("remove", returns: JVoid.jniType)
    public func remove() throws -> Void {
        return try java$lang$ThreadLocal$.java$lang$ThreadLocal_remove__V(jobj)()
    }

}

public typealias java$lang$ThreadLocal$ = java$lang$ThreadLocal

public class java$lang$Throwable : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$Throwable_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$Throwable$.java$lang$Throwable_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$Throwable_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$Throwable$.java$lang$Throwable_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Throwable_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$Throwable$.java$lang$Throwable_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Throwable_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$Throwable$.java$lang$Throwable_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$Throwable_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
    public func getMessage() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Throwable$.java$lang$Throwable_getMessage__java$lang$String(jobj)())
    }

    private static let java$lang$Throwable_getLocalizedMessage__java$lang$String = invoker("getLocalizedMessage", returns: JObjectType("java/lang/String"))
    public func getLocalizedMessage() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$Throwable$.java$lang$Throwable_getLocalizedMessage__java$lang$String(jobj)())
    }

    private static let java$lang$Throwable_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
    public func getCause() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$Throwable$.java$lang$Throwable_getCause__java$lang$Throwable(jobj)())
    }

    private static let java$lang$Throwable_initCause_java$lang$Throwable__java$lang$Throwable = invoker("initCause", returns: JObjectType("java/lang/Throwable"), arguments: (JObjectType("java/lang/Throwable")))
    public func initCause(a0: java$lang$Throwable?) throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$Throwable$.java$lang$Throwable_initCause_java$lang$Throwable__java$lang$Throwable(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$Throwable_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$Throwable_printStackTrace__V = invoker("printStackTrace", returns: JVoid.jniType)
    public func printStackTrace() throws -> Void {
        return try java$lang$Throwable$.java$lang$Throwable_printStackTrace__V(jobj)()
    }

    private static let java$lang$Throwable_printStackTrace_java$io$PrintStream__V = invoker("printStackTrace", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintStream")))
    public func printStackTrace(a0: java$io$PrintStream?) throws -> Void {
        return try java$lang$Throwable$.java$lang$Throwable_printStackTrace_java$io$PrintStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Throwable_printStackTrace_java$io$PrintWriter__V = invoker("printStackTrace", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintWriter")))
    public func printStackTrace(a0: java$io$PrintWriter?) throws -> Void {
        return try java$lang$Throwable$.java$lang$Throwable_printStackTrace_java$io$PrintWriter__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Throwable_fillInStackTrace__java$lang$Throwable = invoker("fillInStackTrace", returns: JObjectType("java/lang/Throwable"))
    public func fillInStackTrace() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$Throwable$.java$lang$Throwable_fillInStackTrace__java$lang$Throwable(jobj)())
    }

    private static let java$lang$Throwable_getStackTrace__Ajava$lang$StackTraceElement = invoker("getStackTrace", returns: JArray(JObjectType("java/lang/StackTraceElement")))
    public func getStackTrace() throws -> [java$lang$StackTraceElement?]? {
        return try java$lang$Throwable$.java$lang$Throwable_getStackTrace__Ajava$lang$StackTraceElement(jobj)().jarrayToArray(java$lang$StackTraceElement$.self)?.map({ $0 as java$lang$StackTraceElement? })
    }

    private static let java$lang$Throwable_setStackTrace_Ajava$lang$StackTraceElement__V = invoker("setStackTrace", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/StackTraceElement"))))
    public func setStackTrace(a0: [java$lang$StackTraceElement?]?) throws -> Void {
        return try java$lang$Throwable$.java$lang$Throwable_setStackTrace_Ajava$lang$StackTraceElement__V(jobj)(a0?.map({ java$lang$StackTraceElement$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$lang$Throwable_addSuppressed_java$lang$Throwable__V = invoker("addSuppressed", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Throwable")))
    public func addSuppressed(a0: java$lang$Throwable?) throws -> Void {
        return try java$lang$Throwable$.java$lang$Throwable_addSuppressed_java$lang$Throwable__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$Throwable_getSuppressed__Ajava$lang$Throwable = invoker("getSuppressed", returns: JArray(JObjectType("java/lang/Throwable")))
    public func getSuppressed() throws -> [java$lang$Throwable?]? {
        return try java$lang$Throwable$.java$lang$Throwable_getSuppressed__Ajava$lang$Throwable(jobj)().jarrayToArray(java$lang$Throwable$.self)?.map({ $0 as java$lang$Throwable? })
    }

}

public typealias java$lang$Throwable$ = java$lang$Throwable

public class java$lang$TypeNotPresentException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$TypeNotPresentException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$TypeNotPresentException$.java$lang$TypeNotPresentException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$TypeNotPresentException_typeName__java$lang$String = invoker("typeName", returns: JObjectType("java/lang/String"))
    public func typeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$TypeNotPresentException$.java$lang$TypeNotPresentException_typeName__java$lang$String(jobj)())
    }

}

public typealias java$lang$TypeNotPresentException$ = java$lang$TypeNotPresentException

public final class java$lang$UNIXProcess : java$lang$Process$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$UNIXProcess_getOutputStream__java$io$OutputStream = invoker("getOutputStream", returns: JObjectType("java/io/OutputStream"))
    private static let java$lang$UNIXProcess_getInputStream__java$io$InputStream = invoker("getInputStream", returns: JObjectType("java/io/InputStream"))
    private static let java$lang$UNIXProcess_getErrorStream__java$io$InputStream = invoker("getErrorStream", returns: JObjectType("java/io/InputStream"))
    private static let java$lang$UNIXProcess_waitFor__I = invoker("waitFor", returns: jint.jniType)
    private static let java$lang$UNIXProcess_waitFor_J_java$util$concurrent$TimeUnit__Z = invoker("waitFor", returns: jboolean.jniType, arguments: (jlong.jniType, JObjectType("java/util/concurrent/TimeUnit")))
    private static let java$lang$UNIXProcess_exitValue__I = invoker("exitValue", returns: jint.jniType)
    private static let java$lang$UNIXProcess_destroy__V = invoker("destroy", returns: JVoid.jniType)
    private static let java$lang$UNIXProcess_destroyForcibly__java$lang$Process = invoker("destroyForcibly", returns: JObjectType("java/lang/Process"))
    private static let java$lang$UNIXProcess_isAlive__Z = invoker("isAlive", returns: jboolean.jniType)
}

public typealias java$lang$UNIXProcess$ = java$lang$UNIXProcess

public class java$lang$UnknownError : java$lang$VirtualMachineError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$UnknownError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$UnknownError$.java$lang$UnknownError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$UnknownError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$UnknownError$.java$lang$UnknownError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$UnknownError$ = java$lang$UnknownError

public class java$lang$UnsatisfiedLinkError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$UnsatisfiedLinkError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$UnsatisfiedLinkError$.java$lang$UnsatisfiedLinkError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$UnsatisfiedLinkError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$UnsatisfiedLinkError$.java$lang$UnsatisfiedLinkError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$UnsatisfiedLinkError$ = java$lang$UnsatisfiedLinkError

public class java$lang$UnsupportedClassVersionError : java$lang$ClassFormatError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$UnsupportedClassVersionError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$UnsupportedClassVersionError$.java$lang$UnsupportedClassVersionError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$UnsupportedClassVersionError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$UnsupportedClassVersionError$.java$lang$UnsupportedClassVersionError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$UnsupportedClassVersionError$ = java$lang$UnsupportedClassVersionError

public class java$lang$UnsupportedOperationException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$UnsupportedOperationException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$UnsupportedOperationException$.java$lang$UnsupportedOperationException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$UnsupportedOperationException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$UnsupportedOperationException$.java$lang$UnsupportedOperationException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$UnsupportedOperationException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$UnsupportedOperationException$.java$lang$UnsupportedOperationException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$UnsupportedOperationException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$UnsupportedOperationException$.java$lang$UnsupportedOperationException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$UnsupportedOperationException$ = java$lang$UnsupportedOperationException

public class java$lang$VerifyError : java$lang$LinkageError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$VerifyError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$VerifyError$.java$lang$VerifyError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$VerifyError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$VerifyError$.java$lang$VerifyError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$VerifyError$ = java$lang$VerifyError

public class java$lang$VirtualMachineError : java$lang$Error$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$VirtualMachineError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$VirtualMachineError$.java$lang$VirtualMachineError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$VirtualMachineError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$VirtualMachineError$.java$lang$VirtualMachineError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$VirtualMachineError_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$lang$VirtualMachineError$.java$lang$VirtualMachineError_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$VirtualMachineError_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$VirtualMachineError$.java$lang$VirtualMachineError_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$VirtualMachineError$ = java$lang$VirtualMachineError

public final class java$lang$Void : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$lang$Void$ = java$lang$Void

public class java$lang$reflect$AccessibleObject : java$lang$Object$, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AccessibleObject_setAccessible_Ajava$lang$reflect$AccessibleObject_Z__V = svoker("setAccessible", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/reflect/AccessibleObject")), jboolean.jniType))
    public static func setAccessible(a0: [java$lang$reflect$AccessibleObject?]?, _ a1: jboolean) throws -> Void {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_setAccessible_Ajava$lang$reflect$AccessibleObject_Z__V(a0?.map({ java$lang$reflect$AccessibleObject$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1)
    }

    private static let java$lang$reflect$AccessibleObject_setAccessible_Z__V = invoker("setAccessible", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setAccessible(a0: jboolean) throws -> Void {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_setAccessible_Z__V(jobj)(a0)
    }

    private static let java$lang$reflect$AccessibleObject_isAccessible__Z = invoker("isAccessible", returns: jboolean.jniType)
    public func isAccessible() throws -> jboolean {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_isAccessible__Z(jobj)()
    }

    private static let java$lang$reflect$AccessibleObject_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$AccessibleObject_isAnnotationPresent_java$lang$Class__Z = invoker("isAnnotationPresent", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public func isAnnotationPresent(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_isAnnotationPresent_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$AccessibleObject_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$AccessibleObject_getAnnotations__Ajava$lang$annotation$Annotation = invoker("getAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$AccessibleObject_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getDeclaredAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$AccessibleObject_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$AccessibleObject_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AccessibleObject$.java$lang$reflect$AccessibleObject_getDeclaredAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

}

public typealias java$lang$reflect$AccessibleObject$ = java$lang$reflect$AccessibleObject

public protocol java$lang$reflect$AnnotatedArrayType : java$lang$reflect$AnnotatedType {
    func getAnnotatedGenericComponentType() throws -> java$lang$reflect$AnnotatedType?
}

public class java$lang$reflect$AnnotatedArrayType$ : java$lang$Object$, java$lang$reflect$AnnotatedArrayType, java$lang$reflect$AnnotatedType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedArrayType_getAnnotatedGenericComponentType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedGenericComponentType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
}

public extension java$lang$reflect$AnnotatedArrayType {
    func getAnnotatedGenericComponentType() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$reflect$AnnotatedArrayType$.java$lang$reflect$AnnotatedArrayType_getAnnotatedGenericComponentType__java$lang$reflect$AnnotatedType(jobj)())
    }

}

public protocol java$lang$reflect$AnnotatedElement : JavaObject {
    func isAnnotationPresent(a0: java$lang$Class?) throws -> jboolean
    func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation?
    func getAnnotations() throws -> [java$lang$annotation$Annotation?]?
    func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]?
    func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation?
    func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]?
    func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]?
}

public class java$lang$reflect$AnnotatedElement$ : java$lang$Object$, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedElement_isAnnotationPresent_java$lang$Class__Z = invoker("isAnnotationPresent", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$AnnotatedElement_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$AnnotatedElement_getAnnotations__Ajava$lang$annotation$Annotation = invoker("getAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    private static let java$lang$reflect$AnnotatedElement_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$AnnotatedElement_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getDeclaredAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$AnnotatedElement_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$AnnotatedElement_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
}

public extension java$lang$reflect$AnnotatedElement {
    func isAnnotationPresent(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_isAnnotationPresent_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

    func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    func getAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$AnnotatedElement$.java$lang$reflect$AnnotatedElement_getDeclaredAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

}

public protocol java$lang$reflect$AnnotatedParameterizedType : java$lang$reflect$AnnotatedType {
    func getAnnotatedActualTypeArguments() throws -> [java$lang$reflect$AnnotatedType?]?
}

public class java$lang$reflect$AnnotatedParameterizedType$ : java$lang$Object$, java$lang$reflect$AnnotatedParameterizedType, java$lang$reflect$AnnotatedType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedParameterizedType_getAnnotatedActualTypeArguments__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedActualTypeArguments", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
}

public extension java$lang$reflect$AnnotatedParameterizedType {
    func getAnnotatedActualTypeArguments() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$AnnotatedParameterizedType$.java$lang$reflect$AnnotatedParameterizedType_getAnnotatedActualTypeArguments__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public protocol java$lang$reflect$AnnotatedType : java$lang$reflect$AnnotatedElement {
    func getType() throws -> java$lang$reflect$Type?
}

public class java$lang$reflect$AnnotatedType$ : java$lang$Object$, java$lang$reflect$AnnotatedType, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedType_getType__java$lang$reflect$Type = invoker("getType", returns: JObjectType("java/lang/reflect/Type"))
}

public extension java$lang$reflect$AnnotatedType {
    func getType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$AnnotatedType$.java$lang$reflect$AnnotatedType_getType__java$lang$reflect$Type(jobj)())
    }

}

public protocol java$lang$reflect$AnnotatedTypeVariable : java$lang$reflect$AnnotatedType {
    func getAnnotatedBounds() throws -> [java$lang$reflect$AnnotatedType?]?
}

public class java$lang$reflect$AnnotatedTypeVariable$ : java$lang$Object$, java$lang$reflect$AnnotatedTypeVariable, java$lang$reflect$AnnotatedType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedTypeVariable_getAnnotatedBounds__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedBounds", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
}

public extension java$lang$reflect$AnnotatedTypeVariable {
    func getAnnotatedBounds() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$AnnotatedTypeVariable$.java$lang$reflect$AnnotatedTypeVariable_getAnnotatedBounds__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public protocol java$lang$reflect$AnnotatedWildcardType : java$lang$reflect$AnnotatedType {
    func getAnnotatedLowerBounds() throws -> [java$lang$reflect$AnnotatedType?]?
    func getAnnotatedUpperBounds() throws -> [java$lang$reflect$AnnotatedType?]?
}

public class java$lang$reflect$AnnotatedWildcardType$ : java$lang$Object$, java$lang$reflect$AnnotatedWildcardType, java$lang$reflect$AnnotatedType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$AnnotatedWildcardType_getAnnotatedLowerBounds__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedLowerBounds", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
    private static let java$lang$reflect$AnnotatedWildcardType_getAnnotatedUpperBounds__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedUpperBounds", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
}

public extension java$lang$reflect$AnnotatedWildcardType {
    func getAnnotatedLowerBounds() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$AnnotatedWildcardType$.java$lang$reflect$AnnotatedWildcardType_getAnnotatedLowerBounds__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

    func getAnnotatedUpperBounds() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$AnnotatedWildcardType$.java$lang$reflect$AnnotatedWildcardType_getAnnotatedUpperBounds__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public final class java$lang$reflect$Array : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Array_newInstance_java$lang$Class_I__java$lang$Object = svoker("newInstance", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class"), jint.jniType))
    public static func newInstance(a0: java$lang$Class?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Array$.java$lang$reflect$Array_newInstance_java$lang$Class_I__java$lang$Object(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$reflect$Array_newInstance_java$lang$Class_AI__java$lang$Object = svoker("newInstance", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class"), JArray(jint.jniType)))
    public static func newInstance(a0: java$lang$Class?, _ a1: [jint]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Array$.java$lang$reflect$Array_newInstance_java$lang$Class_AI__java$lang$Object(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$Array_getLength_java$lang$Object__I = svoker("getLength", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func getLength(a0: java$lang$Object?) throws -> jint {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getLength_java$lang$Object__I(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Array_get_java$lang$Object_I__java$lang$Object = svoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func get(a0: java$lang$Object?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Array$.java$lang$reflect$Array_get_java$lang$Object_I__java$lang$Object(a0?.jobj ?? nil, a1))
    }

    private static let java$lang$reflect$Array_getBoolean_java$lang$Object_I__Z = svoker("getBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getBoolean(a0: java$lang$Object?, _ a1: jint) throws -> jboolean {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getBoolean_java$lang$Object_I__Z(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getByte_java$lang$Object_I__B = svoker("getByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getByte(a0: java$lang$Object?, _ a1: jint) throws -> jbyte {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getByte_java$lang$Object_I__B(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getChar_java$lang$Object_I__C = svoker("getChar", returns: jchar.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getChar(a0: java$lang$Object?, _ a1: jint) throws -> jchar {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getChar_java$lang$Object_I__C(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getShort_java$lang$Object_I__S = svoker("getShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getShort(a0: java$lang$Object?, _ a1: jint) throws -> jshort {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getShort_java$lang$Object_I__S(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getInt_java$lang$Object_I__I = svoker("getInt", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getInt(a0: java$lang$Object?, _ a1: jint) throws -> jint {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getInt_java$lang$Object_I__I(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getLong_java$lang$Object_I__J = svoker("getLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getLong(a0: java$lang$Object?, _ a1: jint) throws -> jlong {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getLong_java$lang$Object_I__J(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getFloat_java$lang$Object_I__F = svoker("getFloat", returns: jfloat.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getFloat(a0: java$lang$Object?, _ a1: jint) throws -> jfloat {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getFloat_java$lang$Object_I__F(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_getDouble_java$lang$Object_I__D = svoker("getDouble", returns: jdouble.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public static func getDouble(a0: java$lang$Object?, _ a1: jint) throws -> jdouble {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_getDouble_java$lang$Object_I__D(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Array_set_java$lang$Object_I_java$lang$Object__V = svoker("set", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, JObjectType("java/lang/Object")))
    public static func set(a0: java$lang$Object?, _ a1: jint, _ a2: java$lang$Object?) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_set_java$lang$Object_I_java$lang$Object__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
    }

    private static let java$lang$reflect$Array_setBoolean_java$lang$Object_I_Z__V = svoker("setBoolean", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jboolean.jniType))
    public static func setBoolean(a0: java$lang$Object?, _ a1: jint, _ a2: jboolean) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setBoolean_java$lang$Object_I_Z__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setByte_java$lang$Object_I_B__V = svoker("setByte", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jbyte.jniType))
    public static func setByte(a0: java$lang$Object?, _ a1: jint, _ a2: jbyte) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setByte_java$lang$Object_I_B__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setChar_java$lang$Object_I_C__V = svoker("setChar", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jchar.jniType))
    public static func setChar(a0: java$lang$Object?, _ a1: jint, _ a2: jchar) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setChar_java$lang$Object_I_C__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setShort_java$lang$Object_I_S__V = svoker("setShort", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jshort.jniType))
    public static func setShort(a0: java$lang$Object?, _ a1: jint, _ a2: jshort) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setShort_java$lang$Object_I_S__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setInt_java$lang$Object_I_I__V = svoker("setInt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jint.jniType))
    public static func setInt(a0: java$lang$Object?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setInt_java$lang$Object_I_I__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setLong_java$lang$Object_I_J__V = svoker("setLong", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jlong.jniType))
    public static func setLong(a0: java$lang$Object?, _ a1: jint, _ a2: jlong) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setLong_java$lang$Object_I_J__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setFloat_java$lang$Object_I_F__V = svoker("setFloat", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jfloat.jniType))
    public static func setFloat(a0: java$lang$Object?, _ a1: jint, _ a2: jfloat) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setFloat_java$lang$Object_I_F__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$lang$reflect$Array_setDouble_java$lang$Object_I_D__V = svoker("setDouble", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType, jdouble.jniType))
    public static func setDouble(a0: java$lang$Object?, _ a1: jint, _ a2: jdouble) throws -> Void {
        return try java$lang$reflect$Array$.java$lang$reflect$Array_setDouble_java$lang$Object_I_D__V(a0?.jobj ?? nil, a1, a2)
    }

}

public typealias java$lang$reflect$Array$ = java$lang$reflect$Array

public final class java$lang$reflect$Constructor : java$lang$reflect$Executable$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Constructor_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    private static let java$lang$reflect$Constructor_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Constructor_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    private static let java$lang$reflect$Constructor_getTypeParameters__Ajava$lang$reflect$TypeVariable = invoker("getTypeParameters", returns: JArray(JObjectType("java/lang/reflect/TypeVariable")))
    private static let java$lang$reflect$Constructor_getParameterTypes__Ajava$lang$Class = invoker("getParameterTypes", returns: JArray(JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Constructor_getParameterCount__I = invoker("getParameterCount", returns: jint.jniType)
    private static let java$lang$reflect$Constructor_getGenericParameterTypes__Ajava$lang$reflect$Type = invoker("getGenericParameterTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$Constructor_getExceptionTypes__Ajava$lang$Class = invoker("getExceptionTypes", returns: JArray(JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Constructor_getGenericExceptionTypes__Ajava$lang$reflect$Type = invoker("getGenericExceptionTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$Constructor_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$reflect$Constructor_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$reflect$Constructor_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Constructor_toGenericString__java$lang$String = invoker("toGenericString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Constructor_newInstance_Ajava$lang$Object__java$lang$Object = invoker("newInstance", returns: JObjectType("java/lang/Object"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public func newInstance(a0: [java$lang$Object?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Constructor$.java$lang$reflect$Constructor_newInstance_Ajava$lang$Object__java$lang$Object(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$Constructor_isVarArgs__Z = invoker("isVarArgs", returns: jboolean.jniType)
    private static let java$lang$reflect$Constructor_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    private static let java$lang$reflect$Constructor_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Constructor_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    private static let java$lang$reflect$Constructor_getAnnotatedReturnType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedReturnType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    private static let java$lang$reflect$Constructor_getAnnotatedReceiverType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedReceiverType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
}

public typealias java$lang$reflect$Constructor$ = java$lang$reflect$Constructor

public class java$lang$reflect$Executable : java$lang$reflect$AccessibleObject$, java$lang$reflect$Member, java$lang$reflect$GenericDeclaration {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Executable_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    public func getDeclaringClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Executable$.java$lang$reflect$Executable_getDeclaringClass__java$lang$Class(jobj)())
    }

    private static let java$lang$reflect$Executable_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Executable$.java$lang$reflect$Executable_getName__java$lang$String(jobj)())
    }

    private static let java$lang$reflect$Executable_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    public func getModifiers() throws -> jint {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getModifiers__I(jobj)()
    }

    private static let java$lang$reflect$Executable_getTypeParameters__Ajava$lang$reflect$TypeVariable = invoker("getTypeParameters", returns: JArray(JObjectType("java/lang/reflect/TypeVariable")))
    public func getTypeParameters() throws -> [java$lang$reflect$TypeVariable?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getTypeParameters__Ajava$lang$reflect$TypeVariable(jobj)().jarrayToArray(java$lang$reflect$TypeVariable$.self)?.map({ $0 as java$lang$reflect$TypeVariable? })
    }

    private static let java$lang$reflect$Executable_getParameterTypes__Ajava$lang$Class = invoker("getParameterTypes", returns: JArray(JObjectType("java/lang/Class")))
    public func getParameterTypes() throws -> [java$lang$Class?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getParameterTypes__Ajava$lang$Class(jobj)().jarrayToArray(java$lang$Class$.self)?.map({ $0 as java$lang$Class? })
    }

    private static let java$lang$reflect$Executable_getParameterCount__I = invoker("getParameterCount", returns: jint.jniType)
    public func getParameterCount() throws -> jint {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getParameterCount__I(jobj)()
    }

    private static let java$lang$reflect$Executable_getGenericParameterTypes__Ajava$lang$reflect$Type = invoker("getGenericParameterTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    public func getGenericParameterTypes() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getGenericParameterTypes__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    private static let java$lang$reflect$Executable_getParameters__Ajava$lang$reflect$Parameter = invoker("getParameters", returns: JArray(JObjectType("java/lang/reflect/Parameter")))
    public func getParameters() throws -> [java$lang$reflect$Parameter?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getParameters__Ajava$lang$reflect$Parameter(jobj)().jarrayToArray(java$lang$reflect$Parameter$.self)?.map({ $0 as java$lang$reflect$Parameter? })
    }

    private static let java$lang$reflect$Executable_getExceptionTypes__Ajava$lang$Class = invoker("getExceptionTypes", returns: JArray(JObjectType("java/lang/Class")))
    public func getExceptionTypes() throws -> [java$lang$Class?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getExceptionTypes__Ajava$lang$Class(jobj)().jarrayToArray(java$lang$Class$.self)?.map({ $0 as java$lang$Class? })
    }

    private static let java$lang$reflect$Executable_getGenericExceptionTypes__Ajava$lang$reflect$Type = invoker("getGenericExceptionTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    public func getGenericExceptionTypes() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getGenericExceptionTypes__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    private static let java$lang$reflect$Executable_toGenericString__java$lang$String = invoker("toGenericString", returns: JObjectType("java/lang/String"))
    public func toGenericString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Executable$.java$lang$reflect$Executable_toGenericString__java$lang$String(jobj)())
    }

    private static let java$lang$reflect$Executable_isVarArgs__Z = invoker("isVarArgs", returns: jboolean.jniType)
    public func isVarArgs() throws -> jboolean {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_isVarArgs__Z(jobj)()
    }

    private static let java$lang$reflect$Executable_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    public func isSynthetic() throws -> jboolean {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_isSynthetic__Z(jobj)()
    }

    private static let java$lang$reflect$Executable_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Executable_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Executable_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    private static let java$lang$reflect$Executable_getAnnotatedReturnType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedReturnType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    public func getAnnotatedReturnType() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$reflect$Executable$.java$lang$reflect$Executable_getAnnotatedReturnType__java$lang$reflect$AnnotatedType(jobj)())
    }

    private static let java$lang$reflect$Executable_getAnnotatedReceiverType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedReceiverType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    public func getAnnotatedReceiverType() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$reflect$Executable$.java$lang$reflect$Executable_getAnnotatedReceiverType__java$lang$reflect$AnnotatedType(jobj)())
    }

    private static let java$lang$reflect$Executable_getAnnotatedParameterTypes__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedParameterTypes", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
    public func getAnnotatedParameterTypes() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getAnnotatedParameterTypes__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

    private static let java$lang$reflect$Executable_getAnnotatedExceptionTypes__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedExceptionTypes", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
    public func getAnnotatedExceptionTypes() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$Executable$.java$lang$reflect$Executable_getAnnotatedExceptionTypes__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public typealias java$lang$reflect$Executable$ = java$lang$reflect$Executable

public final class java$lang$reflect$Field : java$lang$reflect$AccessibleObject$, java$lang$reflect$Member {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Field_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    public func getDeclaringClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_getDeclaringClass__java$lang$Class(jobj)())
    }

    private static let java$lang$reflect$Field_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_getName__java$lang$String(jobj)())
    }

    private static let java$lang$reflect$Field_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    public func getModifiers() throws -> jint {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getModifiers__I(jobj)()
    }

    private static let java$lang$reflect$Field_isEnumConstant__Z = invoker("isEnumConstant", returns: jboolean.jniType)
    public func isEnumConstant() throws -> jboolean {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_isEnumConstant__Z(jobj)()
    }

    private static let java$lang$reflect$Field_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    public func isSynthetic() throws -> jboolean {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_isSynthetic__Z(jobj)()
    }

    private static let java$lang$reflect$Field_getType__java$lang$Class = invoker("getType", returns: JObjectType("java/lang/Class"))
    public func getType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_getType__java$lang$Class(jobj)())
    }

    private static let java$lang$reflect$Field_getGenericType__java$lang$reflect$Type = invoker("getGenericType", returns: JObjectType("java/lang/reflect/Type"))
    public func getGenericType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_getGenericType__java$lang$reflect$Type(jobj)())
    }

    private static let java$lang$reflect$Field_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$reflect$Field_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$reflect$Field_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Field_toGenericString__java$lang$String = invoker("toGenericString", returns: JObjectType("java/lang/String"))
    public func toGenericString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_toGenericString__java$lang$String(jobj)())
    }

    private static let java$lang$reflect$Field_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$Field_getBoolean_java$lang$Object__Z = invoker("getBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getBoolean(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getBoolean_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getByte_java$lang$Object__B = invoker("getByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getByte(a0: java$lang$Object?) throws -> jbyte {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getByte_java$lang$Object__B(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getChar_java$lang$Object__C = invoker("getChar", returns: jchar.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getChar(a0: java$lang$Object?) throws -> jchar {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getChar_java$lang$Object__C(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getShort_java$lang$Object__S = invoker("getShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getShort(a0: java$lang$Object?) throws -> jshort {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getShort_java$lang$Object__S(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getInt_java$lang$Object__I = invoker("getInt", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getInt(a0: java$lang$Object?) throws -> jint {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getInt_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getLong_java$lang$Object__J = invoker("getLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getLong(a0: java$lang$Object?) throws -> jlong {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getLong_java$lang$Object__J(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getFloat_java$lang$Object__F = invoker("getFloat", returns: jfloat.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getFloat(a0: java$lang$Object?) throws -> jfloat {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getFloat_java$lang$Object__F(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_getDouble_java$lang$Object__D = invoker("getDouble", returns: jdouble.jniType, arguments: (JObjectType("java/lang/Object")))
    public func getDouble(a0: java$lang$Object?) throws -> jdouble {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_getDouble_java$lang$Object__D(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_set_java$lang$Object_java$lang$Object__V = invoker("set", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func set(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_set_java$lang$Object_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$reflect$Field_setBoolean_java$lang$Object_Z__V = invoker("setBoolean", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    public func setBoolean(a0: java$lang$Object?, _ a1: jboolean) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setBoolean_java$lang$Object_Z__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setByte_java$lang$Object_B__V = invoker("setByte", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jbyte.jniType))
    public func setByte(a0: java$lang$Object?, _ a1: jbyte) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setByte_java$lang$Object_B__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setChar_java$lang$Object_C__V = invoker("setChar", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jchar.jniType))
    public func setChar(a0: java$lang$Object?, _ a1: jchar) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setChar_java$lang$Object_C__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setShort_java$lang$Object_S__V = invoker("setShort", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jshort.jniType))
    public func setShort(a0: java$lang$Object?, _ a1: jshort) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setShort_java$lang$Object_S__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setInt_java$lang$Object_I__V = invoker("setInt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public func setInt(a0: java$lang$Object?, _ a1: jint) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setInt_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setLong_java$lang$Object_J__V = invoker("setLong", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jlong.jniType))
    public func setLong(a0: java$lang$Object?, _ a1: jlong) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setLong_java$lang$Object_J__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setFloat_java$lang$Object_F__V = invoker("setFloat", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jfloat.jniType))
    public func setFloat(a0: java$lang$Object?, _ a1: jfloat) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setFloat_java$lang$Object_F__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_setDouble_java$lang$Object_D__V = invoker("setDouble", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jdouble.jniType))
    public func setDouble(a0: java$lang$Object?, _ a1: jdouble) throws -> Void {
        return try java$lang$reflect$Field$.java$lang$reflect$Field_setDouble_java$lang$Object_D__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$lang$reflect$Field_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Field_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Field_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    private static let java$lang$reflect$Field_getAnnotatedType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    public func getAnnotatedType() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$reflect$Field$.java$lang$reflect$Field_getAnnotatedType__java$lang$reflect$AnnotatedType(jobj)())
    }

}

public typealias java$lang$reflect$Field$ = java$lang$reflect$Field

public protocol java$lang$reflect$GenericArrayType : java$lang$reflect$Type {
    func getGenericComponentType() throws -> java$lang$reflect$Type?
}

public class java$lang$reflect$GenericArrayType$ : java$lang$Object$, java$lang$reflect$GenericArrayType, java$lang$reflect$Type {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$GenericArrayType_getGenericComponentType__java$lang$reflect$Type = invoker("getGenericComponentType", returns: JObjectType("java/lang/reflect/Type"))
}

public extension java$lang$reflect$GenericArrayType {
    func getGenericComponentType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$GenericArrayType$.java$lang$reflect$GenericArrayType_getGenericComponentType__java$lang$reflect$Type(jobj)())
    }

}

public protocol java$lang$reflect$GenericDeclaration : java$lang$reflect$AnnotatedElement {
    func getTypeParameters() throws -> [java$lang$reflect$TypeVariable?]?
}

public class java$lang$reflect$GenericDeclaration$ : java$lang$Object$, java$lang$reflect$GenericDeclaration, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$GenericDeclaration_getTypeParameters__Ajava$lang$reflect$TypeVariable = invoker("getTypeParameters", returns: JArray(JObjectType("java/lang/reflect/TypeVariable")))
}

public extension java$lang$reflect$GenericDeclaration {
    func getTypeParameters() throws -> [java$lang$reflect$TypeVariable?]? {
        return try java$lang$reflect$GenericDeclaration$.java$lang$reflect$GenericDeclaration_getTypeParameters__Ajava$lang$reflect$TypeVariable(jobj)().jarrayToArray(java$lang$reflect$TypeVariable$.self)?.map({ $0 as java$lang$reflect$TypeVariable? })
    }

}

public class java$lang$reflect$GenericSignatureFormatError : java$lang$ClassFormatError$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$GenericSignatureFormatError_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$reflect$GenericSignatureFormatError$.java$lang$reflect$GenericSignatureFormatError_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$GenericSignatureFormatError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$reflect$GenericSignatureFormatError$.java$lang$reflect$GenericSignatureFormatError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$reflect$GenericSignatureFormatError$ = java$lang$reflect$GenericSignatureFormatError

public protocol java$lang$reflect$InvocationHandler : JavaObject {
    func invoke(a0: java$lang$Object?, _ a1: java$lang$reflect$Method?, _ a2: [java$lang$Object?]?) throws -> java$lang$Object?
}

public class java$lang$reflect$InvocationHandler$ : java$lang$Object$, java$lang$reflect$InvocationHandler {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$InvocationHandler_invoke_java$lang$Object_java$lang$reflect$Method_Ajava$lang$Object__java$lang$Object = invoker("invoke", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/reflect/Method"), JArray(JObjectType("java/lang/Object"))))
}

public extension java$lang$reflect$InvocationHandler {
    func invoke(a0: java$lang$Object?, _ a1: java$lang$reflect$Method?, _ a2: [java$lang$Object?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$InvocationHandler$.java$lang$reflect$InvocationHandler_invoke_java$lang$Object_java$lang$reflect$Method_Ajava$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

}

public class java$lang$reflect$InvocationTargetException : java$lang$ReflectiveOperationException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$InvocationTargetException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$reflect$InvocationTargetException$.java$lang$reflect$InvocationTargetException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$InvocationTargetException_init_java$lang$Throwable_java$lang$String__V = constructor((JObjectType("java/lang/Throwable"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$Throwable?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$reflect$InvocationTargetException$.java$lang$reflect$InvocationTargetException_init_java$lang$Throwable_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$InvocationTargetException_getTargetException__java$lang$Throwable = invoker("getTargetException", returns: JObjectType("java/lang/Throwable"))
    public func getTargetException() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$reflect$InvocationTargetException$.java$lang$reflect$InvocationTargetException_getTargetException__java$lang$Throwable(jobj)())
    }

    private static let java$lang$reflect$InvocationTargetException_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$lang$reflect$InvocationTargetException$ = java$lang$reflect$InvocationTargetException

public class java$lang$reflect$MalformedParameterizedTypeException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$MalformedParameterizedTypeException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$reflect$MalformedParameterizedTypeException$.java$lang$reflect$MalformedParameterizedTypeException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$lang$reflect$MalformedParameterizedTypeException$ = java$lang$reflect$MalformedParameterizedTypeException

public class java$lang$reflect$MalformedParametersException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$MalformedParametersException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$reflect$MalformedParametersException$.java$lang$reflect$MalformedParametersException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$MalformedParametersException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$lang$reflect$MalformedParametersException$.java$lang$reflect$MalformedParametersException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$lang$reflect$MalformedParametersException$ = java$lang$reflect$MalformedParametersException

public protocol java$lang$reflect$Member : JavaObject {
    func getDeclaringClass() throws -> java$lang$Class?
    func getName() throws -> java$lang$String?
    func getModifiers() throws -> jint
    func isSynthetic() throws -> jboolean
}

public class java$lang$reflect$Member$ : java$lang$Object$, java$lang$reflect$Member {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Member_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    private static let java$lang$reflect$Member_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Member_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    private static let java$lang$reflect$Member_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
}

public extension java$lang$reflect$Member {
    func getDeclaringClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Member$.java$lang$reflect$Member_getDeclaringClass__java$lang$Class(jobj)())
    }

    func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Member$.java$lang$reflect$Member_getName__java$lang$String(jobj)())
    }

    func getModifiers() throws -> jint {
        return try java$lang$reflect$Member$.java$lang$reflect$Member_getModifiers__I(jobj)()
    }

    func isSynthetic() throws -> jboolean {
        return try java$lang$reflect$Member$.java$lang$reflect$Member_isSynthetic__Z(jobj)()
    }

}

public final class java$lang$reflect$Method : java$lang$reflect$Executable$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Method_getDeclaringClass__java$lang$Class = invoker("getDeclaringClass", returns: JObjectType("java/lang/Class"))
    private static let java$lang$reflect$Method_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Method_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    private static let java$lang$reflect$Method_getTypeParameters__Ajava$lang$reflect$TypeVariable = invoker("getTypeParameters", returns: JArray(JObjectType("java/lang/reflect/TypeVariable")))
    private static let java$lang$reflect$Method_getReturnType__java$lang$Class = invoker("getReturnType", returns: JObjectType("java/lang/Class"))
    public func getReturnType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Method$.java$lang$reflect$Method_getReturnType__java$lang$Class(jobj)())
    }

    private static let java$lang$reflect$Method_getGenericReturnType__java$lang$reflect$Type = invoker("getGenericReturnType", returns: JObjectType("java/lang/reflect/Type"))
    public func getGenericReturnType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$Method$.java$lang$reflect$Method_getGenericReturnType__java$lang$reflect$Type(jobj)())
    }

    private static let java$lang$reflect$Method_getParameterTypes__Ajava$lang$Class = invoker("getParameterTypes", returns: JArray(JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Method_getParameterCount__I = invoker("getParameterCount", returns: jint.jniType)
    private static let java$lang$reflect$Method_getGenericParameterTypes__Ajava$lang$reflect$Type = invoker("getGenericParameterTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$Method_getExceptionTypes__Ajava$lang$Class = invoker("getExceptionTypes", returns: JArray(JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Method_getGenericExceptionTypes__Ajava$lang$reflect$Type = invoker("getGenericExceptionTypes", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$Method_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$reflect$Method_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$reflect$Method_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Method_toGenericString__java$lang$String = invoker("toGenericString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Method_invoke_java$lang$Object_Ajava$lang$Object__java$lang$Object = invoker("invoke", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JArray(JObjectType("java/lang/Object"))))
    public func invoke(a0: java$lang$Object?, _ a1: [java$lang$Object?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Method$.java$lang$reflect$Method_invoke_java$lang$Object_Ajava$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$Method_isBridge__Z = invoker("isBridge", returns: jboolean.jniType)
    public func isBridge() throws -> jboolean {
        return try java$lang$reflect$Method$.java$lang$reflect$Method_isBridge__Z(jobj)()
    }

    private static let java$lang$reflect$Method_isVarArgs__Z = invoker("isVarArgs", returns: jboolean.jniType)
    private static let java$lang$reflect$Method_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    private static let java$lang$reflect$Method_isDefault__Z = invoker("isDefault", returns: jboolean.jniType)
    public func isDefault() throws -> jboolean {
        return try java$lang$reflect$Method$.java$lang$reflect$Method_isDefault__Z(jobj)()
    }

    private static let java$lang$reflect$Method_getDefaultValue__java$lang$Object = invoker("getDefaultValue", returns: JObjectType("java/lang/Object"))
    public func getDefaultValue() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Method$.java$lang$reflect$Method_getDefaultValue__java$lang$Object(jobj)())
    }

    private static let java$lang$reflect$Method_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    private static let java$lang$reflect$Method_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    private static let java$lang$reflect$Method_getAnnotatedReturnType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedReturnType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
}

public typealias java$lang$reflect$Method$ = java$lang$reflect$Method

public class java$lang$reflect$Modifier : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Modifier_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_init__V()
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$Modifier_isPublic_I__Z = svoker("isPublic", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isPublic(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isPublic_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isPrivate_I__Z = svoker("isPrivate", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isPrivate(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isPrivate_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isProtected_I__Z = svoker("isProtected", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isProtected(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isProtected_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isStatic_I__Z = svoker("isStatic", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isStatic(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isStatic_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isFinal_I__Z = svoker("isFinal", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isFinal(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isFinal_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isSynchronized_I__Z = svoker("isSynchronized", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isSynchronized(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isSynchronized_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isVolatile_I__Z = svoker("isVolatile", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isVolatile(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isVolatile_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isTransient_I__Z = svoker("isTransient", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isTransient(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isTransient_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isNative_I__Z = svoker("isNative", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isNative(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isNative_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isInterface_I__Z = svoker("isInterface", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isInterface(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isInterface_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isAbstract_I__Z = svoker("isAbstract", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isAbstract(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isAbstract_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_isStrict_I__Z = svoker("isStrict", returns: jboolean.jniType, arguments: (jint.jniType))
    public static func isStrict(a0: jint) throws -> jboolean {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_isStrict_I__Z(a0)
    }

    private static let java$lang$reflect$Modifier_toString_I__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public static func toString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Modifier$.java$lang$reflect$Modifier_toString_I__java$lang$String(a0))
    }

    private static let java$lang$reflect$Modifier_classModifiers__I = svoker("classModifiers", returns: jint.jniType)
    public static func classModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_classModifiers__I()
    }

    private static let java$lang$reflect$Modifier_interfaceModifiers__I = svoker("interfaceModifiers", returns: jint.jniType)
    public static func interfaceModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_interfaceModifiers__I()
    }

    private static let java$lang$reflect$Modifier_constructorModifiers__I = svoker("constructorModifiers", returns: jint.jniType)
    public static func constructorModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_constructorModifiers__I()
    }

    private static let java$lang$reflect$Modifier_methodModifiers__I = svoker("methodModifiers", returns: jint.jniType)
    public static func methodModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_methodModifiers__I()
    }

    private static let java$lang$reflect$Modifier_fieldModifiers__I = svoker("fieldModifiers", returns: jint.jniType)
    public static func fieldModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_fieldModifiers__I()
    }

    private static let java$lang$reflect$Modifier_parameterModifiers__I = svoker("parameterModifiers", returns: jint.jniType)
    public static func parameterModifiers() throws -> jint {
        return try java$lang$reflect$Modifier$.java$lang$reflect$Modifier_parameterModifiers__I()
    }

}

public typealias java$lang$reflect$Modifier$ = java$lang$reflect$Modifier

public final class java$lang$reflect$Parameter : java$lang$Object$, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Parameter_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$lang$reflect$Parameter_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$lang$reflect$Parameter_isNamePresent__Z = invoker("isNamePresent", returns: jboolean.jniType)
    public func isNamePresent() throws -> jboolean {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_isNamePresent__Z(jobj)()
    }

    private static let java$lang$reflect$Parameter_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$Parameter_getDeclaringExecutable__java$lang$reflect$Executable = invoker("getDeclaringExecutable", returns: JObjectType("java/lang/reflect/Executable"))
    public func getDeclaringExecutable() throws -> java$lang$reflect$Executable? {
        return try java$lang$reflect$Executable$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getDeclaringExecutable__java$lang$reflect$Executable(jobj)())
    }

    private static let java$lang$reflect$Parameter_getModifiers__I = invoker("getModifiers", returns: jint.jniType)
    public func getModifiers() throws -> jint {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getModifiers__I(jobj)()
    }

    private static let java$lang$reflect$Parameter_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getName__java$lang$String(jobj)())
    }

    private static let java$lang$reflect$Parameter_getParameterizedType__java$lang$reflect$Type = invoker("getParameterizedType", returns: JObjectType("java/lang/reflect/Type"))
    public func getParameterizedType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getParameterizedType__java$lang$reflect$Type(jobj)())
    }

    private static let java$lang$reflect$Parameter_getType__java$lang$Class = invoker("getType", returns: JObjectType("java/lang/Class"))
    public func getType() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getType__java$lang$Class(jobj)())
    }

    private static let java$lang$reflect$Parameter_getAnnotatedType__java$lang$reflect$AnnotatedType = invoker("getAnnotatedType", returns: JObjectType("java/lang/reflect/AnnotatedType"))
    public func getAnnotatedType() throws -> java$lang$reflect$AnnotatedType? {
        return try java$lang$reflect$AnnotatedType$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getAnnotatedType__java$lang$reflect$AnnotatedType(jobj)())
    }

    private static let java$lang$reflect$Parameter_isImplicit__Z = invoker("isImplicit", returns: jboolean.jniType)
    public func isImplicit() throws -> jboolean {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_isImplicit__Z(jobj)()
    }

    private static let java$lang$reflect$Parameter_isSynthetic__Z = invoker("isSynthetic", returns: jboolean.jniType)
    public func isSynthetic() throws -> jboolean {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_isSynthetic__Z(jobj)()
    }

    private static let java$lang$reflect$Parameter_isVarArgs__Z = invoker("isVarArgs", returns: jboolean.jniType)
    public func isVarArgs() throws -> jboolean {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_isVarArgs__Z(jobj)()
    }

    private static let java$lang$reflect$Parameter_getAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$Parameter_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$Parameter_getDeclaredAnnotations__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getDeclaredAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getDeclaredAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$Parameter_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation = invoker("getDeclaredAnnotation", returns: JObjectType("java/lang/annotation/Annotation"), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotation(a0: java$lang$Class?) throws -> java$lang$annotation$Annotation? {
        return try java$lang$annotation$Annotation$(jobj: java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getDeclaredAnnotation_java$lang$Class__java$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$Parameter_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation = invoker("getDeclaredAnnotationsByType", returns: JArray(JObjectType("java/lang/annotation/Annotation")), arguments: (JObjectType("java/lang/Class")))
    public func getDeclaredAnnotationsByType(a0: java$lang$Class?) throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getDeclaredAnnotationsByType_java$lang$Class__Ajava$lang$annotation$Annotation(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

    private static let java$lang$reflect$Parameter_getAnnotations__Ajava$lang$annotation$Annotation = invoker("getAnnotations", returns: JArray(JObjectType("java/lang/annotation/Annotation")))
    public func getAnnotations() throws -> [java$lang$annotation$Annotation?]? {
        return try java$lang$reflect$Parameter$.java$lang$reflect$Parameter_getAnnotations__Ajava$lang$annotation$Annotation(jobj)().jarrayToArray(java$lang$annotation$Annotation$.self)?.map({ $0 as java$lang$annotation$Annotation? })
    }

}

public typealias java$lang$reflect$Parameter$ = java$lang$reflect$Parameter

public protocol java$lang$reflect$ParameterizedType : java$lang$reflect$Type {
    func getActualTypeArguments() throws -> [java$lang$reflect$Type?]?
    func getRawType() throws -> java$lang$reflect$Type?
    func getOwnerType() throws -> java$lang$reflect$Type?
}

public class java$lang$reflect$ParameterizedType$ : java$lang$Object$, java$lang$reflect$ParameterizedType, java$lang$reflect$Type {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$ParameterizedType_getActualTypeArguments__Ajava$lang$reflect$Type = invoker("getActualTypeArguments", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$ParameterizedType_getRawType__java$lang$reflect$Type = invoker("getRawType", returns: JObjectType("java/lang/reflect/Type"))
    private static let java$lang$reflect$ParameterizedType_getOwnerType__java$lang$reflect$Type = invoker("getOwnerType", returns: JObjectType("java/lang/reflect/Type"))
}

public extension java$lang$reflect$ParameterizedType {
    func getActualTypeArguments() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$ParameterizedType$.java$lang$reflect$ParameterizedType_getActualTypeArguments__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    func getRawType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$ParameterizedType$.java$lang$reflect$ParameterizedType_getRawType__java$lang$reflect$Type(jobj)())
    }

    func getOwnerType() throws -> java$lang$reflect$Type? {
        return try java$lang$reflect$Type$(jobj: java$lang$reflect$ParameterizedType$.java$lang$reflect$ParameterizedType_getOwnerType__java$lang$reflect$Type(jobj)())
    }

}

public class java$lang$reflect$Proxy : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Proxy_getProxyClass_java$lang$ClassLoader_Ajava$lang$Class__java$lang$Class = svoker("getProxyClass", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/ClassLoader"), JArray(JObjectType("java/lang/Class"))))
    public static func getProxyClass(a0: java$lang$ClassLoader?, _ a1: [java$lang$Class?]?) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$lang$reflect$Proxy$.java$lang$reflect$Proxy_getProxyClass_java$lang$ClassLoader_Ajava$lang$Class__java$lang$Class(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$Proxy_newProxyInstance_java$lang$ClassLoader_Ajava$lang$Class_java$lang$reflect$InvocationHandler__java$lang$Object = svoker("newProxyInstance", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/ClassLoader"), JArray(JObjectType("java/lang/Class")), JObjectType("java/lang/reflect/InvocationHandler")))
    public static func newProxyInstance(a0: java$lang$ClassLoader?, _ a1: [java$lang$Class?]?, _ a2: java$lang$reflect$InvocationHandler?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$Proxy$.java$lang$reflect$Proxy_newProxyInstance_java$lang$ClassLoader_Ajava$lang$Class_java$lang$reflect$InvocationHandler__java$lang$Object(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a2?.jobj ?? nil))
    }

    private static let java$lang$reflect$Proxy_isProxyClass_java$lang$Class__Z = svoker("isProxyClass", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
    public static func isProxyClass(a0: java$lang$Class?) throws -> jboolean {
        return try java$lang$reflect$Proxy$.java$lang$reflect$Proxy_isProxyClass_java$lang$Class__Z(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$Proxy_getInvocationHandler_java$lang$Object__java$lang$reflect$InvocationHandler = svoker("getInvocationHandler", returns: JObjectType("java/lang/reflect/InvocationHandler"), arguments: (JObjectType("java/lang/Object")))
    public static func getInvocationHandler(a0: java$lang$Object?) throws -> java$lang$reflect$InvocationHandler? {
        return try java$lang$reflect$InvocationHandler$(jobj: java$lang$reflect$Proxy$.java$lang$reflect$Proxy_getInvocationHandler_java$lang$Object__java$lang$reflect$InvocationHandler(a0?.jobj ?? nil))
    }

}

public typealias java$lang$reflect$Proxy$ = java$lang$reflect$Proxy

public class java$lang$reflect$ReflectAccess : java$lang$Object$, sun$reflect$LangReflectAccess {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$ReflectAccess_newField_java$lang$Class_java$lang$String_java$lang$Class_I_I_java$lang$String_AB__java$lang$reflect$Field = invoker("newField", returns: JObjectType("java/lang/reflect/Field"), arguments: (JObjectType("java/lang/Class"), JObjectType("java/lang/String"), JObjectType("java/lang/Class"), jint.jniType, jint.jniType, JObjectType("java/lang/String"), JArray(jbyte.jniType)))
    public func newField(a0: java$lang$Class?, _ a1: java$lang$String?, _ a2: java$lang$Class?, _ a3: jint, _ a4: jint, _ a5: java$lang$String?, _ a6: [jbyte]?) throws -> java$lang$reflect$Field? {
        return try java$lang$reflect$Field$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_newField_java$lang$Class_java$lang$String_java$lang$Class_I_I_java$lang$String_AB__java$lang$reflect$Field(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3, a4, a5?.jobj ?? nil, a6?.arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_newConstructor_java$lang$Class_Ajava$lang$Class_Ajava$lang$Class_I_I_java$lang$String_AB_AB__java$lang$reflect$Constructor = invoker("newConstructor", returns: JObjectType("java/lang/reflect/Constructor"), arguments: (JObjectType("java/lang/Class"), JArray(JObjectType("java/lang/Class")), JArray(JObjectType("java/lang/Class")), jint.jniType, jint.jniType, JObjectType("java/lang/String"), JArray(jbyte.jniType), JArray(jbyte.jniType)))
    public func newConstructor(a0: java$lang$Class?, _ a1: [java$lang$Class?]?, _ a2: [java$lang$Class?]?, _ a3: jint, _ a4: jint, _ a5: java$lang$String?, _ a6: [jbyte]?, _ a7: [jbyte]?) throws -> java$lang$reflect$Constructor? {
        return try java$lang$reflect$Constructor$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_newConstructor_java$lang$Class_Ajava$lang$Class_Ajava$lang$Class_I_I_java$lang$String_AB_AB__java$lang$reflect$Constructor(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a2?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a3, a4, a5?.jobj ?? nil, a6?.arrayToJArray() ?? nil, a7?.arrayToJArray() ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_getMethodAccessor_java$lang$reflect$Method__sun$reflect$MethodAccessor = invoker("getMethodAccessor", returns: JObjectType("sun/reflect/MethodAccessor"), arguments: (JObjectType("java/lang/reflect/Method")))
    public func getMethodAccessor(a0: java$lang$reflect$Method?) throws -> sun$reflect$MethodAccessor? {
        return try sun$reflect$MethodAccessor$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getMethodAccessor_java$lang$reflect$Method__sun$reflect$MethodAccessor(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_setMethodAccessor_java$lang$reflect$Method_sun$reflect$MethodAccessor__V = invoker("setMethodAccessor", returns: JVoid.jniType, arguments: (JObjectType("java/lang/reflect/Method"), JObjectType("sun/reflect/MethodAccessor")))
    public func setMethodAccessor(a0: java$lang$reflect$Method?, _ a1: sun$reflect$MethodAccessor?) throws -> Void {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_setMethodAccessor_java$lang$reflect$Method_sun$reflect$MethodAccessor__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$reflect$ReflectAccess_getConstructorAccessor_java$lang$reflect$Constructor__sun$reflect$ConstructorAccessor = invoker("getConstructorAccessor", returns: JObjectType("sun/reflect/ConstructorAccessor"), arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func getConstructorAccessor(a0: java$lang$reflect$Constructor?) throws -> sun$reflect$ConstructorAccessor? {
        return try sun$reflect$ConstructorAccessor$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getConstructorAccessor_java$lang$reflect$Constructor__sun$reflect$ConstructorAccessor(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_setConstructorAccessor_java$lang$reflect$Constructor_sun$reflect$ConstructorAccessor__V = invoker("setConstructorAccessor", returns: JVoid.jniType, arguments: (JObjectType("java/lang/reflect/Constructor"), JObjectType("sun/reflect/ConstructorAccessor")))
    public func setConstructorAccessor(a0: java$lang$reflect$Constructor?, _ a1: sun$reflect$ConstructorAccessor?) throws -> Void {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_setConstructorAccessor_java$lang$reflect$Constructor_sun$reflect$ConstructorAccessor__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$lang$reflect$ReflectAccess_getConstructorSlot_java$lang$reflect$Constructor__I = invoker("getConstructorSlot", returns: jint.jniType, arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func getConstructorSlot(a0: java$lang$reflect$Constructor?) throws -> jint {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getConstructorSlot_java$lang$reflect$Constructor__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$ReflectAccess_getConstructorSignature_java$lang$reflect$Constructor__java$lang$String = invoker("getConstructorSignature", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func getConstructorSignature(a0: java$lang$reflect$Constructor?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getConstructorSignature_java$lang$reflect$Constructor__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_getConstructorAnnotations_java$lang$reflect$Constructor__AB = invoker("getConstructorAnnotations", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func getConstructorAnnotations(a0: java$lang$reflect$Constructor?) throws -> [jbyte]? {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getConstructorAnnotations_java$lang$reflect$Constructor__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    private static let java$lang$reflect$ReflectAccess_getConstructorParameterAnnotations_java$lang$reflect$Constructor__AB = invoker("getConstructorParameterAnnotations", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func getConstructorParameterAnnotations(a0: java$lang$reflect$Constructor?) throws -> [jbyte]? {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getConstructorParameterAnnotations_java$lang$reflect$Constructor__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    private static let java$lang$reflect$ReflectAccess_getExecutableTypeAnnotationBytes_java$lang$reflect$Executable__AB = invoker("getExecutableTypeAnnotationBytes", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/reflect/Executable")))
    public func getExecutableTypeAnnotationBytes(a0: java$lang$reflect$Executable?) throws -> [jbyte]? {
        return try java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_getExecutableTypeAnnotationBytes_java$lang$reflect$Executable__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    private static let java$lang$reflect$ReflectAccess_copyMethod_java$lang$reflect$Method__java$lang$reflect$Method = invoker("copyMethod", returns: JObjectType("java/lang/reflect/Method"), arguments: (JObjectType("java/lang/reflect/Method")))
    public func copyMethod(a0: java$lang$reflect$Method?) throws -> java$lang$reflect$Method? {
        return try java$lang$reflect$Method$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_copyMethod_java$lang$reflect$Method__java$lang$reflect$Method(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_copyField_java$lang$reflect$Field__java$lang$reflect$Field = invoker("copyField", returns: JObjectType("java/lang/reflect/Field"), arguments: (JObjectType("java/lang/reflect/Field")))
    public func copyField(a0: java$lang$reflect$Field?) throws -> java$lang$reflect$Field? {
        return try java$lang$reflect$Field$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_copyField_java$lang$reflect$Field__java$lang$reflect$Field(jobj)(a0?.jobj ?? nil))
    }

    private static let java$lang$reflect$ReflectAccess_copyConstructor_java$lang$reflect$Constructor__java$lang$reflect$Constructor = invoker("copyConstructor", returns: JObjectType("java/lang/reflect/Constructor"), arguments: (JObjectType("java/lang/reflect/Constructor")))
    public func copyConstructor(a0: java$lang$reflect$Constructor?) throws -> java$lang$reflect$Constructor? {
        return try java$lang$reflect$Constructor$(jobj: java$lang$reflect$ReflectAccess$.java$lang$reflect$ReflectAccess_copyConstructor_java$lang$reflect$Constructor__java$lang$reflect$Constructor(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$lang$reflect$ReflectAccess$ = java$lang$reflect$ReflectAccess

public protocol java$lang$reflect$Type : JavaObject {
    func getTypeName() throws -> java$lang$String?
}

public class java$lang$reflect$Type$ : java$lang$Object$, java$lang$reflect$Type {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$Type_getTypeName__java$lang$String = invoker("getTypeName", returns: JObjectType("java/lang/String"))
}

public extension java$lang$reflect$Type {
    func getTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$Type$.java$lang$reflect$Type_getTypeName__java$lang$String(jobj)())
    }

}

public protocol java$lang$reflect$TypeVariable : java$lang$reflect$Type, java$lang$reflect$AnnotatedElement {
    func getBounds() throws -> [java$lang$reflect$Type?]?
    func getGenericDeclaration() throws -> java$lang$reflect$GenericDeclaration?
    func getName() throws -> java$lang$String?
    func getAnnotatedBounds() throws -> [java$lang$reflect$AnnotatedType?]?
}

public class java$lang$reflect$TypeVariable$ : java$lang$Object$, java$lang$reflect$TypeVariable, java$lang$reflect$Type, java$lang$reflect$AnnotatedElement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$TypeVariable_getBounds__Ajava$lang$reflect$Type = invoker("getBounds", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$TypeVariable_getGenericDeclaration__java$lang$reflect$GenericDeclaration = invoker("getGenericDeclaration", returns: JObjectType("java/lang/reflect/GenericDeclaration"))
    private static let java$lang$reflect$TypeVariable_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    private static let java$lang$reflect$TypeVariable_getAnnotatedBounds__Ajava$lang$reflect$AnnotatedType = invoker("getAnnotatedBounds", returns: JArray(JObjectType("java/lang/reflect/AnnotatedType")))
}

public extension java$lang$reflect$TypeVariable {
    func getBounds() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$TypeVariable$.java$lang$reflect$TypeVariable_getBounds__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    func getGenericDeclaration() throws -> java$lang$reflect$GenericDeclaration? {
        return try java$lang$reflect$GenericDeclaration$(jobj: java$lang$reflect$TypeVariable$.java$lang$reflect$TypeVariable_getGenericDeclaration__java$lang$reflect$GenericDeclaration(jobj)())
    }

    func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$lang$reflect$TypeVariable$.java$lang$reflect$TypeVariable_getName__java$lang$String(jobj)())
    }

    func getAnnotatedBounds() throws -> [java$lang$reflect$AnnotatedType?]? {
        return try java$lang$reflect$TypeVariable$.java$lang$reflect$TypeVariable_getAnnotatedBounds__Ajava$lang$reflect$AnnotatedType(jobj)().jarrayToArray(java$lang$reflect$AnnotatedType$.self)?.map({ $0 as java$lang$reflect$AnnotatedType? })
    }

}

public class java$lang$reflect$UndeclaredThrowableException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$UndeclaredThrowableException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$lang$reflect$UndeclaredThrowableException$.java$lang$reflect$UndeclaredThrowableException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$UndeclaredThrowableException_init_java$lang$Throwable_java$lang$String__V = constructor((JObjectType("java/lang/Throwable"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$Throwable?, _ a1: java$lang$String?) throws {
        let jobj = try java$lang$reflect$UndeclaredThrowableException$.java$lang$reflect$UndeclaredThrowableException_init_java$lang$Throwable_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$UndeclaredThrowableException_getUndeclaredThrowable__java$lang$Throwable = invoker("getUndeclaredThrowable", returns: JObjectType("java/lang/Throwable"))
    public func getUndeclaredThrowable() throws -> java$lang$Throwable? {
        return try java$lang$Throwable$(jobj: java$lang$reflect$UndeclaredThrowableException$.java$lang$reflect$UndeclaredThrowableException_getUndeclaredThrowable__java$lang$Throwable(jobj)())
    }

    private static let java$lang$reflect$UndeclaredThrowableException_getCause__java$lang$Throwable = invoker("getCause", returns: JObjectType("java/lang/Throwable"))
}

public typealias java$lang$reflect$UndeclaredThrowableException$ = java$lang$reflect$UndeclaredThrowableException

public final class java$lang$reflect$WeakCache : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$WeakCache_init_java$util$function$BiFunction_java$util$function$BiFunction__V = constructor((JObjectType("java/util/function/BiFunction"), JObjectType("java/util/function/BiFunction")))
    public convenience init!(_ a0: java$util$function$BiFunction?, _ a1: java$util$function$BiFunction?) throws {
        let jobj = try java$lang$reflect$WeakCache$.java$lang$reflect$WeakCache_init_java$util$function$BiFunction_java$util$function$BiFunction__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$lang$reflect$WeakCache_get_java$lang$Object_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func get(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$lang$reflect$WeakCache$.java$lang$reflect$WeakCache_get_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$lang$reflect$WeakCache_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsValue(a0: java$lang$Object?) throws -> jboolean {
        return try java$lang$reflect$WeakCache$.java$lang$reflect$WeakCache_containsValue_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$lang$reflect$WeakCache_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$lang$reflect$WeakCache$.java$lang$reflect$WeakCache_size__I(jobj)()
    }

}

public typealias java$lang$reflect$WeakCache$ = java$lang$reflect$WeakCache

public protocol java$lang$reflect$WildcardType : java$lang$reflect$Type {
    func getUpperBounds() throws -> [java$lang$reflect$Type?]?
    func getLowerBounds() throws -> [java$lang$reflect$Type?]?
}

public class java$lang$reflect$WildcardType$ : java$lang$Object$, java$lang$reflect$WildcardType, java$lang$reflect$Type {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$lang$reflect$WildcardType_getUpperBounds__Ajava$lang$reflect$Type = invoker("getUpperBounds", returns: JArray(JObjectType("java/lang/reflect/Type")))
    private static let java$lang$reflect$WildcardType_getLowerBounds__Ajava$lang$reflect$Type = invoker("getLowerBounds", returns: JArray(JObjectType("java/lang/reflect/Type")))
}

public extension java$lang$reflect$WildcardType {
    func getUpperBounds() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$WildcardType$.java$lang$reflect$WildcardType_getUpperBounds__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

    func getLowerBounds() throws -> [java$lang$reflect$Type?]? {
        return try java$lang$reflect$WildcardType$.java$lang$reflect$WildcardType_getLowerBounds__Ajava$lang$reflect$Type(jobj)().jarrayToArray(java$lang$reflect$Type$.self)?.map({ $0 as java$lang$reflect$Type? })
    }

}

public class java$math$BigDecimal : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$BigDecimal_init_AC_I_I__V = constructor((JArray(jchar.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jchar]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_AC_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_AC_I_I_java$math$MathContext__V = constructor((JArray(jchar.jniType), jint.jniType, jint.jniType, JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: [jchar]?, _ a1: jint, _ a2: jint, _ a3: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_AC_I_I_java$math$MathContext__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_AC__V = constructor((JArray(jchar.jniType)))
    public convenience init!(_ a0: [jchar]?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_AC__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_AC_java$math$MathContext__V = constructor((JArray(jchar.jniType), JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: [jchar]?, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_AC_java$math$MathContext__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$lang$String_java$math$MathContext__V = constructor((JObjectType("java/lang/String"), JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$lang$String_java$math$MathContext__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_D__V = constructor((jdouble.jniType))
    public convenience init!(_ a0: jdouble) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_D__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_D_java$math$MathContext__V = constructor((jdouble.jniType, JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: jdouble, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_D_java$math$MathContext__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$math$BigInteger__V = constructor((JObjectType("java/math/BigInteger")))
    public convenience init!(_ a0: java$math$BigInteger?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$math$BigInteger__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$math$BigInteger_java$math$MathContext__V = constructor((JObjectType("java/math/BigInteger"), JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: java$math$BigInteger?, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$math$BigInteger_java$math$MathContext__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$math$BigInteger_I__V = constructor((JObjectType("java/math/BigInteger"), jint.jniType))
    public convenience init!(_ a0: java$math$BigInteger?, _ a1: jint) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$math$BigInteger_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_java$math$BigInteger_I_java$math$MathContext__V = constructor((JObjectType("java/math/BigInteger"), jint.jniType, JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: java$math$BigInteger?, _ a1: jint, _ a2: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_java$math$BigInteger_I_java$math$MathContext__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_I_java$math$MathContext__V = constructor((jint.jniType, JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: jint, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_I_java$math$MathContext__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_init_J_java$math$MathContext__V = constructor((jlong.jniType, JObjectType("java/math/MathContext")))
    public convenience init!(_ a0: jlong, _ a1: java$math$MathContext?) throws {
        let jobj = try java$math$BigDecimal$.java$math$BigDecimal_init_J_java$math$MathContext__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigDecimal_valueOf_J_I__java$math$BigDecimal = svoker("valueOf", returns: JObjectType("java/math/BigDecimal"), arguments: (jlong.jniType, jint.jniType))
    public static func valueOf(a0: jlong, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_valueOf_J_I__java$math$BigDecimal(a0, a1))
    }

    private static let java$math$BigDecimal_valueOf_J__java$math$BigDecimal = svoker("valueOf", returns: JObjectType("java/math/BigDecimal"), arguments: (jlong.jniType))
    public static func valueOf(a0: jlong) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_valueOf_J__java$math$BigDecimal(a0))
    }

    private static let java$math$BigDecimal_valueOf_D__java$math$BigDecimal = svoker("valueOf", returns: JObjectType("java/math/BigDecimal"), arguments: (jdouble.jniType))
    public static func valueOf(a0: jdouble) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_valueOf_D__java$math$BigDecimal(a0))
    }

    private static let java$math$BigDecimal_add_java$math$BigDecimal__java$math$BigDecimal = invoker("add", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func add(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_add_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_add_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("add", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func add(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_add_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_subtract_java$math$BigDecimal__java$math$BigDecimal = invoker("subtract", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func subtract(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_subtract_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_subtract_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("subtract", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func subtract(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_subtract_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_multiply_java$math$BigDecimal__java$math$BigDecimal = invoker("multiply", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func multiply(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_multiply_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_multiply_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("multiply", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func multiply(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_multiply_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal_I_I__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), jint.jniType, jint.jniType))
    public func divide(a0: java$math$BigDecimal?, _ a1: jint, _ a2: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal_I_I__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal_I_java$math$RoundingMode__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), jint.jniType, JObjectType("java/math/RoundingMode")))
    public func divide(a0: java$math$BigDecimal?, _ a1: jint, _ a2: java$math$RoundingMode?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal_I_java$math$RoundingMode__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal_I__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), jint.jniType))
    public func divide(a0: java$math$BigDecimal?, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal_I__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal_java$math$RoundingMode__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/RoundingMode")))
    public func divide(a0: java$math$BigDecimal?, _ a1: java$math$RoundingMode?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal_java$math$RoundingMode__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func divide(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divide_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("divide", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func divide(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divide_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divideToIntegralValue_java$math$BigDecimal__java$math$BigDecimal = invoker("divideToIntegralValue", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func divideToIntegralValue(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divideToIntegralValue_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divideToIntegralValue_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("divideToIntegralValue", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func divideToIntegralValue(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_divideToIntegralValue_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_remainder_java$math$BigDecimal__java$math$BigDecimal = invoker("remainder", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func remainder(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_remainder_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_remainder_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal = invoker("remainder", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func remainder(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_remainder_java$math$BigDecimal_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_divideAndRemainder_java$math$BigDecimal__Ajava$math$BigDecimal = invoker("divideAndRemainder", returns: JArray(JObjectType("java/math/BigDecimal")), arguments: (JObjectType("java/math/BigDecimal")))
    public func divideAndRemainder(a0: java$math$BigDecimal?) throws -> [java$math$BigDecimal?]? {
        return try java$math$BigDecimal$.java$math$BigDecimal_divideAndRemainder_java$math$BigDecimal__Ajava$math$BigDecimal(jobj)(a0?.jobj ?? nil).jarrayToArray(java$math$BigDecimal$.self)?.map({ $0 as java$math$BigDecimal? })
    }

    private static let java$math$BigDecimal_divideAndRemainder_java$math$BigDecimal_java$math$MathContext__Ajava$math$BigDecimal = invoker("divideAndRemainder", returns: JArray(JObjectType("java/math/BigDecimal")), arguments: (JObjectType("java/math/BigDecimal"), JObjectType("java/math/MathContext")))
    public func divideAndRemainder(a0: java$math$BigDecimal?, _ a1: java$math$MathContext?) throws -> [java$math$BigDecimal?]? {
        return try java$math$BigDecimal$.java$math$BigDecimal_divideAndRemainder_java$math$BigDecimal_java$math$MathContext__Ajava$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil).jarrayToArray(java$math$BigDecimal$.self)?.map({ $0 as java$math$BigDecimal? })
    }

    private static let java$math$BigDecimal_pow_I__java$math$BigDecimal = invoker("pow", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    public func pow(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_pow_I__java$math$BigDecimal(jobj)(a0))
    }

    private static let java$math$BigDecimal_pow_I_java$math$MathContext__java$math$BigDecimal = invoker("pow", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType, JObjectType("java/math/MathContext")))
    public func pow(a0: jint, _ a1: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_pow_I_java$math$MathContext__java$math$BigDecimal(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_abs__java$math$BigDecimal = invoker("abs", returns: JObjectType("java/math/BigDecimal"))
    public func abs() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_abs__java$math$BigDecimal(jobj)())
    }

    private static let java$math$BigDecimal_abs_java$math$MathContext__java$math$BigDecimal = invoker("abs", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/MathContext")))
    public func abs(a0: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_abs_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_negate__java$math$BigDecimal = invoker("negate", returns: JObjectType("java/math/BigDecimal"))
    public func negate() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_negate__java$math$BigDecimal(jobj)())
    }

    private static let java$math$BigDecimal_negate_java$math$MathContext__java$math$BigDecimal = invoker("negate", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/MathContext")))
    public func negate(a0: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_negate_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_plus__java$math$BigDecimal = invoker("plus", returns: JObjectType("java/math/BigDecimal"))
    public func plus() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_plus__java$math$BigDecimal(jobj)())
    }

    private static let java$math$BigDecimal_plus_java$math$MathContext__java$math$BigDecimal = invoker("plus", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/MathContext")))
    public func plus(a0: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_plus_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_signum__I = invoker("signum", returns: jint.jniType)
    public func signum() throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_signum__I(jobj)()
    }

    private static let java$math$BigDecimal_scale__I = invoker("scale", returns: jint.jniType)
    public func scale() throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_scale__I(jobj)()
    }

    private static let java$math$BigDecimal_precision__I = invoker("precision", returns: jint.jniType)
    public func precision() throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_precision__I(jobj)()
    }

    private static let java$math$BigDecimal_unscaledValue__java$math$BigInteger = invoker("unscaledValue", returns: JObjectType("java/math/BigInteger"))
    public func unscaledValue() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigDecimal$.java$math$BigDecimal_unscaledValue__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigDecimal_round_java$math$MathContext__java$math$BigDecimal = invoker("round", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/MathContext")))
    public func round(a0: java$math$MathContext?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_round_java$math$MathContext__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_setScale_I_java$math$RoundingMode__java$math$BigDecimal = invoker("setScale", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType, JObjectType("java/math/RoundingMode")))
    public func setScale(a0: jint, _ a1: java$math$RoundingMode?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_setScale_I_java$math$RoundingMode__java$math$BigDecimal(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_setScale_I_I__java$math$BigDecimal = invoker("setScale", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType, jint.jniType))
    public func setScale(a0: jint, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_setScale_I_I__java$math$BigDecimal(jobj)(a0, a1))
    }

    private static let java$math$BigDecimal_setScale_I__java$math$BigDecimal = invoker("setScale", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    public func setScale(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_setScale_I__java$math$BigDecimal(jobj)(a0))
    }

    private static let java$math$BigDecimal_movePointLeft_I__java$math$BigDecimal = invoker("movePointLeft", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    public func movePointLeft(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_movePointLeft_I__java$math$BigDecimal(jobj)(a0))
    }

    private static let java$math$BigDecimal_movePointRight_I__java$math$BigDecimal = invoker("movePointRight", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    public func movePointRight(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_movePointRight_I__java$math$BigDecimal(jobj)(a0))
    }

    private static let java$math$BigDecimal_scaleByPowerOfTen_I__java$math$BigDecimal = invoker("scaleByPowerOfTen", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    public func scaleByPowerOfTen(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_scaleByPowerOfTen_I__java$math$BigDecimal(jobj)(a0))
    }

    private static let java$math$BigDecimal_stripTrailingZeros__java$math$BigDecimal = invoker("stripTrailingZeros", returns: JObjectType("java/math/BigDecimal"))
    public func stripTrailingZeros() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_stripTrailingZeros__java$math$BigDecimal(jobj)())
    }

    private static let java$math$BigDecimal_compareTo_java$math$BigDecimal__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/math/BigDecimal")))
    public func compareTo(a0: java$math$BigDecimal?) throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_compareTo_java$math$BigDecimal__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$math$BigDecimal_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$math$BigDecimal_min_java$math$BigDecimal__java$math$BigDecimal = invoker("min", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func min(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_min_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_max_java$math$BigDecimal__java$math$BigDecimal = invoker("max", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/math/BigDecimal")))
    public func max(a0: java$math$BigDecimal?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_max_java$math$BigDecimal__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigDecimal_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$math$BigDecimal_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$math$BigDecimal_toEngineeringString__java$lang$String = invoker("toEngineeringString", returns: JObjectType("java/lang/String"))
    public func toEngineeringString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$math$BigDecimal$.java$math$BigDecimal_toEngineeringString__java$lang$String(jobj)())
    }

    private static let java$math$BigDecimal_toPlainString__java$lang$String = invoker("toPlainString", returns: JObjectType("java/lang/String"))
    public func toPlainString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$math$BigDecimal$.java$math$BigDecimal_toPlainString__java$lang$String(jobj)())
    }

    private static let java$math$BigDecimal_toBigInteger__java$math$BigInteger = invoker("toBigInteger", returns: JObjectType("java/math/BigInteger"))
    public func toBigInteger() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigDecimal$.java$math$BigDecimal_toBigInteger__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigDecimal_toBigIntegerExact__java$math$BigInteger = invoker("toBigIntegerExact", returns: JObjectType("java/math/BigInteger"))
    public func toBigIntegerExact() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigDecimal$.java$math$BigDecimal_toBigIntegerExact__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigDecimal_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$math$BigDecimal_longValueExact__J = invoker("longValueExact", returns: jlong.jniType)
    public func longValueExact() throws -> jlong {
        return try java$math$BigDecimal$.java$math$BigDecimal_longValueExact__J(jobj)()
    }

    private static let java$math$BigDecimal_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$math$BigDecimal_intValueExact__I = invoker("intValueExact", returns: jint.jniType)
    public func intValueExact() throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_intValueExact__I(jobj)()
    }

    private static let java$math$BigDecimal_shortValueExact__S = invoker("shortValueExact", returns: jshort.jniType)
    public func shortValueExact() throws -> jshort {
        return try java$math$BigDecimal$.java$math$BigDecimal_shortValueExact__S(jobj)()
    }

    private static let java$math$BigDecimal_byteValueExact__B = invoker("byteValueExact", returns: jbyte.jniType)
    public func byteValueExact() throws -> jbyte {
        return try java$math$BigDecimal$.java$math$BigDecimal_byteValueExact__B(jobj)()
    }

    private static let java$math$BigDecimal_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$math$BigDecimal_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$math$BigDecimal_ulp__java$math$BigDecimal = invoker("ulp", returns: JObjectType("java/math/BigDecimal"))
    public func ulp() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$math$BigDecimal$.java$math$BigDecimal_ulp__java$math$BigDecimal(jobj)())
    }

    private static let java$math$BigDecimal_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$math$BigDecimal$.java$math$BigDecimal_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$math$BigDecimal$ = java$math$BigDecimal

public class java$math$BigInteger : java$lang$Number$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$BigInteger_init_AB__V = constructor((JArray(jbyte.jniType)))
    public convenience init!(_ a0: [jbyte]?) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_AB__V(a0?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_init_I_AB__V = constructor((jint.jniType, JArray(jbyte.jniType)))
    public convenience init!(_ a0: jint, _ a1: [jbyte]?) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_I_AB__V(a0, a1?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_init_I_java$util$Random__V = constructor((jint.jniType, JObjectType("java/util/Random")))
    public convenience init!(_ a0: jint, _ a1: java$util$Random?) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_I_java$util$Random__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_init_I_I_java$util$Random__V = constructor((jint.jniType, jint.jniType, JObjectType("java/util/Random")))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: java$util$Random?) throws {
        let jobj = try java$math$BigInteger$.java$math$BigInteger_init_I_I_java$util$Random__V(a0, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$BigInteger_probablePrime_I_java$util$Random__java$math$BigInteger = svoker("probablePrime", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType, JObjectType("java/util/Random")))
    public static func probablePrime(a0: jint, _ a1: java$util$Random?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_probablePrime_I_java$util$Random__java$math$BigInteger(a0, a1?.jobj ?? nil))
    }

    private static let java$math$BigInteger_nextProbablePrime__java$math$BigInteger = invoker("nextProbablePrime", returns: JObjectType("java/math/BigInteger"))
    public func nextProbablePrime() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_nextProbablePrime__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigInteger_valueOf_J__java$math$BigInteger = svoker("valueOf", returns: JObjectType("java/math/BigInteger"), arguments: (jlong.jniType))
    public static func valueOf(a0: jlong) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_valueOf_J__java$math$BigInteger(a0))
    }

    private static let java$math$BigInteger_add_java$math$BigInteger__java$math$BigInteger = invoker("add", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func add(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_add_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_subtract_java$math$BigInteger__java$math$BigInteger = invoker("subtract", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func subtract(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_subtract_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_multiply_java$math$BigInteger__java$math$BigInteger = invoker("multiply", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func multiply(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_multiply_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_divide_java$math$BigInteger__java$math$BigInteger = invoker("divide", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func divide(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_divide_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_divideAndRemainder_java$math$BigInteger__Ajava$math$BigInteger = invoker("divideAndRemainder", returns: JArray(JObjectType("java/math/BigInteger")), arguments: (JObjectType("java/math/BigInteger")))
    public func divideAndRemainder(a0: java$math$BigInteger?) throws -> [java$math$BigInteger?]? {
        return try java$math$BigInteger$.java$math$BigInteger_divideAndRemainder_java$math$BigInteger__Ajava$math$BigInteger(jobj)(a0?.jobj ?? nil).jarrayToArray(java$math$BigInteger$.self)?.map({ $0 as java$math$BigInteger? })
    }

    private static let java$math$BigInteger_remainder_java$math$BigInteger__java$math$BigInteger = invoker("remainder", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func remainder(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_remainder_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_pow_I__java$math$BigInteger = invoker("pow", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func pow(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_pow_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_gcd_java$math$BigInteger__java$math$BigInteger = invoker("gcd", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func gcd(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_gcd_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_abs__java$math$BigInteger = invoker("abs", returns: JObjectType("java/math/BigInteger"))
    public func abs() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_abs__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigInteger_negate__java$math$BigInteger = invoker("negate", returns: JObjectType("java/math/BigInteger"))
    public func negate() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_negate__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigInteger_signum__I = invoker("signum", returns: jint.jniType)
    public func signum() throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_signum__I(jobj)()
    }

    private static let java$math$BigInteger_mod_java$math$BigInteger__java$math$BigInteger = invoker("mod", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func mod(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_mod_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_modPow_java$math$BigInteger_java$math$BigInteger__java$math$BigInteger = invoker("modPow", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger"), JObjectType("java/math/BigInteger")))
    public func modPow(a0: java$math$BigInteger?, _ a1: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_modPow_java$math$BigInteger_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$math$BigInteger_modInverse_java$math$BigInteger__java$math$BigInteger = invoker("modInverse", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func modInverse(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_modInverse_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_shiftLeft_I__java$math$BigInteger = invoker("shiftLeft", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func shiftLeft(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_shiftLeft_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_shiftRight_I__java$math$BigInteger = invoker("shiftRight", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func shiftRight(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_shiftRight_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_and_java$math$BigInteger__java$math$BigInteger = invoker("and", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func and(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_and_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_or_java$math$BigInteger__java$math$BigInteger = invoker("or", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func or(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_or_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_xor_java$math$BigInteger__java$math$BigInteger = invoker("xor", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func xor(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_xor_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_not__java$math$BigInteger = invoker("not", returns: JObjectType("java/math/BigInteger"))
    public func not() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_not__java$math$BigInteger(jobj)())
    }

    private static let java$math$BigInteger_andNot_java$math$BigInteger__java$math$BigInteger = invoker("andNot", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func andNot(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_andNot_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_testBit_I__Z = invoker("testBit", returns: jboolean.jniType, arguments: (jint.jniType))
    public func testBit(a0: jint) throws -> jboolean {
        return try java$math$BigInteger$.java$math$BigInteger_testBit_I__Z(jobj)(a0)
    }

    private static let java$math$BigInteger_setBit_I__java$math$BigInteger = invoker("setBit", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func setBit(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_setBit_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_clearBit_I__java$math$BigInteger = invoker("clearBit", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func clearBit(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_clearBit_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_flipBit_I__java$math$BigInteger = invoker("flipBit", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func flipBit(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_flipBit_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$math$BigInteger_getLowestSetBit__I = invoker("getLowestSetBit", returns: jint.jniType)
    public func getLowestSetBit() throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_getLowestSetBit__I(jobj)()
    }

    private static let java$math$BigInteger_bitLength__I = invoker("bitLength", returns: jint.jniType)
    public func bitLength() throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_bitLength__I(jobj)()
    }

    private static let java$math$BigInteger_bitCount__I = invoker("bitCount", returns: jint.jniType)
    public func bitCount() throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_bitCount__I(jobj)()
    }

    private static let java$math$BigInteger_isProbablePrime_I__Z = invoker("isProbablePrime", returns: jboolean.jniType, arguments: (jint.jniType))
    public func isProbablePrime(a0: jint) throws -> jboolean {
        return try java$math$BigInteger$.java$math$BigInteger_isProbablePrime_I__Z(jobj)(a0)
    }

    private static let java$math$BigInteger_compareTo_java$math$BigInteger__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/math/BigInteger")))
    public func compareTo(a0: java$math$BigInteger?) throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_compareTo_java$math$BigInteger__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$math$BigInteger_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$math$BigInteger_min_java$math$BigInteger__java$math$BigInteger = invoker("min", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func min(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_min_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_max_java$math$BigInteger__java$math$BigInteger = invoker("max", returns: JObjectType("java/math/BigInteger"), arguments: (JObjectType("java/math/BigInteger")))
    public func max(a0: java$math$BigInteger?) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$math$BigInteger$.java$math$BigInteger_max_java$math$BigInteger__java$math$BigInteger(jobj)(a0?.jobj ?? nil))
    }

    private static let java$math$BigInteger_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$math$BigInteger_toString_I__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func toString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$math$BigInteger$.java$math$BigInteger_toString_I__java$lang$String(jobj)(a0))
    }

    private static let java$math$BigInteger_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$math$BigInteger_toByteArray__AB = invoker("toByteArray", returns: JArray(jbyte.jniType))
    public func toByteArray() throws -> [jbyte]? {
        return try java$math$BigInteger$.java$math$BigInteger_toByteArray__AB(jobj)().jarrayToArray()
    }

    private static let java$math$BigInteger_intValue__I = invoker("intValue", returns: jint.jniType)
    private static let java$math$BigInteger_longValue__J = invoker("longValue", returns: jlong.jniType)
    private static let java$math$BigInteger_floatValue__F = invoker("floatValue", returns: jfloat.jniType)
    private static let java$math$BigInteger_doubleValue__D = invoker("doubleValue", returns: jdouble.jniType)
    private static let java$math$BigInteger_longValueExact__J = invoker("longValueExact", returns: jlong.jniType)
    public func longValueExact() throws -> jlong {
        return try java$math$BigInteger$.java$math$BigInteger_longValueExact__J(jobj)()
    }

    private static let java$math$BigInteger_intValueExact__I = invoker("intValueExact", returns: jint.jniType)
    public func intValueExact() throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_intValueExact__I(jobj)()
    }

    private static let java$math$BigInteger_shortValueExact__S = invoker("shortValueExact", returns: jshort.jniType)
    public func shortValueExact() throws -> jshort {
        return try java$math$BigInteger$.java$math$BigInteger_shortValueExact__S(jobj)()
    }

    private static let java$math$BigInteger_byteValueExact__B = invoker("byteValueExact", returns: jbyte.jniType)
    public func byteValueExact() throws -> jbyte {
        return try java$math$BigInteger$.java$math$BigInteger_byteValueExact__B(jobj)()
    }

    private static let java$math$BigInteger_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$math$BigInteger$.java$math$BigInteger_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$math$BigInteger$ = java$math$BigInteger

public class java$math$BitSieve : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$math$BitSieve$ = java$math$BitSieve

public final class java$math$MathContext : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$MathContext_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$math$MathContext$.java$math$MathContext_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$math$MathContext_init_I_java$math$RoundingMode__V = constructor((jint.jniType, JObjectType("java/math/RoundingMode")))
    public convenience init!(_ a0: jint, _ a1: java$math$RoundingMode?) throws {
        let jobj = try java$math$MathContext$.java$math$MathContext_init_I_java$math$RoundingMode__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$MathContext_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$math$MathContext$.java$math$MathContext_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$math$MathContext_getPrecision__I = invoker("getPrecision", returns: jint.jniType)
    public func getPrecision() throws -> jint {
        return try java$math$MathContext$.java$math$MathContext_getPrecision__I(jobj)()
    }

    private static let java$math$MathContext_getRoundingMode__java$math$RoundingMode = invoker("getRoundingMode", returns: JObjectType("java/math/RoundingMode"))
    public func getRoundingMode() throws -> java$math$RoundingMode? {
        return try java$math$RoundingMode$(jobj: java$math$MathContext$.java$math$MathContext_getRoundingMode__java$math$RoundingMode(jobj)())
    }

    private static let java$math$MathContext_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$math$MathContext_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$math$MathContext_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$math$MathContext$ = java$math$MathContext

public class java$math$MutableBigInteger : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$MutableBigInteger_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$math$MutableBigInteger$ = java$math$MutableBigInteger

public final class java$math$RoundingMode : java$lang$Enum$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$RoundingMode_values__Ajava$math$RoundingMode = svoker("values", returns: JArray(JObjectType("java/math/RoundingMode")))
    public static func values() throws -> [java$math$RoundingMode?]? {
        return try java$math$RoundingMode$.java$math$RoundingMode_values__Ajava$math$RoundingMode().jarrayToArray(java$math$RoundingMode$.self)?.map({ $0 as java$math$RoundingMode? })
    }

    private static let java$math$RoundingMode_valueOf_java$lang$String__java$math$RoundingMode = svoker("valueOf", returns: JObjectType("java/math/RoundingMode"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$math$RoundingMode? {
        return try java$math$RoundingMode$(jobj: java$math$RoundingMode$.java$math$RoundingMode_valueOf_java$lang$String__java$math$RoundingMode(a0?.jobj ?? nil))
    }

    private static let java$math$RoundingMode_valueOf_I__java$math$RoundingMode = svoker("valueOf", returns: JObjectType("java/math/RoundingMode"), arguments: (jint.jniType))
    public static func valueOf(a0: jint) throws -> java$math$RoundingMode? {
        return try java$math$RoundingMode$(jobj: java$math$RoundingMode$.java$math$RoundingMode_valueOf_I__java$math$RoundingMode(a0))
    }

}

public typealias java$math$RoundingMode$ = java$math$RoundingMode

public class java$math$SignedMutableBigInteger : java$math$MutableBigInteger$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$math$SignedMutableBigInteger_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$math$SignedMutableBigInteger$ = java$math$SignedMutableBigInteger

public class java$net$AbstractPlainDatagramSocketImpl : java$net$DatagramSocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$AbstractPlainDatagramSocketImpl_setOption_I_java$lang$Object__V = invoker("setOption", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public func setOption(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$net$AbstractPlainDatagramSocketImpl$.java$net$AbstractPlainDatagramSocketImpl_setOption_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$net$AbstractPlainDatagramSocketImpl_getOption_I__java$lang$Object = invoker("getOption", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    public func getOption(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$AbstractPlainDatagramSocketImpl$.java$net$AbstractPlainDatagramSocketImpl_getOption_I__java$lang$Object(jobj)(a0))
    }

}

public typealias java$net$AbstractPlainDatagramSocketImpl$ = java$net$AbstractPlainDatagramSocketImpl

public class java$net$AbstractPlainSocketImpl : java$net$SocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$AbstractPlainSocketImpl_setOption_I_java$lang$Object__V = invoker("setOption", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public func setOption(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_setOption_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$net$AbstractPlainSocketImpl_getOption_I__java$lang$Object = invoker("getOption", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    public func getOption(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_getOption_I__java$lang$Object(jobj)(a0))
    }

    private static let java$net$AbstractPlainSocketImpl_isConnectionReset__Z = invoker("isConnectionReset", returns: jboolean.jniType)
    public func isConnectionReset() throws -> jboolean {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_isConnectionReset__Z(jobj)()
    }

    private static let java$net$AbstractPlainSocketImpl_isConnectionResetPending__Z = invoker("isConnectionResetPending", returns: jboolean.jniType)
    public func isConnectionResetPending() throws -> jboolean {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_isConnectionResetPending__Z(jobj)()
    }

    private static let java$net$AbstractPlainSocketImpl_setConnectionReset__V = invoker("setConnectionReset", returns: JVoid.jniType)
    public func setConnectionReset() throws -> Void {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_setConnectionReset__V(jobj)()
    }

    private static let java$net$AbstractPlainSocketImpl_setConnectionResetPending__V = invoker("setConnectionResetPending", returns: JVoid.jniType)
    public func setConnectionResetPending() throws -> Void {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_setConnectionResetPending__V(jobj)()
    }

    private static let java$net$AbstractPlainSocketImpl_isClosedOrPending__Z = invoker("isClosedOrPending", returns: jboolean.jniType)
    public func isClosedOrPending() throws -> jboolean {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_isClosedOrPending__Z(jobj)()
    }

    private static let java$net$AbstractPlainSocketImpl_getTimeout__I = invoker("getTimeout", returns: jint.jniType)
    public func getTimeout() throws -> jint {
        return try java$net$AbstractPlainSocketImpl$.java$net$AbstractPlainSocketImpl_getTimeout__I(jobj)()
    }

}

public typealias java$net$AbstractPlainSocketImpl$ = java$net$AbstractPlainSocketImpl

public class java$net$Authenticator : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Authenticator_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$Authenticator$.java$net$Authenticator_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$Authenticator_setDefault_java$net$Authenticator__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/net/Authenticator")))
    public static func setDefault(a0: java$net$Authenticator?) throws -> Void {
        return try java$net$Authenticator$.java$net$Authenticator_setDefault_java$net$Authenticator__V(a0?.jobj ?? nil)
    }

    private static let java$net$Authenticator_requestPasswordAuthentication_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String__java$net$PasswordAuthentication = svoker("requestPasswordAuthentication", returns: JObjectType("java/net/PasswordAuthentication"), arguments: (JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func requestPasswordAuthentication(a0: java$net$InetAddress?, _ a1: jint, _ a2: java$lang$String?, _ a3: java$lang$String?, _ a4: java$lang$String?) throws -> java$net$PasswordAuthentication? {
        return try java$net$PasswordAuthentication$(jobj: java$net$Authenticator$.java$net$Authenticator_requestPasswordAuthentication_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String__java$net$PasswordAuthentication(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3?.jobj ?? nil, a4?.jobj ?? nil))
    }

    private static let java$net$Authenticator_requestPasswordAuthentication_java$lang$String_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String__java$net$PasswordAuthentication = svoker("requestPasswordAuthentication", returns: JObjectType("java/net/PasswordAuthentication"), arguments: (JObjectType("java/lang/String"), JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func requestPasswordAuthentication(a0: java$lang$String?, _ a1: java$net$InetAddress?, _ a2: jint, _ a3: java$lang$String?, _ a4: java$lang$String?, _ a5: java$lang$String?) throws -> java$net$PasswordAuthentication? {
        return try java$net$PasswordAuthentication$(jobj: java$net$Authenticator$.java$net$Authenticator_requestPasswordAuthentication_java$lang$String_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String__java$net$PasswordAuthentication(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil, a4?.jobj ?? nil, a5?.jobj ?? nil))
    }

    private static let java$net$Authenticator_requestPasswordAuthentication_java$lang$String_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String_java$net$URL_java$net$Authenticator$RequestorType__java$net$PasswordAuthentication = svoker("requestPasswordAuthentication", returns: JObjectType("java/net/PasswordAuthentication"), arguments: (JObjectType("java/lang/String"), JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/net/URL"), JObjectType("java/net/Authenticator$RequestorType")))
    public static func requestPasswordAuthentication(a0: java$lang$String?, _ a1: java$net$InetAddress?, _ a2: jint, _ a3: java$lang$String?, _ a4: java$lang$String?, _ a5: java$lang$String?, _ a6: java$net$URL?, _ a7: java$net$Authenticator$RequestorType?) throws -> java$net$PasswordAuthentication? {
        return try java$net$PasswordAuthentication$(jobj: java$net$Authenticator$.java$net$Authenticator_requestPasswordAuthentication_java$lang$String_java$net$InetAddress_I_java$lang$String_java$lang$String_java$lang$String_java$net$URL_java$net$Authenticator$RequestorType__java$net$PasswordAuthentication(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil, a4?.jobj ?? nil, a5?.jobj ?? nil, a6?.jobj ?? nil, a7?.jobj ?? nil))
    }

}

public typealias java$net$Authenticator$ = java$net$Authenticator

public class java$net$BindException : java$net$SocketException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$BindException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$BindException$.java$net$BindException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$BindException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$BindException$.java$net$BindException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$BindException$ = java$net$BindException

public class java$net$CacheRequest : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CacheRequest_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$CacheRequest$.java$net$CacheRequest_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$CacheRequest_getBody__java$io$OutputStream = invoker("getBody", returns: JObjectType("java/io/OutputStream"))
    public func getBody() throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$net$CacheRequest$.java$net$CacheRequest_getBody__java$io$OutputStream(jobj)())
    }

    private static let java$net$CacheRequest_abort__V = invoker("abort", returns: JVoid.jniType)
    public func abort() throws -> Void {
        return try java$net$CacheRequest$.java$net$CacheRequest_abort__V(jobj)()
    }

}

public typealias java$net$CacheRequest$ = java$net$CacheRequest

public class java$net$CacheResponse : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CacheResponse_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$CacheResponse$.java$net$CacheResponse_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$CacheResponse_getHeaders__java$util$Map = invoker("getHeaders", returns: JObjectType("java/util/Map"))
    public func getHeaders() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$net$CacheResponse$.java$net$CacheResponse_getHeaders__java$util$Map(jobj)())
    }

    private static let java$net$CacheResponse_getBody__java$io$InputStream = invoker("getBody", returns: JObjectType("java/io/InputStream"))
    public func getBody() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$net$CacheResponse$.java$net$CacheResponse_getBody__java$io$InputStream(jobj)())
    }

}

public typealias java$net$CacheResponse$ = java$net$CacheResponse

public class java$net$ConnectException : java$net$SocketException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ConnectException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$ConnectException$.java$net$ConnectException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$ConnectException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ConnectException$.java$net$ConnectException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$ConnectException$ = java$net$ConnectException

public class java$net$ContentHandler : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ContentHandler_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ContentHandler$.java$net$ContentHandler_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$ContentHandler_getContent_java$net$URLConnection__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/net/URLConnection")))
    public func getContent(a0: java$net$URLConnection?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$ContentHandler$.java$net$ContentHandler_getContent_java$net$URLConnection__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$ContentHandler_getContent_java$net$URLConnection_Ajava$lang$Class__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/net/URLConnection"), JArray(JObjectType("java/lang/Class"))))
    public func getContent(a0: java$net$URLConnection?, _ a1: [java$lang$Class?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$ContentHandler$.java$net$ContentHandler_getContent_java$net$URLConnection_Ajava$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

}

public typealias java$net$ContentHandler$ = java$net$ContentHandler

public protocol java$net$ContentHandlerFactory : JavaObject {
    func createContentHandler(a0: java$lang$String?) throws -> java$net$ContentHandler?
}

public class java$net$ContentHandlerFactory$ : java$lang$Object$, java$net$ContentHandlerFactory {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ContentHandlerFactory_createContentHandler_java$lang$String__java$net$ContentHandler = invoker("createContentHandler", returns: JObjectType("java/net/ContentHandler"), arguments: (JObjectType("java/lang/String")))
}

public extension java$net$ContentHandlerFactory {
    func createContentHandler(a0: java$lang$String?) throws -> java$net$ContentHandler? {
        return try java$net$ContentHandler$(jobj: java$net$ContentHandlerFactory$.java$net$ContentHandlerFactory_createContentHandler_java$lang$String__java$net$ContentHandler(jobj)(a0?.jobj ?? nil))
    }

}

public class java$net$CookieHandler : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CookieHandler_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$CookieHandler$.java$net$CookieHandler_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$CookieHandler_getDefault__java$net$CookieHandler = svoker("getDefault", returns: JObjectType("java/net/CookieHandler"))
    public static func getDefault() throws -> java$net$CookieHandler? {
        return try java$net$CookieHandler$(jobj: java$net$CookieHandler$.java$net$CookieHandler_getDefault__java$net$CookieHandler())
    }

    private static let java$net$CookieHandler_setDefault_java$net$CookieHandler__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/net/CookieHandler")))
    public static func setDefault(a0: java$net$CookieHandler?) throws -> Void {
        return try java$net$CookieHandler$.java$net$CookieHandler_setDefault_java$net$CookieHandler__V(a0?.jobj ?? nil)
    }

    private static let java$net$CookieHandler_get_java$net$URI_java$util$Map__java$util$Map = invoker("get", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/net/URI"), JObjectType("java/util/Map")))
    public func get(a0: java$net$URI?, _ a1: java$util$Map?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$net$CookieHandler$.java$net$CookieHandler_get_java$net$URI_java$util$Map__java$util$Map(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$net$CookieHandler_put_java$net$URI_java$util$Map__V = invoker("put", returns: JVoid.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/util/Map")))
    public func put(a0: java$net$URI?, _ a1: java$util$Map?) throws -> Void {
        return try java$net$CookieHandler$.java$net$CookieHandler_put_java$net$URI_java$util$Map__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public typealias java$net$CookieHandler$ = java$net$CookieHandler

public class java$net$CookieManager : java$net$CookieHandler$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CookieManager_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$CookieManager$.java$net$CookieManager_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$CookieManager_init_java$net$CookieStore_java$net$CookiePolicy__V = constructor((JObjectType("java/net/CookieStore"), JObjectType("java/net/CookiePolicy")))
    public convenience init!(_ a0: java$net$CookieStore?, _ a1: java$net$CookiePolicy?) throws {
        let jobj = try java$net$CookieManager$.java$net$CookieManager_init_java$net$CookieStore_java$net$CookiePolicy__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$CookieManager_setCookiePolicy_java$net$CookiePolicy__V = invoker("setCookiePolicy", returns: JVoid.jniType, arguments: (JObjectType("java/net/CookiePolicy")))
    public func setCookiePolicy(a0: java$net$CookiePolicy?) throws -> Void {
        return try java$net$CookieManager$.java$net$CookieManager_setCookiePolicy_java$net$CookiePolicy__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$CookieManager_getCookieStore__java$net$CookieStore = invoker("getCookieStore", returns: JObjectType("java/net/CookieStore"))
    public func getCookieStore() throws -> java$net$CookieStore? {
        return try java$net$CookieStore$(jobj: java$net$CookieManager$.java$net$CookieManager_getCookieStore__java$net$CookieStore(jobj)())
    }

    private static let java$net$CookieManager_get_java$net$URI_java$util$Map__java$util$Map = invoker("get", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/net/URI"), JObjectType("java/util/Map")))
    private static let java$net$CookieManager_put_java$net$URI_java$util$Map__V = invoker("put", returns: JVoid.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/util/Map")))
}

public typealias java$net$CookieManager$ = java$net$CookieManager

public protocol java$net$CookiePolicy : JavaObject {
    func shouldAccept(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> jboolean
}

public class java$net$CookiePolicy$ : java$lang$Object$, java$net$CookiePolicy {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CookiePolicy_shouldAccept_java$net$URI_java$net$HttpCookie__Z = invoker("shouldAccept", returns: jboolean.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/HttpCookie")))
}

public extension java$net$CookiePolicy {
    func shouldAccept(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> jboolean {
        return try java$net$CookiePolicy$.java$net$CookiePolicy_shouldAccept_java$net$URI_java$net$HttpCookie__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public protocol java$net$CookieStore : JavaObject {
    func add(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> Void
    func get(a0: java$net$URI?) throws -> java$util$List?
    func getCookies() throws -> java$util$List?
    func getURIs() throws -> java$util$List?
    func remove(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> jboolean
    func removeAll() throws -> jboolean
}

public class java$net$CookieStore$ : java$lang$Object$, java$net$CookieStore {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$CookieStore_add_java$net$URI_java$net$HttpCookie__V = invoker("add", returns: JVoid.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/HttpCookie")))
    private static let java$net$CookieStore_get_java$net$URI__java$util$List = invoker("get", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/net/URI")))
    private static let java$net$CookieStore_getCookies__java$util$List = invoker("getCookies", returns: JObjectType("java/util/List"))
    private static let java$net$CookieStore_getURIs__java$util$List = invoker("getURIs", returns: JObjectType("java/util/List"))
    private static let java$net$CookieStore_remove_java$net$URI_java$net$HttpCookie__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/HttpCookie")))
    private static let java$net$CookieStore_removeAll__Z = invoker("removeAll", returns: jboolean.jniType)
}

public extension java$net$CookieStore {
    func add(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> Void {
        return try java$net$CookieStore$.java$net$CookieStore_add_java$net$URI_java$net$HttpCookie__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func get(a0: java$net$URI?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$CookieStore$.java$net$CookieStore_get_java$net$URI__java$util$List(jobj)(a0?.jobj ?? nil))
    }

    func getCookies() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$CookieStore$.java$net$CookieStore_getCookies__java$util$List(jobj)())
    }

    func getURIs() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$CookieStore$.java$net$CookieStore_getURIs__java$util$List(jobj)())
    }

    func remove(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> jboolean {
        return try java$net$CookieStore$.java$net$CookieStore_remove_java$net$URI_java$net$HttpCookie__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func removeAll() throws -> jboolean {
        return try java$net$CookieStore$.java$net$CookieStore_removeAll__Z(jobj)()
    }

}

public final class java$net$DatagramPacket : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$DatagramPacket_init_AB_I_I__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_init_AB_I__V = constructor((JArray(jbyte.jniType), jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I__V(a0?.arrayToJArray() ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_init_AB_I_I_java$net$InetAddress_I__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType, JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: java$net$InetAddress?, _ a4: jint) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I_I_java$net$InetAddress_I__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil, a4)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_init_AB_I_I_java$net$SocketAddress__V = constructor((JArray(jbyte.jniType), jint.jniType, jint.jniType, JObjectType("java/net/SocketAddress")))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: java$net$SocketAddress?) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I_I_java$net$SocketAddress__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_init_AB_I_java$net$InetAddress_I__V = constructor((JArray(jbyte.jniType), jint.jniType, JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: java$net$InetAddress?, _ a3: jint) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I_java$net$InetAddress_I__V(a0?.arrayToJArray() ?? nil, a1, a2?.jobj ?? nil, a3)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_init_AB_I_java$net$SocketAddress__V = constructor((JArray(jbyte.jniType), jint.jniType, JObjectType("java/net/SocketAddress")))
    public convenience init!(_ a0: [jbyte]?, _ a1: jint, _ a2: java$net$SocketAddress?) throws {
        let jobj = try java$net$DatagramPacket$.java$net$DatagramPacket_init_AB_I_java$net$SocketAddress__V(a0?.arrayToJArray() ?? nil, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramPacket_getAddress__java$net$InetAddress = invoker("getAddress", returns: JObjectType("java/net/InetAddress"))
    public func getAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$DatagramPacket$.java$net$DatagramPacket_getAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$DatagramPacket_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_getPort__I(jobj)()
    }

    private static let java$net$DatagramPacket_getData__AB = invoker("getData", returns: JArray(jbyte.jniType))
    public func getData() throws -> [jbyte]? {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_getData__AB(jobj)().jarrayToArray()
    }

    private static let java$net$DatagramPacket_getOffset__I = invoker("getOffset", returns: jint.jniType)
    public func getOffset() throws -> jint {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_getOffset__I(jobj)()
    }

    private static let java$net$DatagramPacket_getLength__I = invoker("getLength", returns: jint.jniType)
    public func getLength() throws -> jint {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_getLength__I(jobj)()
    }

    private static let java$net$DatagramPacket_setData_AB_I_I__V = invoker("setData", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public func setData(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setData_AB_I_I__V(jobj)(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$net$DatagramPacket_setAddress_java$net$InetAddress__V = invoker("setAddress", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress")))
    public func setAddress(a0: java$net$InetAddress?) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setAddress_java$net$InetAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramPacket_setPort_I__V = invoker("setPort", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setPort(a0: jint) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setPort_I__V(jobj)(a0)
    }

    private static let java$net$DatagramPacket_setSocketAddress_java$net$SocketAddress__V = invoker("setSocketAddress", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func setSocketAddress(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setSocketAddress_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramPacket_getSocketAddress__java$net$SocketAddress = invoker("getSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$DatagramPacket$.java$net$DatagramPacket_getSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$DatagramPacket_setData_AB__V = invoker("setData", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func setData(a0: [jbyte]?) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setData_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$net$DatagramPacket_setLength_I__V = invoker("setLength", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setLength(a0: jint) throws -> Void {
        return try java$net$DatagramPacket$.java$net$DatagramPacket_setLength_I__V(jobj)(a0)
    }

}

public typealias java$net$DatagramPacket$ = java$net$DatagramPacket

public class java$net$DatagramSocket : java$lang$Object$, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$DatagramSocket_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$DatagramSocket$.java$net$DatagramSocket_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramSocket_init_java$net$SocketAddress__V = constructor((JObjectType("java/net/SocketAddress")))
    public convenience init!(_ a0: java$net$SocketAddress?) throws {
        let jobj = try java$net$DatagramSocket$.java$net$DatagramSocket_init_java$net$SocketAddress__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramSocket_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$net$DatagramSocket$.java$net$DatagramSocket_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramSocket_init_I_java$net$InetAddress__V = constructor((jint.jniType, JObjectType("java/net/InetAddress")))
    public convenience init!(_ a0: jint, _ a1: java$net$InetAddress?) throws {
        let jobj = try java$net$DatagramSocket$.java$net$DatagramSocket_init_I_java$net$InetAddress__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$DatagramSocket_bind_java$net$SocketAddress__V = invoker("bind", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func bind(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_bind_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramSocket_connect_java$net$InetAddress_I__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress"), jint.jniType))
    public func connect(a0: java$net$InetAddress?, _ a1: jint) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_connect_java$net$InetAddress_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$DatagramSocket_connect_java$net$SocketAddress__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func connect(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_connect_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramSocket_disconnect__V = invoker("disconnect", returns: JVoid.jniType)
    public func disconnect() throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_disconnect__V(jobj)()
    }

    private static let java$net$DatagramSocket_isBound__Z = invoker("isBound", returns: jboolean.jniType)
    public func isBound() throws -> jboolean {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_isBound__Z(jobj)()
    }

    private static let java$net$DatagramSocket_isConnected__Z = invoker("isConnected", returns: jboolean.jniType)
    public func isConnected() throws -> jboolean {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_isConnected__Z(jobj)()
    }

    private static let java$net$DatagramSocket_getInetAddress__java$net$InetAddress = invoker("getInetAddress", returns: JObjectType("java/net/InetAddress"))
    public func getInetAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$DatagramSocket$.java$net$DatagramSocket_getInetAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$DatagramSocket_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getPort__I(jobj)()
    }

    private static let java$net$DatagramSocket_getRemoteSocketAddress__java$net$SocketAddress = invoker("getRemoteSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getRemoteSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$DatagramSocket$.java$net$DatagramSocket_getRemoteSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$DatagramSocket_getLocalSocketAddress__java$net$SocketAddress = invoker("getLocalSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getLocalSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$DatagramSocket$.java$net$DatagramSocket_getLocalSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$DatagramSocket_send_java$net$DatagramPacket__V = invoker("send", returns: JVoid.jniType, arguments: (JObjectType("java/net/DatagramPacket")))
    public func send(a0: java$net$DatagramPacket?) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_send_java$net$DatagramPacket__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramSocket_receive_java$net$DatagramPacket__V = invoker("receive", returns: JVoid.jniType, arguments: (JObjectType("java/net/DatagramPacket")))
    public func receive(a0: java$net$DatagramPacket?) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_receive_java$net$DatagramPacket__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$DatagramSocket_getLocalAddress__java$net$InetAddress = invoker("getLocalAddress", returns: JObjectType("java/net/InetAddress"))
    public func getLocalAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$DatagramSocket$.java$net$DatagramSocket_getLocalAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$DatagramSocket_getLocalPort__I = invoker("getLocalPort", returns: jint.jniType)
    public func getLocalPort() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getLocalPort__I(jobj)()
    }

    private static let java$net$DatagramSocket_setSoTimeout_I__V = invoker("setSoTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSoTimeout(a0: jint) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setSoTimeout_I__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getSoTimeout__I = invoker("getSoTimeout", returns: jint.jniType)
    public func getSoTimeout() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getSoTimeout__I(jobj)()
    }

    private static let java$net$DatagramSocket_setSendBufferSize_I__V = invoker("setSendBufferSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSendBufferSize(a0: jint) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setSendBufferSize_I__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getSendBufferSize__I = invoker("getSendBufferSize", returns: jint.jniType)
    public func getSendBufferSize() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getSendBufferSize__I(jobj)()
    }

    private static let java$net$DatagramSocket_setReceiveBufferSize_I__V = invoker("setReceiveBufferSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setReceiveBufferSize(a0: jint) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setReceiveBufferSize_I__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getReceiveBufferSize__I = invoker("getReceiveBufferSize", returns: jint.jniType)
    public func getReceiveBufferSize() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getReceiveBufferSize__I(jobj)()
    }

    private static let java$net$DatagramSocket_setReuseAddress_Z__V = invoker("setReuseAddress", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setReuseAddress(a0: jboolean) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setReuseAddress_Z__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getReuseAddress__Z = invoker("getReuseAddress", returns: jboolean.jniType)
    public func getReuseAddress() throws -> jboolean {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getReuseAddress__Z(jobj)()
    }

    private static let java$net$DatagramSocket_setBroadcast_Z__V = invoker("setBroadcast", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setBroadcast(a0: jboolean) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setBroadcast_Z__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getBroadcast__Z = invoker("getBroadcast", returns: jboolean.jniType)
    public func getBroadcast() throws -> jboolean {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getBroadcast__Z(jobj)()
    }

    private static let java$net$DatagramSocket_setTrafficClass_I__V = invoker("setTrafficClass", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setTrafficClass(a0: jint) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setTrafficClass_I__V(jobj)(a0)
    }

    private static let java$net$DatagramSocket_getTrafficClass__I = invoker("getTrafficClass", returns: jint.jniType)
    public func getTrafficClass() throws -> jint {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_getTrafficClass__I(jobj)()
    }

    private static let java$net$DatagramSocket_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_close__V(jobj)()
    }

    private static let java$net$DatagramSocket_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    public func isClosed() throws -> jboolean {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_isClosed__Z(jobj)()
    }

    private static let java$net$DatagramSocket_getChannel__java$nio$channels$DatagramChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/DatagramChannel"))
    public func getChannel() throws -> java$nio$channels$DatagramChannel? {
        return try java$nio$channels$DatagramChannel$(jobj: java$net$DatagramSocket$.java$net$DatagramSocket_getChannel__java$nio$channels$DatagramChannel(jobj)())
    }

    private static let java$net$DatagramSocket_setDatagramSocketImplFactory_java$net$DatagramSocketImplFactory__V = svoker("setDatagramSocketImplFactory", returns: JVoid.jniType, arguments: (JObjectType("java/net/DatagramSocketImplFactory")))
    public static func setDatagramSocketImplFactory(a0: java$net$DatagramSocketImplFactory?) throws -> Void {
        return try java$net$DatagramSocket$.java$net$DatagramSocket_setDatagramSocketImplFactory_java$net$DatagramSocketImplFactory__V(a0?.jobj ?? nil)
    }

}

public typealias java$net$DatagramSocket$ = java$net$DatagramSocket

public class java$net$DatagramSocketImpl : java$lang$Object$, java$net$SocketOptions {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$DatagramSocketImpl_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$DatagramSocketImpl$.java$net$DatagramSocketImpl_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$DatagramSocketImpl$ = java$net$DatagramSocketImpl

public protocol java$net$DatagramSocketImplFactory : JavaObject {
    func createDatagramSocketImpl() throws -> java$net$DatagramSocketImpl?
}

public class java$net$DatagramSocketImplFactory$ : java$lang$Object$, java$net$DatagramSocketImplFactory {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$DatagramSocketImplFactory_createDatagramSocketImpl__java$net$DatagramSocketImpl = invoker("createDatagramSocketImpl", returns: JObjectType("java/net/DatagramSocketImpl"))
}

public extension java$net$DatagramSocketImplFactory {
    func createDatagramSocketImpl() throws -> java$net$DatagramSocketImpl? {
        return try java$net$DatagramSocketImpl$(jobj: java$net$DatagramSocketImplFactory$.java$net$DatagramSocketImplFactory_createDatagramSocketImpl__java$net$DatagramSocketImpl(jobj)())
    }

}

public class java$net$DefaultDatagramSocketImplFactory : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$DefaultDatagramSocketImplFactory$ = java$net$DefaultDatagramSocketImplFactory

public class java$net$DefaultInterface : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$DefaultInterface$ = java$net$DefaultInterface

public final class java$net$FactoryURLClassLoader : java$net$URLClassLoader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$FactoryURLClassLoader_loadClass_java$lang$String_Z__java$lang$Class = invoker("loadClass", returns: JObjectType("java/lang/Class"), arguments: (JObjectType("java/lang/String"), jboolean.jniType))
    public func loadClass(a0: java$lang$String?, _ a1: jboolean) throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$net$FactoryURLClassLoader$.java$net$FactoryURLClassLoader_loadClass_java$lang$String_Z__java$lang$Class(jobj)(a0?.jobj ?? nil, a1))
    }

}

public typealias java$net$FactoryURLClassLoader$ = java$net$FactoryURLClassLoader

public protocol java$net$FileNameMap : JavaObject {
    func getContentTypeFor(a0: java$lang$String?) throws -> java$lang$String?
}

public class java$net$FileNameMap$ : java$lang$Object$, java$net$FileNameMap {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$FileNameMap_getContentTypeFor_java$lang$String__java$lang$String = invoker("getContentTypeFor", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
}

public extension java$net$FileNameMap {
    func getContentTypeFor(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$FileNameMap$.java$net$FileNameMap_getContentTypeFor_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

}

public class java$net$HostPortrange : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$HostPortrange_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$HostPortrange_literal__Z = invoker("literal", returns: jboolean.jniType)
    public func literal() throws -> jboolean {
        return try java$net$HostPortrange$.java$net$HostPortrange_literal__Z(jobj)()
    }

    private static let java$net$HostPortrange_ipv4Literal__Z = invoker("ipv4Literal", returns: jboolean.jniType)
    public func ipv4Literal() throws -> jboolean {
        return try java$net$HostPortrange$.java$net$HostPortrange_ipv4Literal__Z(jobj)()
    }

    private static let java$net$HostPortrange_ipv6Literal__Z = invoker("ipv6Literal", returns: jboolean.jniType)
    public func ipv6Literal() throws -> jboolean {
        return try java$net$HostPortrange$.java$net$HostPortrange_ipv6Literal__Z(jobj)()
    }

    private static let java$net$HostPortrange_hostname__java$lang$String = invoker("hostname", returns: JObjectType("java/lang/String"))
    public func hostname() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HostPortrange$.java$net$HostPortrange_hostname__java$lang$String(jobj)())
    }

    private static let java$net$HostPortrange_portrange__AI = invoker("portrange", returns: JArray(jint.jniType))
    public func portrange() throws -> [jint]? {
        return try java$net$HostPortrange$.java$net$HostPortrange_portrange__AI(jobj)().jarrayToArray()
    }

    private static let java$net$HostPortrange_wildcard__Z = invoker("wildcard", returns: jboolean.jniType)
    public func wildcard() throws -> jboolean {
        return try java$net$HostPortrange$.java$net$HostPortrange_wildcard__Z(jobj)()
    }

}

public typealias java$net$HostPortrange$ = java$net$HostPortrange

public class java$net$HttpConnectSocketImpl : java$net$PlainSocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$HttpConnectSocketImpl_setOption_I_java$lang$Object__V = invoker("setOption", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
}

public typealias java$net$HttpConnectSocketImpl$ = java$net$HttpConnectSocketImpl

public final class java$net$HttpCookie : java$lang$Object$, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$HttpCookie_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$net$HttpCookie$.java$net$HttpCookie_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$HttpCookie_parse_java$lang$String__java$util$List = svoker("parse", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/lang/String")))
    public static func parse(a0: java$lang$String?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$HttpCookie$.java$net$HttpCookie_parse_java$lang$String__java$util$List(a0?.jobj ?? nil))
    }

    private static let java$net$HttpCookie_hasExpired__Z = invoker("hasExpired", returns: jboolean.jniType)
    public func hasExpired() throws -> jboolean {
        return try java$net$HttpCookie$.java$net$HttpCookie_hasExpired__Z(jobj)()
    }

    private static let java$net$HttpCookie_setComment_java$lang$String__V = invoker("setComment", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setComment(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setComment_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getComment__java$lang$String = invoker("getComment", returns: JObjectType("java/lang/String"))
    public func getComment() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getComment__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setCommentURL_java$lang$String__V = invoker("setCommentURL", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setCommentURL(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setCommentURL_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getCommentURL__java$lang$String = invoker("getCommentURL", returns: JObjectType("java/lang/String"))
    public func getCommentURL() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getCommentURL__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setDiscard_Z__V = invoker("setDiscard", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDiscard(a0: jboolean) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setDiscard_Z__V(jobj)(a0)
    }

    private static let java$net$HttpCookie_getDiscard__Z = invoker("getDiscard", returns: jboolean.jniType)
    public func getDiscard() throws -> jboolean {
        return try java$net$HttpCookie$.java$net$HttpCookie_getDiscard__Z(jobj)()
    }

    private static let java$net$HttpCookie_setPortlist_java$lang$String__V = invoker("setPortlist", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setPortlist(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setPortlist_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getPortlist__java$lang$String = invoker("getPortlist", returns: JObjectType("java/lang/String"))
    public func getPortlist() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getPortlist__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setDomain_java$lang$String__V = invoker("setDomain", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setDomain(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setDomain_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getDomain__java$lang$String = invoker("getDomain", returns: JObjectType("java/lang/String"))
    public func getDomain() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getDomain__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setMaxAge_J__V = invoker("setMaxAge", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setMaxAge(a0: jlong) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setMaxAge_J__V(jobj)(a0)
    }

    private static let java$net$HttpCookie_getMaxAge__J = invoker("getMaxAge", returns: jlong.jniType)
    public func getMaxAge() throws -> jlong {
        return try java$net$HttpCookie$.java$net$HttpCookie_getMaxAge__J(jobj)()
    }

    private static let java$net$HttpCookie_setPath_java$lang$String__V = invoker("setPath", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setPath(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setPath_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getPath__java$lang$String = invoker("getPath", returns: JObjectType("java/lang/String"))
    public func getPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getPath__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setSecure_Z__V = invoker("setSecure", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setSecure(a0: jboolean) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setSecure_Z__V(jobj)(a0)
    }

    private static let java$net$HttpCookie_getSecure__Z = invoker("getSecure", returns: jboolean.jniType)
    public func getSecure() throws -> jboolean {
        return try java$net$HttpCookie$.java$net$HttpCookie_getSecure__Z(jobj)()
    }

    private static let java$net$HttpCookie_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getName__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_setValue_java$lang$String__V = invoker("setValue", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setValue(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setValue_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_getValue__java$lang$String = invoker("getValue", returns: JObjectType("java/lang/String"))
    public func getValue() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpCookie$.java$net$HttpCookie_getValue__java$lang$String(jobj)())
    }

    private static let java$net$HttpCookie_getVersion__I = invoker("getVersion", returns: jint.jniType)
    public func getVersion() throws -> jint {
        return try java$net$HttpCookie$.java$net$HttpCookie_getVersion__I(jobj)()
    }

    private static let java$net$HttpCookie_setVersion_I__V = invoker("setVersion", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setVersion(a0: jint) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setVersion_I__V(jobj)(a0)
    }

    private static let java$net$HttpCookie_isHttpOnly__Z = invoker("isHttpOnly", returns: jboolean.jniType)
    public func isHttpOnly() throws -> jboolean {
        return try java$net$HttpCookie$.java$net$HttpCookie_isHttpOnly__Z(jobj)()
    }

    private static let java$net$HttpCookie_setHttpOnly_Z__V = invoker("setHttpOnly", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setHttpOnly(a0: jboolean) throws -> Void {
        return try java$net$HttpCookie$.java$net$HttpCookie_setHttpOnly_Z__V(jobj)(a0)
    }

    private static let java$net$HttpCookie_domainMatches_java$lang$String_java$lang$String__Z = svoker("domainMatches", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func domainMatches(a0: java$lang$String?, _ a1: java$lang$String?) throws -> jboolean {
        return try java$net$HttpCookie$.java$net$HttpCookie_domainMatches_java$lang$String_java$lang$String__Z(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$HttpCookie_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$HttpCookie_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$HttpCookie_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$HttpCookie_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$HttpCookie$.java$net$HttpCookie_clone__java$lang$Object(jobj)())
    }

}

public typealias java$net$HttpCookie$ = java$net$HttpCookie

public class java$net$HttpRetryException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$HttpRetryException_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$net$HttpRetryException$.java$net$HttpRetryException_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$HttpRetryException_init_java$lang$String_I_java$lang$String__V = constructor((JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint, _ a2: java$lang$String?) throws {
        let jobj = try java$net$HttpRetryException$.java$net$HttpRetryException_init_java$lang$String_I_java$lang$String__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$HttpRetryException_responseCode__I = invoker("responseCode", returns: jint.jniType)
    public func responseCode() throws -> jint {
        return try java$net$HttpRetryException$.java$net$HttpRetryException_responseCode__I(jobj)()
    }

    private static let java$net$HttpRetryException_getReason__java$lang$String = invoker("getReason", returns: JObjectType("java/lang/String"))
    public func getReason() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpRetryException$.java$net$HttpRetryException_getReason__java$lang$String(jobj)())
    }

    private static let java$net$HttpRetryException_getLocation__java$lang$String = invoker("getLocation", returns: JObjectType("java/lang/String"))
    public func getLocation() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpRetryException$.java$net$HttpRetryException_getLocation__java$lang$String(jobj)())
    }

}

public typealias java$net$HttpRetryException$ = java$net$HttpRetryException

public class java$net$HttpURLConnection : java$net$URLConnection$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$HttpURLConnection_getHeaderFieldKey_I__java$lang$String = invoker("getHeaderFieldKey", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$net$HttpURLConnection_setFixedLengthStreamingMode_I__V = invoker("setFixedLengthStreamingMode", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setFixedLengthStreamingMode(a0: jint) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setFixedLengthStreamingMode_I__V(jobj)(a0)
    }

    private static let java$net$HttpURLConnection_setFixedLengthStreamingMode_J__V = invoker("setFixedLengthStreamingMode", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setFixedLengthStreamingMode(a0: jlong) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setFixedLengthStreamingMode_J__V(jobj)(a0)
    }

    private static let java$net$HttpURLConnection_setChunkedStreamingMode_I__V = invoker("setChunkedStreamingMode", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setChunkedStreamingMode(a0: jint) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setChunkedStreamingMode_I__V(jobj)(a0)
    }

    private static let java$net$HttpURLConnection_getHeaderField_I__java$lang$String = invoker("getHeaderField", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$net$HttpURLConnection_setFollowRedirects_Z__V = svoker("setFollowRedirects", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public static func setFollowRedirects(a0: jboolean) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setFollowRedirects_Z__V(a0)
    }

    private static let java$net$HttpURLConnection_getFollowRedirects__Z = svoker("getFollowRedirects", returns: jboolean.jniType)
    public static func getFollowRedirects() throws -> jboolean {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_getFollowRedirects__Z()
    }

    private static let java$net$HttpURLConnection_setInstanceFollowRedirects_Z__V = invoker("setInstanceFollowRedirects", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setInstanceFollowRedirects(a0: jboolean) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setInstanceFollowRedirects_Z__V(jobj)(a0)
    }

    private static let java$net$HttpURLConnection_getInstanceFollowRedirects__Z = invoker("getInstanceFollowRedirects", returns: jboolean.jniType)
    public func getInstanceFollowRedirects() throws -> jboolean {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_getInstanceFollowRedirects__Z(jobj)()
    }

    private static let java$net$HttpURLConnection_setRequestMethod_java$lang$String__V = invoker("setRequestMethod", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setRequestMethod(a0: java$lang$String?) throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_setRequestMethod_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$HttpURLConnection_getRequestMethod__java$lang$String = invoker("getRequestMethod", returns: JObjectType("java/lang/String"))
    public func getRequestMethod() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpURLConnection$.java$net$HttpURLConnection_getRequestMethod__java$lang$String(jobj)())
    }

    private static let java$net$HttpURLConnection_getResponseCode__I = invoker("getResponseCode", returns: jint.jniType)
    public func getResponseCode() throws -> jint {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_getResponseCode__I(jobj)()
    }

    private static let java$net$HttpURLConnection_getResponseMessage__java$lang$String = invoker("getResponseMessage", returns: JObjectType("java/lang/String"))
    public func getResponseMessage() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$HttpURLConnection$.java$net$HttpURLConnection_getResponseMessage__java$lang$String(jobj)())
    }

    private static let java$net$HttpURLConnection_getHeaderFieldDate_java$lang$String_J__J = invoker("getHeaderFieldDate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    private static let java$net$HttpURLConnection_disconnect__V = invoker("disconnect", returns: JVoid.jniType)
    public func disconnect() throws -> Void {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_disconnect__V(jobj)()
    }

    private static let java$net$HttpURLConnection_usingProxy__Z = invoker("usingProxy", returns: jboolean.jniType)
    public func usingProxy() throws -> jboolean {
        return try java$net$HttpURLConnection$.java$net$HttpURLConnection_usingProxy__Z(jobj)()
    }

    private static let java$net$HttpURLConnection_getPermission__java$security$Permission = invoker("getPermission", returns: JObjectType("java/security/Permission"))
    private static let java$net$HttpURLConnection_getErrorStream__java$io$InputStream = invoker("getErrorStream", returns: JObjectType("java/io/InputStream"))
    public func getErrorStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$net$HttpURLConnection$.java$net$HttpURLConnection_getErrorStream__java$io$InputStream(jobj)())
    }

}

public typealias java$net$HttpURLConnection$ = java$net$HttpURLConnection

public final class java$net$IDN : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$IDN_toASCII_java$lang$String_I__java$lang$String = svoker("toASCII", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func toASCII(a0: java$lang$String?, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$IDN$.java$net$IDN_toASCII_java$lang$String_I__java$lang$String(a0?.jobj ?? nil, a1))
    }

    private static let java$net$IDN_toASCII_java$lang$String__java$lang$String = svoker("toASCII", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func toASCII(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$IDN$.java$net$IDN_toASCII_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$net$IDN_toUnicode_java$lang$String_I__java$lang$String = svoker("toUnicode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func toUnicode(a0: java$lang$String?, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$IDN$.java$net$IDN_toUnicode_java$lang$String_I__java$lang$String(a0?.jobj ?? nil, a1))
    }

    private static let java$net$IDN_toUnicode_java$lang$String__java$lang$String = svoker("toUnicode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func toUnicode(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$IDN$.java$net$IDN_toUnicode_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

}

public typealias java$net$IDN$ = java$net$IDN

public class java$net$InMemoryCookieStore : java$lang$Object$, java$net$CookieStore {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$InMemoryCookieStore_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$InMemoryCookieStore_add_java$net$URI_java$net$HttpCookie__V = invoker("add", returns: JVoid.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/HttpCookie")))
    public func add(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> Void {
        return try java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_add_java$net$URI_java$net$HttpCookie__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$InMemoryCookieStore_get_java$net$URI__java$util$List = invoker("get", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/net/URI")))
    public func get(a0: java$net$URI?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_get_java$net$URI__java$util$List(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$InMemoryCookieStore_getCookies__java$util$List = invoker("getCookies", returns: JObjectType("java/util/List"))
    public func getCookies() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_getCookies__java$util$List(jobj)())
    }

    private static let java$net$InMemoryCookieStore_getURIs__java$util$List = invoker("getURIs", returns: JObjectType("java/util/List"))
    public func getURIs() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_getURIs__java$util$List(jobj)())
    }

    private static let java$net$InMemoryCookieStore_remove_java$net$URI_java$net$HttpCookie__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/HttpCookie")))
    public func remove(a0: java$net$URI?, _ a1: java$net$HttpCookie?) throws -> jboolean {
        return try java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_remove_java$net$URI_java$net$HttpCookie__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$InMemoryCookieStore_removeAll__Z = invoker("removeAll", returns: jboolean.jniType)
    public func removeAll() throws -> jboolean {
        return try java$net$InMemoryCookieStore$.java$net$InMemoryCookieStore_removeAll__Z(jobj)()
    }

}

public typealias java$net$InMemoryCookieStore$ = java$net$InMemoryCookieStore

public final class java$net$Inet4Address : java$net$InetAddress$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Inet4Address_isMulticastAddress__Z = invoker("isMulticastAddress", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isAnyLocalAddress__Z = invoker("isAnyLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isLoopbackAddress__Z = invoker("isLoopbackAddress", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isLinkLocalAddress__Z = invoker("isLinkLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isSiteLocalAddress__Z = invoker("isSiteLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isMCGlobal__Z = invoker("isMCGlobal", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isMCNodeLocal__Z = invoker("isMCNodeLocal", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isMCLinkLocal__Z = invoker("isMCLinkLocal", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isMCSiteLocal__Z = invoker("isMCSiteLocal", returns: jboolean.jniType)
    private static let java$net$Inet4Address_isMCOrgLocal__Z = invoker("isMCOrgLocal", returns: jboolean.jniType)
    private static let java$net$Inet4Address_getAddress__AB = invoker("getAddress", returns: JArray(jbyte.jniType))
    private static let java$net$Inet4Address_getHostAddress__java$lang$String = invoker("getHostAddress", returns: JObjectType("java/lang/String"))
    private static let java$net$Inet4Address_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$Inet4Address_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$net$Inet4Address$ = java$net$Inet4Address

public class java$net$Inet4AddressImpl : java$lang$Object$, java$net$InetAddressImpl {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Inet4AddressImpl_getLocalHostName__java$lang$String = invoker("getLocalHostName", returns: JObjectType("java/lang/String"))
    public func getLocalHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_getLocalHostName__java$lang$String(jobj)())
    }

    private static let java$net$Inet4AddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress = invoker("lookupAllHostAddr", returns: JArray(JObjectType("java/net/InetAddress")), arguments: (JObjectType("java/lang/String")))
    public func lookupAllHostAddr(a0: java$lang$String?) throws -> [java$net$InetAddress?]? {
        return try java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress(jobj)(a0?.jobj ?? nil).jarrayToArray(java$net$InetAddress$.self)?.map({ $0 as java$net$InetAddress? })
    }

    private static let java$net$Inet4AddressImpl_getHostByAddr_AB__java$lang$String = invoker("getHostByAddr", returns: JObjectType("java/lang/String"), arguments: (JArray(jbyte.jniType)))
    public func getHostByAddr(a0: [jbyte]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_getHostByAddr_AB__java$lang$String(jobj)(a0?.arrayToJArray() ?? nil))
    }

    private static let java$net$Inet4AddressImpl_anyLocalAddress__java$net$InetAddress = invoker("anyLocalAddress", returns: JObjectType("java/net/InetAddress"))
    public func anyLocalAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_anyLocalAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$Inet4AddressImpl_loopbackAddress__java$net$InetAddress = invoker("loopbackAddress", returns: JObjectType("java/net/InetAddress"))
    public func loopbackAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_loopbackAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$Inet4AddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z = invoker("isReachable", returns: jboolean.jniType, arguments: (JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/net/NetworkInterface"), jint.jniType))
    public func isReachable(a0: java$net$InetAddress?, _ a1: jint, _ a2: java$net$NetworkInterface?, _ a3: jint) throws -> jboolean {
        return try java$net$Inet4AddressImpl$.java$net$Inet4AddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3)
    }

}

public typealias java$net$Inet4AddressImpl$ = java$net$Inet4AddressImpl

public final class java$net$Inet6Address : java$net$InetAddress$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Inet6Address_getByAddress_java$lang$String_AB_java$net$NetworkInterface__java$net$Inet6Address = svoker("getByAddress", returns: JObjectType("java/net/Inet6Address"), arguments: (JObjectType("java/lang/String"), JArray(jbyte.jniType), JObjectType("java/net/NetworkInterface")))
    public static func getByAddress(a0: java$lang$String?, _ a1: [jbyte]?, _ a2: java$net$NetworkInterface?) throws -> java$net$Inet6Address? {
        return try java$net$Inet6Address$(jobj: java$net$Inet6Address$.java$net$Inet6Address_getByAddress_java$lang$String_AB_java$net$NetworkInterface__java$net$Inet6Address(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil, a2?.jobj ?? nil))
    }

    private static let java$net$Inet6Address_getByAddress_java$lang$String_AB_I__java$net$Inet6Address = svoker("getByAddress", returns: JObjectType("java/net/Inet6Address"), arguments: (JObjectType("java/lang/String"), JArray(jbyte.jniType), jint.jniType))
    public static func getByAddress(a0: java$lang$String?, _ a1: [jbyte]?, _ a2: jint) throws -> java$net$Inet6Address? {
        return try java$net$Inet6Address$(jobj: java$net$Inet6Address$.java$net$Inet6Address_getByAddress_java$lang$String_AB_I__java$net$Inet6Address(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil, a2))
    }

    private static let java$net$Inet6Address_isMulticastAddress__Z = invoker("isMulticastAddress", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isAnyLocalAddress__Z = invoker("isAnyLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isLoopbackAddress__Z = invoker("isLoopbackAddress", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isLinkLocalAddress__Z = invoker("isLinkLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isSiteLocalAddress__Z = invoker("isSiteLocalAddress", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isMCGlobal__Z = invoker("isMCGlobal", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isMCNodeLocal__Z = invoker("isMCNodeLocal", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isMCLinkLocal__Z = invoker("isMCLinkLocal", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isMCSiteLocal__Z = invoker("isMCSiteLocal", returns: jboolean.jniType)
    private static let java$net$Inet6Address_isMCOrgLocal__Z = invoker("isMCOrgLocal", returns: jboolean.jniType)
    private static let java$net$Inet6Address_getAddress__AB = invoker("getAddress", returns: JArray(jbyte.jniType))
    private static let java$net$Inet6Address_getScopeId__I = invoker("getScopeId", returns: jint.jniType)
    public func getScopeId() throws -> jint {
        return try java$net$Inet6Address$.java$net$Inet6Address_getScopeId__I(jobj)()
    }

    private static let java$net$Inet6Address_getScopedInterface__java$net$NetworkInterface = invoker("getScopedInterface", returns: JObjectType("java/net/NetworkInterface"))
    public func getScopedInterface() throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$Inet6Address$.java$net$Inet6Address_getScopedInterface__java$net$NetworkInterface(jobj)())
    }

    private static let java$net$Inet6Address_getHostAddress__java$lang$String = invoker("getHostAddress", returns: JObjectType("java/lang/String"))
    private static let java$net$Inet6Address_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$Inet6Address_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$Inet6Address_isIPv4CompatibleAddress__Z = invoker("isIPv4CompatibleAddress", returns: jboolean.jniType)
    public func isIPv4CompatibleAddress() throws -> jboolean {
        return try java$net$Inet6Address$.java$net$Inet6Address_isIPv4CompatibleAddress__Z(jobj)()
    }

}

public typealias java$net$Inet6Address$ = java$net$Inet6Address

public class java$net$Inet6AddressImpl : java$lang$Object$, java$net$InetAddressImpl {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Inet6AddressImpl_getLocalHostName__java$lang$String = invoker("getLocalHostName", returns: JObjectType("java/lang/String"))
    public func getLocalHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_getLocalHostName__java$lang$String(jobj)())
    }

    private static let java$net$Inet6AddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress = invoker("lookupAllHostAddr", returns: JArray(JObjectType("java/net/InetAddress")), arguments: (JObjectType("java/lang/String")))
    public func lookupAllHostAddr(a0: java$lang$String?) throws -> [java$net$InetAddress?]? {
        return try java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress(jobj)(a0?.jobj ?? nil).jarrayToArray(java$net$InetAddress$.self)?.map({ $0 as java$net$InetAddress? })
    }

    private static let java$net$Inet6AddressImpl_getHostByAddr_AB__java$lang$String = invoker("getHostByAddr", returns: JObjectType("java/lang/String"), arguments: (JArray(jbyte.jniType)))
    public func getHostByAddr(a0: [jbyte]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_getHostByAddr_AB__java$lang$String(jobj)(a0?.arrayToJArray() ?? nil))
    }

    private static let java$net$Inet6AddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z = invoker("isReachable", returns: jboolean.jniType, arguments: (JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/net/NetworkInterface"), jint.jniType))
    public func isReachable(a0: java$net$InetAddress?, _ a1: jint, _ a2: java$net$NetworkInterface?, _ a3: jint) throws -> jboolean {
        return try java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3)
    }

    private static let java$net$Inet6AddressImpl_anyLocalAddress__java$net$InetAddress = invoker("anyLocalAddress", returns: JObjectType("java/net/InetAddress"))
    public func anyLocalAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_anyLocalAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$Inet6AddressImpl_loopbackAddress__java$net$InetAddress = invoker("loopbackAddress", returns: JObjectType("java/net/InetAddress"))
    public func loopbackAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Inet6AddressImpl$.java$net$Inet6AddressImpl_loopbackAddress__java$net$InetAddress(jobj)())
    }

}

public typealias java$net$Inet6AddressImpl$ = java$net$Inet6AddressImpl

public class java$net$InetAddress : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$InetAddress_isMulticastAddress__Z = invoker("isMulticastAddress", returns: jboolean.jniType)
    public func isMulticastAddress() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMulticastAddress__Z(jobj)()
    }

    private static let java$net$InetAddress_isAnyLocalAddress__Z = invoker("isAnyLocalAddress", returns: jboolean.jniType)
    public func isAnyLocalAddress() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isAnyLocalAddress__Z(jobj)()
    }

    private static let java$net$InetAddress_isLoopbackAddress__Z = invoker("isLoopbackAddress", returns: jboolean.jniType)
    public func isLoopbackAddress() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isLoopbackAddress__Z(jobj)()
    }

    private static let java$net$InetAddress_isLinkLocalAddress__Z = invoker("isLinkLocalAddress", returns: jboolean.jniType)
    public func isLinkLocalAddress() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isLinkLocalAddress__Z(jobj)()
    }

    private static let java$net$InetAddress_isSiteLocalAddress__Z = invoker("isSiteLocalAddress", returns: jboolean.jniType)
    public func isSiteLocalAddress() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isSiteLocalAddress__Z(jobj)()
    }

    private static let java$net$InetAddress_isMCGlobal__Z = invoker("isMCGlobal", returns: jboolean.jniType)
    public func isMCGlobal() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMCGlobal__Z(jobj)()
    }

    private static let java$net$InetAddress_isMCNodeLocal__Z = invoker("isMCNodeLocal", returns: jboolean.jniType)
    public func isMCNodeLocal() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMCNodeLocal__Z(jobj)()
    }

    private static let java$net$InetAddress_isMCLinkLocal__Z = invoker("isMCLinkLocal", returns: jboolean.jniType)
    public func isMCLinkLocal() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMCLinkLocal__Z(jobj)()
    }

    private static let java$net$InetAddress_isMCSiteLocal__Z = invoker("isMCSiteLocal", returns: jboolean.jniType)
    public func isMCSiteLocal() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMCSiteLocal__Z(jobj)()
    }

    private static let java$net$InetAddress_isMCOrgLocal__Z = invoker("isMCOrgLocal", returns: jboolean.jniType)
    public func isMCOrgLocal() throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isMCOrgLocal__Z(jobj)()
    }

    private static let java$net$InetAddress_isReachable_I__Z = invoker("isReachable", returns: jboolean.jniType, arguments: (jint.jniType))
    public func isReachable(a0: jint) throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isReachable_I__Z(jobj)(a0)
    }

    private static let java$net$InetAddress_isReachable_java$net$NetworkInterface_I_I__Z = invoker("isReachable", returns: jboolean.jniType, arguments: (JObjectType("java/net/NetworkInterface"), jint.jniType, jint.jniType))
    public func isReachable(a0: java$net$NetworkInterface?, _ a1: jint, _ a2: jint) throws -> jboolean {
        return try java$net$InetAddress$.java$net$InetAddress_isReachable_java$net$NetworkInterface_I_I__Z(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$net$InetAddress_getHostName__java$lang$String = invoker("getHostName", returns: JObjectType("java/lang/String"))
    public func getHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetAddress$.java$net$InetAddress_getHostName__java$lang$String(jobj)())
    }

    private static let java$net$InetAddress_getCanonicalHostName__java$lang$String = invoker("getCanonicalHostName", returns: JObjectType("java/lang/String"))
    public func getCanonicalHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetAddress$.java$net$InetAddress_getCanonicalHostName__java$lang$String(jobj)())
    }

    private static let java$net$InetAddress_getAddress__AB = invoker("getAddress", returns: JArray(jbyte.jniType))
    public func getAddress() throws -> [jbyte]? {
        return try java$net$InetAddress$.java$net$InetAddress_getAddress__AB(jobj)().jarrayToArray()
    }

    private static let java$net$InetAddress_getHostAddress__java$lang$String = invoker("getHostAddress", returns: JObjectType("java/lang/String"))
    public func getHostAddress() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetAddress$.java$net$InetAddress_getHostAddress__java$lang$String(jobj)())
    }

    private static let java$net$InetAddress_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$InetAddress_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$InetAddress_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$InetAddress_getByAddress_java$lang$String_AB__java$net$InetAddress = svoker("getByAddress", returns: JObjectType("java/net/InetAddress"), arguments: (JObjectType("java/lang/String"), JArray(jbyte.jniType)))
    public static func getByAddress(a0: java$lang$String?, _ a1: [jbyte]?) throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddress$.java$net$InetAddress_getByAddress_java$lang$String_AB__java$net$InetAddress(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil))
    }

    private static let java$net$InetAddress_getByName_java$lang$String__java$net$InetAddress = svoker("getByName", returns: JObjectType("java/net/InetAddress"), arguments: (JObjectType("java/lang/String")))
    public static func getByName(a0: java$lang$String?) throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddress$.java$net$InetAddress_getByName_java$lang$String__java$net$InetAddress(a0?.jobj ?? nil))
    }

    private static let java$net$InetAddress_getAllByName_java$lang$String__Ajava$net$InetAddress = svoker("getAllByName", returns: JArray(JObjectType("java/net/InetAddress")), arguments: (JObjectType("java/lang/String")))
    public static func getAllByName(a0: java$lang$String?) throws -> [java$net$InetAddress?]? {
        return try java$net$InetAddress$.java$net$InetAddress_getAllByName_java$lang$String__Ajava$net$InetAddress(a0?.jobj ?? nil).jarrayToArray(java$net$InetAddress$.self)?.map({ $0 as java$net$InetAddress? })
    }

    private static let java$net$InetAddress_getLoopbackAddress__java$net$InetAddress = svoker("getLoopbackAddress", returns: JObjectType("java/net/InetAddress"))
    public static func getLoopbackAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddress$.java$net$InetAddress_getLoopbackAddress__java$net$InetAddress())
    }

    private static let java$net$InetAddress_getByAddress_AB__java$net$InetAddress = svoker("getByAddress", returns: JObjectType("java/net/InetAddress"), arguments: (JArray(jbyte.jniType)))
    public static func getByAddress(a0: [jbyte]?) throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddress$.java$net$InetAddress_getByAddress_AB__java$net$InetAddress(a0?.arrayToJArray() ?? nil))
    }

    private static let java$net$InetAddress_getLocalHost__java$net$InetAddress = svoker("getLocalHost", returns: JObjectType("java/net/InetAddress"))
    public static func getLocalHost() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddress$.java$net$InetAddress_getLocalHost__java$net$InetAddress())
    }

}

public typealias java$net$InetAddress$ = java$net$InetAddress

public class java$net$InetAddressContainer : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$InetAddressContainer$ = java$net$InetAddressContainer

public protocol java$net$InetAddressImpl : JavaObject {
    func getLocalHostName() throws -> java$lang$String?
    func lookupAllHostAddr(a0: java$lang$String?) throws -> [java$net$InetAddress?]?
    func getHostByAddr(a0: [jbyte]?) throws -> java$lang$String?
    func anyLocalAddress() throws -> java$net$InetAddress?
    func loopbackAddress() throws -> java$net$InetAddress?
    func isReachable(a0: java$net$InetAddress?, _ a1: jint, _ a2: java$net$NetworkInterface?, _ a3: jint) throws -> jboolean
}

public class java$net$InetAddressImpl$ : java$lang$Object$, java$net$InetAddressImpl {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$InetAddressImpl_getLocalHostName__java$lang$String = invoker("getLocalHostName", returns: JObjectType("java/lang/String"))
    private static let java$net$InetAddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress = invoker("lookupAllHostAddr", returns: JArray(JObjectType("java/net/InetAddress")), arguments: (JObjectType("java/lang/String")))
    private static let java$net$InetAddressImpl_getHostByAddr_AB__java$lang$String = invoker("getHostByAddr", returns: JObjectType("java/lang/String"), arguments: (JArray(jbyte.jniType)))
    private static let java$net$InetAddressImpl_anyLocalAddress__java$net$InetAddress = invoker("anyLocalAddress", returns: JObjectType("java/net/InetAddress"))
    private static let java$net$InetAddressImpl_loopbackAddress__java$net$InetAddress = invoker("loopbackAddress", returns: JObjectType("java/net/InetAddress"))
    private static let java$net$InetAddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z = invoker("isReachable", returns: jboolean.jniType, arguments: (JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/net/NetworkInterface"), jint.jniType))
}

public extension java$net$InetAddressImpl {
    func getLocalHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetAddressImpl$.java$net$InetAddressImpl_getLocalHostName__java$lang$String(jobj)())
    }

    func lookupAllHostAddr(a0: java$lang$String?) throws -> [java$net$InetAddress?]? {
        return try java$net$InetAddressImpl$.java$net$InetAddressImpl_lookupAllHostAddr_java$lang$String__Ajava$net$InetAddress(jobj)(a0?.jobj ?? nil).jarrayToArray(java$net$InetAddress$.self)?.map({ $0 as java$net$InetAddress? })
    }

    func getHostByAddr(a0: [jbyte]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetAddressImpl$.java$net$InetAddressImpl_getHostByAddr_AB__java$lang$String(jobj)(a0?.arrayToJArray() ?? nil))
    }

    func anyLocalAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddressImpl$.java$net$InetAddressImpl_anyLocalAddress__java$net$InetAddress(jobj)())
    }

    func loopbackAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetAddressImpl$.java$net$InetAddressImpl_loopbackAddress__java$net$InetAddress(jobj)())
    }

    func isReachable(a0: java$net$InetAddress?, _ a1: jint, _ a2: java$net$NetworkInterface?, _ a3: jint) throws -> jboolean {
        return try java$net$InetAddressImpl$.java$net$InetAddressImpl_isReachable_java$net$InetAddress_I_java$net$NetworkInterface_I__Z(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3)
    }

}

public class java$net$InetAddressImplFactory : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$InetAddressImplFactory$ = java$net$InetAddressImplFactory

public class java$net$InetSocketAddress : java$net$SocketAddress$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$InetSocketAddress_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$net$InetSocketAddress$.java$net$InetSocketAddress_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$net$InetSocketAddress_init_java$net$InetAddress_I__V = constructor((JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: java$net$InetAddress?, _ a1: jint) throws {
        let jobj = try java$net$InetSocketAddress$.java$net$InetSocketAddress_init_java$net$InetAddress_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$InetSocketAddress_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$net$InetSocketAddress$.java$net$InetSocketAddress_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$InetSocketAddress_createUnresolved_java$lang$String_I__java$net$InetSocketAddress = svoker("createUnresolved", returns: JObjectType("java/net/InetSocketAddress"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public static func createUnresolved(a0: java$lang$String?, _ a1: jint) throws -> java$net$InetSocketAddress? {
        return try java$net$InetSocketAddress$(jobj: java$net$InetSocketAddress$.java$net$InetSocketAddress_createUnresolved_java$lang$String_I__java$net$InetSocketAddress(a0?.jobj ?? nil, a1))
    }

    private static let java$net$InetSocketAddress_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$InetSocketAddress$.java$net$InetSocketAddress_getPort__I(jobj)()
    }

    private static let java$net$InetSocketAddress_getAddress__java$net$InetAddress = invoker("getAddress", returns: JObjectType("java/net/InetAddress"))
    public func getAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InetSocketAddress$.java$net$InetSocketAddress_getAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$InetSocketAddress_getHostName__java$lang$String = invoker("getHostName", returns: JObjectType("java/lang/String"))
    public func getHostName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetSocketAddress$.java$net$InetSocketAddress_getHostName__java$lang$String(jobj)())
    }

    private static let java$net$InetSocketAddress_getHostString__java$lang$String = invoker("getHostString", returns: JObjectType("java/lang/String"))
    public func getHostString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$InetSocketAddress$.java$net$InetSocketAddress_getHostString__java$lang$String(jobj)())
    }

    private static let java$net$InetSocketAddress_isUnresolved__Z = invoker("isUnresolved", returns: jboolean.jniType)
    public func isUnresolved() throws -> jboolean {
        return try java$net$InetSocketAddress$.java$net$InetSocketAddress_isUnresolved__Z(jobj)()
    }

    private static let java$net$InetSocketAddress_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$InetSocketAddress_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$InetSocketAddress_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$net$InetSocketAddress$ = java$net$InetSocketAddress

public class java$net$InterfaceAddress : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$InterfaceAddress_getAddress__java$net$InetAddress = invoker("getAddress", returns: JObjectType("java/net/InetAddress"))
    public func getAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InterfaceAddress$.java$net$InterfaceAddress_getAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$InterfaceAddress_getBroadcast__java$net$InetAddress = invoker("getBroadcast", returns: JObjectType("java/net/InetAddress"))
    public func getBroadcast() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$InterfaceAddress$.java$net$InterfaceAddress_getBroadcast__java$net$InetAddress(jobj)())
    }

    private static let java$net$InterfaceAddress_getNetworkPrefixLength__S = invoker("getNetworkPrefixLength", returns: jshort.jniType)
    public func getNetworkPrefixLength() throws -> jshort {
        return try java$net$InterfaceAddress$.java$net$InterfaceAddress_getNetworkPrefixLength__S(jobj)()
    }

    private static let java$net$InterfaceAddress_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$InterfaceAddress_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$InterfaceAddress_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$net$InterfaceAddress$ = java$net$InterfaceAddress

public class java$net$JarURLConnection : java$net$URLConnection$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$JarURLConnection_getJarFileURL__java$net$URL = invoker("getJarFileURL", returns: JObjectType("java/net/URL"))
    public func getJarFileURL() throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getJarFileURL__java$net$URL(jobj)())
    }

    private static let java$net$JarURLConnection_getEntryName__java$lang$String = invoker("getEntryName", returns: JObjectType("java/lang/String"))
    public func getEntryName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getEntryName__java$lang$String(jobj)())
    }

    private static let java$net$JarURLConnection_getJarFile__java$util$jar$JarFile = invoker("getJarFile", returns: JObjectType("java/util/jar/JarFile"))
    public func getJarFile() throws -> java$util$jar$JarFile? {
        return try java$util$jar$JarFile$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getJarFile__java$util$jar$JarFile(jobj)())
    }

    private static let java$net$JarURLConnection_getManifest__java$util$jar$Manifest = invoker("getManifest", returns: JObjectType("java/util/jar/Manifest"))
    public func getManifest() throws -> java$util$jar$Manifest? {
        return try java$util$jar$Manifest$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getManifest__java$util$jar$Manifest(jobj)())
    }

    private static let java$net$JarURLConnection_getJarEntry__java$util$jar$JarEntry = invoker("getJarEntry", returns: JObjectType("java/util/jar/JarEntry"))
    public func getJarEntry() throws -> java$util$jar$JarEntry? {
        return try java$util$jar$JarEntry$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getJarEntry__java$util$jar$JarEntry(jobj)())
    }

    private static let java$net$JarURLConnection_getAttributes__java$util$jar$Attributes = invoker("getAttributes", returns: JObjectType("java/util/jar/Attributes"))
    public func getAttributes() throws -> java$util$jar$Attributes? {
        return try java$util$jar$Attributes$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getAttributes__java$util$jar$Attributes(jobj)())
    }

    private static let java$net$JarURLConnection_getMainAttributes__java$util$jar$Attributes = invoker("getMainAttributes", returns: JObjectType("java/util/jar/Attributes"))
    public func getMainAttributes() throws -> java$util$jar$Attributes? {
        return try java$util$jar$Attributes$(jobj: java$net$JarURLConnection$.java$net$JarURLConnection_getMainAttributes__java$util$jar$Attributes(jobj)())
    }

    private static let java$net$JarURLConnection_getCertificates__Ajava$security$cert$Certificate = invoker("getCertificates", returns: JArray(JObjectType("java/security/cert/Certificate")))
    public func getCertificates() throws -> [java$security$cert$Certificate?]? {
        return try java$net$JarURLConnection$.java$net$JarURLConnection_getCertificates__Ajava$security$cert$Certificate(jobj)().jarrayToArray(java$security$cert$Certificate$.self)?.map({ $0 as java$security$cert$Certificate? })
    }

}

public typealias java$net$JarURLConnection$ = java$net$JarURLConnection

public class java$net$MalformedURLException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$MalformedURLException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$MalformedURLException$.java$net$MalformedURLException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$MalformedURLException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$MalformedURLException$.java$net$MalformedURLException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$net$MalformedURLException$ = java$net$MalformedURLException

public class java$net$MulticastSocket : java$net$DatagramSocket$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$MulticastSocket_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$MulticastSocket$.java$net$MulticastSocket_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$MulticastSocket_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$net$MulticastSocket$.java$net$MulticastSocket_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$net$MulticastSocket_init_java$net$SocketAddress__V = constructor((JObjectType("java/net/SocketAddress")))
    public convenience init!(_ a0: java$net$SocketAddress?) throws {
        let jobj = try java$net$MulticastSocket$.java$net$MulticastSocket_init_java$net$SocketAddress__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$MulticastSocket_setTTL_B__V = invoker("setTTL", returns: JVoid.jniType, arguments: (jbyte.jniType))
    public func setTTL(a0: jbyte) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_setTTL_B__V(jobj)(a0)
    }

    private static let java$net$MulticastSocket_setTimeToLive_I__V = invoker("setTimeToLive", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setTimeToLive(a0: jint) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_setTimeToLive_I__V(jobj)(a0)
    }

    private static let java$net$MulticastSocket_getTTL__B = invoker("getTTL", returns: jbyte.jniType)
    public func getTTL() throws -> jbyte {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_getTTL__B(jobj)()
    }

    private static let java$net$MulticastSocket_getTimeToLive__I = invoker("getTimeToLive", returns: jint.jniType)
    public func getTimeToLive() throws -> jint {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_getTimeToLive__I(jobj)()
    }

    private static let java$net$MulticastSocket_joinGroup_java$net$InetAddress__V = invoker("joinGroup", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress")))
    public func joinGroup(a0: java$net$InetAddress?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_joinGroup_java$net$InetAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_leaveGroup_java$net$InetAddress__V = invoker("leaveGroup", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress")))
    public func leaveGroup(a0: java$net$InetAddress?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_leaveGroup_java$net$InetAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_joinGroup_java$net$SocketAddress_java$net$NetworkInterface__V = invoker("joinGroup", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress"), JObjectType("java/net/NetworkInterface")))
    public func joinGroup(a0: java$net$SocketAddress?, _ a1: java$net$NetworkInterface?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_joinGroup_java$net$SocketAddress_java$net$NetworkInterface__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_leaveGroup_java$net$SocketAddress_java$net$NetworkInterface__V = invoker("leaveGroup", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress"), JObjectType("java/net/NetworkInterface")))
    public func leaveGroup(a0: java$net$SocketAddress?, _ a1: java$net$NetworkInterface?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_leaveGroup_java$net$SocketAddress_java$net$NetworkInterface__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_setInterface_java$net$InetAddress__V = invoker("setInterface", returns: JVoid.jniType, arguments: (JObjectType("java/net/InetAddress")))
    public func setInterface(a0: java$net$InetAddress?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_setInterface_java$net$InetAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_getInterface__java$net$InetAddress = invoker("getInterface", returns: JObjectType("java/net/InetAddress"))
    public func getInterface() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$MulticastSocket$.java$net$MulticastSocket_getInterface__java$net$InetAddress(jobj)())
    }

    private static let java$net$MulticastSocket_setNetworkInterface_java$net$NetworkInterface__V = invoker("setNetworkInterface", returns: JVoid.jniType, arguments: (JObjectType("java/net/NetworkInterface")))
    public func setNetworkInterface(a0: java$net$NetworkInterface?) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_setNetworkInterface_java$net$NetworkInterface__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$MulticastSocket_getNetworkInterface__java$net$NetworkInterface = invoker("getNetworkInterface", returns: JObjectType("java/net/NetworkInterface"))
    public func getNetworkInterface() throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$MulticastSocket$.java$net$MulticastSocket_getNetworkInterface__java$net$NetworkInterface(jobj)())
    }

    private static let java$net$MulticastSocket_setLoopbackMode_Z__V = invoker("setLoopbackMode", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setLoopbackMode(a0: jboolean) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_setLoopbackMode_Z__V(jobj)(a0)
    }

    private static let java$net$MulticastSocket_getLoopbackMode__Z = invoker("getLoopbackMode", returns: jboolean.jniType)
    public func getLoopbackMode() throws -> jboolean {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_getLoopbackMode__Z(jobj)()
    }

    private static let java$net$MulticastSocket_send_java$net$DatagramPacket_B__V = invoker("send", returns: JVoid.jniType, arguments: (JObjectType("java/net/DatagramPacket"), jbyte.jniType))
    public func send(a0: java$net$DatagramPacket?, _ a1: jbyte) throws -> Void {
        return try java$net$MulticastSocket$.java$net$MulticastSocket_send_java$net$DatagramPacket_B__V(jobj)(a0?.jobj ?? nil, a1)
    }

}

public typealias java$net$MulticastSocket$ = java$net$MulticastSocket

public final class java$net$NetworkInterface : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$NetworkInterface_getName__java$lang$String = invoker("getName", returns: JObjectType("java/lang/String"))
    public func getName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getName__java$lang$String(jobj)())
    }

    private static let java$net$NetworkInterface_getInetAddresses__java$util$Enumeration = invoker("getInetAddresses", returns: JObjectType("java/util/Enumeration"))
    public func getInetAddresses() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getInetAddresses__java$util$Enumeration(jobj)())
    }

    private static let java$net$NetworkInterface_getInterfaceAddresses__java$util$List = invoker("getInterfaceAddresses", returns: JObjectType("java/util/List"))
    public func getInterfaceAddresses() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getInterfaceAddresses__java$util$List(jobj)())
    }

    private static let java$net$NetworkInterface_getSubInterfaces__java$util$Enumeration = invoker("getSubInterfaces", returns: JObjectType("java/util/Enumeration"))
    public func getSubInterfaces() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getSubInterfaces__java$util$Enumeration(jobj)())
    }

    private static let java$net$NetworkInterface_getParent__java$net$NetworkInterface = invoker("getParent", returns: JObjectType("java/net/NetworkInterface"))
    public func getParent() throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getParent__java$net$NetworkInterface(jobj)())
    }

    private static let java$net$NetworkInterface_getIndex__I = invoker("getIndex", returns: jint.jniType)
    public func getIndex() throws -> jint {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_getIndex__I(jobj)()
    }

    private static let java$net$NetworkInterface_getDisplayName__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"))
    public func getDisplayName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getDisplayName__java$lang$String(jobj)())
    }

    private static let java$net$NetworkInterface_getByName_java$lang$String__java$net$NetworkInterface = svoker("getByName", returns: JObjectType("java/net/NetworkInterface"), arguments: (JObjectType("java/lang/String")))
    public static func getByName(a0: java$lang$String?) throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getByName_java$lang$String__java$net$NetworkInterface(a0?.jobj ?? nil))
    }

    private static let java$net$NetworkInterface_getByIndex_I__java$net$NetworkInterface = svoker("getByIndex", returns: JObjectType("java/net/NetworkInterface"), arguments: (jint.jniType))
    public static func getByIndex(a0: jint) throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getByIndex_I__java$net$NetworkInterface(a0))
    }

    private static let java$net$NetworkInterface_getByInetAddress_java$net$InetAddress__java$net$NetworkInterface = svoker("getByInetAddress", returns: JObjectType("java/net/NetworkInterface"), arguments: (JObjectType("java/net/InetAddress")))
    public static func getByInetAddress(a0: java$net$InetAddress?) throws -> java$net$NetworkInterface? {
        return try java$net$NetworkInterface$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getByInetAddress_java$net$InetAddress__java$net$NetworkInterface(a0?.jobj ?? nil))
    }

    private static let java$net$NetworkInterface_getNetworkInterfaces__java$util$Enumeration = svoker("getNetworkInterfaces", returns: JObjectType("java/util/Enumeration"))
    public static func getNetworkInterfaces() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$net$NetworkInterface$.java$net$NetworkInterface_getNetworkInterfaces__java$util$Enumeration())
    }

    private static let java$net$NetworkInterface_isUp__Z = invoker("isUp", returns: jboolean.jniType)
    public func isUp() throws -> jboolean {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_isUp__Z(jobj)()
    }

    private static let java$net$NetworkInterface_isLoopback__Z = invoker("isLoopback", returns: jboolean.jniType)
    public func isLoopback() throws -> jboolean {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_isLoopback__Z(jobj)()
    }

    private static let java$net$NetworkInterface_isPointToPoint__Z = invoker("isPointToPoint", returns: jboolean.jniType)
    public func isPointToPoint() throws -> jboolean {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_isPointToPoint__Z(jobj)()
    }

    private static let java$net$NetworkInterface_supportsMulticast__Z = invoker("supportsMulticast", returns: jboolean.jniType)
    public func supportsMulticast() throws -> jboolean {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_supportsMulticast__Z(jobj)()
    }

    private static let java$net$NetworkInterface_getHardwareAddress__AB = invoker("getHardwareAddress", returns: JArray(jbyte.jniType))
    public func getHardwareAddress() throws -> [jbyte]? {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_getHardwareAddress__AB(jobj)().jarrayToArray()
    }

    private static let java$net$NetworkInterface_getMTU__I = invoker("getMTU", returns: jint.jniType)
    public func getMTU() throws -> jint {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_getMTU__I(jobj)()
    }

    private static let java$net$NetworkInterface_isVirtual__Z = invoker("isVirtual", returns: jboolean.jniType)
    public func isVirtual() throws -> jboolean {
        return try java$net$NetworkInterface$.java$net$NetworkInterface_isVirtual__Z(jobj)()
    }

    private static let java$net$NetworkInterface_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$NetworkInterface_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$NetworkInterface_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$net$NetworkInterface$ = java$net$NetworkInterface

public class java$net$NoRouteToHostException : java$net$SocketException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$NoRouteToHostException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$NoRouteToHostException$.java$net$NoRouteToHostException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$NoRouteToHostException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$NoRouteToHostException$.java$net$NoRouteToHostException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$NoRouteToHostException$ = java$net$NoRouteToHostException

public class java$net$Parts : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$Parts$ = java$net$Parts

public final class java$net$PasswordAuthentication : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$PasswordAuthentication_init_java$lang$String_AC__V = constructor((JObjectType("java/lang/String"), JArray(jchar.jniType)))
    public convenience init!(_ a0: java$lang$String?, _ a1: [jchar]?) throws {
        let jobj = try java$net$PasswordAuthentication$.java$net$PasswordAuthentication_init_java$lang$String_AC__V(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$PasswordAuthentication_getUserName__java$lang$String = invoker("getUserName", returns: JObjectType("java/lang/String"))
    public func getUserName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$PasswordAuthentication$.java$net$PasswordAuthentication_getUserName__java$lang$String(jobj)())
    }

    private static let java$net$PasswordAuthentication_getPassword__AC = invoker("getPassword", returns: JArray(jchar.jniType))
    public func getPassword() throws -> [jchar]? {
        return try java$net$PasswordAuthentication$.java$net$PasswordAuthentication_getPassword__AC(jobj)().jarrayToArray()
    }

}

public typealias java$net$PasswordAuthentication$ = java$net$PasswordAuthentication

public class java$net$PlainDatagramSocketImpl : java$net$AbstractPlainDatagramSocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$PlainDatagramSocketImpl$ = java$net$PlainDatagramSocketImpl

public class java$net$PlainSocketImpl : java$net$AbstractPlainSocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$PlainSocketImpl$ = java$net$PlainSocketImpl

public class java$net$PortUnreachableException : java$net$SocketException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$PortUnreachableException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$PortUnreachableException$.java$net$PortUnreachableException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$PortUnreachableException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$PortUnreachableException$.java$net$PortUnreachableException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$PortUnreachableException$ = java$net$PortUnreachableException

public class java$net$ProtocolException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ProtocolException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$ProtocolException$.java$net$ProtocolException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$ProtocolException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ProtocolException$.java$net$ProtocolException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$ProtocolException$ = java$net$ProtocolException

public protocol java$net$ProtocolFamily : JavaObject {
    func name() throws -> java$lang$String?
}

public class java$net$ProtocolFamily$ : java$lang$Object$, java$net$ProtocolFamily {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ProtocolFamily_name__java$lang$String = invoker("name", returns: JObjectType("java/lang/String"))
}

public extension java$net$ProtocolFamily {
    func name() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$ProtocolFamily$.java$net$ProtocolFamily_name__java$lang$String(jobj)())
    }

}

public class java$net$Proxy : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Proxy_init_java$net$Proxy$Type_java$net$SocketAddress__V = constructor((JObjectType("java/net/Proxy$Type"), JObjectType("java/net/SocketAddress")))
    public convenience init!(_ a0: java$net$Proxy$Type?, _ a1: java$net$SocketAddress?) throws {
        let jobj = try java$net$Proxy$.java$net$Proxy_init_java$net$Proxy$Type_java$net$SocketAddress__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$Proxy_type__java$net$Proxy$Type = invoker("type", returns: JObjectType("java/net/Proxy$Type"))
    public func type() throws -> java$net$Proxy$Type? {
        return try java$net$Proxy$Type$(jobj: java$net$Proxy$.java$net$Proxy_type__java$net$Proxy$Type(jobj)())
    }

    private static let java$net$Proxy_address__java$net$SocketAddress = invoker("address", returns: JObjectType("java/net/SocketAddress"))
    public func address() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$Proxy$.java$net$Proxy_address__java$net$SocketAddress(jobj)())
    }

    private static let java$net$Proxy_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$Proxy_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$Proxy_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$net$Proxy$ = java$net$Proxy

public class java$net$ProxySelector : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ProxySelector_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ProxySelector$.java$net$ProxySelector_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$ProxySelector_getDefault__java$net$ProxySelector = svoker("getDefault", returns: JObjectType("java/net/ProxySelector"))
    public static func getDefault() throws -> java$net$ProxySelector? {
        return try java$net$ProxySelector$(jobj: java$net$ProxySelector$.java$net$ProxySelector_getDefault__java$net$ProxySelector())
    }

    private static let java$net$ProxySelector_setDefault_java$net$ProxySelector__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/net/ProxySelector")))
    public static func setDefault(a0: java$net$ProxySelector?) throws -> Void {
        return try java$net$ProxySelector$.java$net$ProxySelector_setDefault_java$net$ProxySelector__V(a0?.jobj ?? nil)
    }

    private static let java$net$ProxySelector_select_java$net$URI__java$util$List = invoker("select", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/net/URI")))
    public func select(a0: java$net$URI?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$ProxySelector$.java$net$ProxySelector_select_java$net$URI__java$util$List(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$ProxySelector_connectFailed_java$net$URI_java$net$SocketAddress_java$io$IOException__V = invoker("connectFailed", returns: JVoid.jniType, arguments: (JObjectType("java/net/URI"), JObjectType("java/net/SocketAddress"), JObjectType("java/io/IOException")))
    public func connectFailed(a0: java$net$URI?, _ a1: java$net$SocketAddress?, _ a2: java$io$IOException?) throws -> Void {
        return try java$net$ProxySelector$.java$net$ProxySelector_connectFailed_java$net$URI_java$net$SocketAddress_java$io$IOException__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

}

public typealias java$net$ProxySelector$ = java$net$ProxySelector

public class java$net$ResponseCache : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ResponseCache_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ResponseCache$.java$net$ResponseCache_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$ResponseCache_getDefault__java$net$ResponseCache = svoker("getDefault", returns: JObjectType("java/net/ResponseCache"))
    public static func getDefault() throws -> java$net$ResponseCache? {
        return try java$net$ResponseCache$(jobj: java$net$ResponseCache$.java$net$ResponseCache_getDefault__java$net$ResponseCache())
    }

    private static let java$net$ResponseCache_setDefault_java$net$ResponseCache__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/net/ResponseCache")))
    public static func setDefault(a0: java$net$ResponseCache?) throws -> Void {
        return try java$net$ResponseCache$.java$net$ResponseCache_setDefault_java$net$ResponseCache__V(a0?.jobj ?? nil)
    }

    private static let java$net$ResponseCache_get_java$net$URI_java$lang$String_java$util$Map__java$net$CacheResponse = invoker("get", returns: JObjectType("java/net/CacheResponse"), arguments: (JObjectType("java/net/URI"), JObjectType("java/lang/String"), JObjectType("java/util/Map")))
    public func get(a0: java$net$URI?, _ a1: java$lang$String?, _ a2: java$util$Map?) throws -> java$net$CacheResponse? {
        return try java$net$CacheResponse$(jobj: java$net$ResponseCache$.java$net$ResponseCache_get_java$net$URI_java$lang$String_java$util$Map__java$net$CacheResponse(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$net$ResponseCache_put_java$net$URI_java$net$URLConnection__java$net$CacheRequest = invoker("put", returns: JObjectType("java/net/CacheRequest"), arguments: (JObjectType("java/net/URI"), JObjectType("java/net/URLConnection")))
    public func put(a0: java$net$URI?, _ a1: java$net$URLConnection?) throws -> java$net$CacheRequest? {
        return try java$net$CacheRequest$(jobj: java$net$ResponseCache$.java$net$ResponseCache_put_java$net$URI_java$net$URLConnection__java$net$CacheRequest(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias java$net$ResponseCache$ = java$net$ResponseCache

public class java$net$SdpSocketImpl : java$net$PlainSocketImpl$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$SdpSocketImpl$ = java$net$SdpSocketImpl

public class java$net$SecureCacheResponse : java$net$CacheResponse$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SecureCacheResponse_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$SecureCacheResponse$.java$net$SecureCacheResponse_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$SecureCacheResponse_getCipherSuite__java$lang$String = invoker("getCipherSuite", returns: JObjectType("java/lang/String"))
    public func getCipherSuite() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$SecureCacheResponse$.java$net$SecureCacheResponse_getCipherSuite__java$lang$String(jobj)())
    }

    private static let java$net$SecureCacheResponse_getLocalCertificateChain__java$util$List = invoker("getLocalCertificateChain", returns: JObjectType("java/util/List"))
    public func getLocalCertificateChain() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$SecureCacheResponse$.java$net$SecureCacheResponse_getLocalCertificateChain__java$util$List(jobj)())
    }

    private static let java$net$SecureCacheResponse_getServerCertificateChain__java$util$List = invoker("getServerCertificateChain", returns: JObjectType("java/util/List"))
    public func getServerCertificateChain() throws -> java$util$List? {
        return try java$util$List$(jobj: java$net$SecureCacheResponse$.java$net$SecureCacheResponse_getServerCertificateChain__java$util$List(jobj)())
    }

    private static let java$net$SecureCacheResponse_getPeerPrincipal__java$security$Principal = invoker("getPeerPrincipal", returns: JObjectType("java/security/Principal"))
    public func getPeerPrincipal() throws -> java$security$Principal? {
        return try java$security$Principal$(jobj: java$net$SecureCacheResponse$.java$net$SecureCacheResponse_getPeerPrincipal__java$security$Principal(jobj)())
    }

    private static let java$net$SecureCacheResponse_getLocalPrincipal__java$security$Principal = invoker("getLocalPrincipal", returns: JObjectType("java/security/Principal"))
    public func getLocalPrincipal() throws -> java$security$Principal? {
        return try java$security$Principal$(jobj: java$net$SecureCacheResponse$.java$net$SecureCacheResponse_getLocalPrincipal__java$security$Principal(jobj)())
    }

}

public typealias java$net$SecureCacheResponse$ = java$net$SecureCacheResponse

public class java$net$ServerSocket : java$lang$Object$, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$ServerSocket_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$ServerSocket$.java$net$ServerSocket_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$ServerSocket_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$net$ServerSocket$.java$net$ServerSocket_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$net$ServerSocket_init_I_I__V = constructor((jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint) throws {
        let jobj = try java$net$ServerSocket$.java$net$ServerSocket_init_I_I__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$ServerSocket_init_I_I_java$net$InetAddress__V = constructor((jint.jniType, jint.jniType, JObjectType("java/net/InetAddress")))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: java$net$InetAddress?) throws {
        let jobj = try java$net$ServerSocket$.java$net$ServerSocket_init_I_I_java$net$InetAddress__V(a0, a1, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$ServerSocket_bind_java$net$SocketAddress__V = invoker("bind", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func bind(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_bind_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$ServerSocket_bind_java$net$SocketAddress_I__V = invoker("bind", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress"), jint.jniType))
    public func bind(a0: java$net$SocketAddress?, _ a1: jint) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_bind_java$net$SocketAddress_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$ServerSocket_getInetAddress__java$net$InetAddress = invoker("getInetAddress", returns: JObjectType("java/net/InetAddress"))
    public func getInetAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$ServerSocket$.java$net$ServerSocket_getInetAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$ServerSocket_getLocalPort__I = invoker("getLocalPort", returns: jint.jniType)
    public func getLocalPort() throws -> jint {
        return try java$net$ServerSocket$.java$net$ServerSocket_getLocalPort__I(jobj)()
    }

    private static let java$net$ServerSocket_getLocalSocketAddress__java$net$SocketAddress = invoker("getLocalSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getLocalSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$ServerSocket$.java$net$ServerSocket_getLocalSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$ServerSocket_accept__java$net$Socket = invoker("accept", returns: JObjectType("java/net/Socket"))
    public func accept() throws -> java$net$Socket? {
        return try java$net$Socket$(jobj: java$net$ServerSocket$.java$net$ServerSocket_accept__java$net$Socket(jobj)())
    }

    private static let java$net$ServerSocket_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_close__V(jobj)()
    }

    private static let java$net$ServerSocket_getChannel__java$nio$channels$ServerSocketChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/ServerSocketChannel"))
    public func getChannel() throws -> java$nio$channels$ServerSocketChannel? {
        return try java$nio$channels$ServerSocketChannel$(jobj: java$net$ServerSocket$.java$net$ServerSocket_getChannel__java$nio$channels$ServerSocketChannel(jobj)())
    }

    private static let java$net$ServerSocket_isBound__Z = invoker("isBound", returns: jboolean.jniType)
    public func isBound() throws -> jboolean {
        return try java$net$ServerSocket$.java$net$ServerSocket_isBound__Z(jobj)()
    }

    private static let java$net$ServerSocket_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    public func isClosed() throws -> jboolean {
        return try java$net$ServerSocket$.java$net$ServerSocket_isClosed__Z(jobj)()
    }

    private static let java$net$ServerSocket_setSoTimeout_I__V = invoker("setSoTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSoTimeout(a0: jint) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_setSoTimeout_I__V(jobj)(a0)
    }

    private static let java$net$ServerSocket_getSoTimeout__I = invoker("getSoTimeout", returns: jint.jniType)
    public func getSoTimeout() throws -> jint {
        return try java$net$ServerSocket$.java$net$ServerSocket_getSoTimeout__I(jobj)()
    }

    private static let java$net$ServerSocket_setReuseAddress_Z__V = invoker("setReuseAddress", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setReuseAddress(a0: jboolean) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_setReuseAddress_Z__V(jobj)(a0)
    }

    private static let java$net$ServerSocket_getReuseAddress__Z = invoker("getReuseAddress", returns: jboolean.jniType)
    public func getReuseAddress() throws -> jboolean {
        return try java$net$ServerSocket$.java$net$ServerSocket_getReuseAddress__Z(jobj)()
    }

    private static let java$net$ServerSocket_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$ServerSocket_setSocketFactory_java$net$SocketImplFactory__V = svoker("setSocketFactory", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketImplFactory")))
    public static func setSocketFactory(a0: java$net$SocketImplFactory?) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_setSocketFactory_java$net$SocketImplFactory__V(a0?.jobj ?? nil)
    }

    private static let java$net$ServerSocket_setReceiveBufferSize_I__V = invoker("setReceiveBufferSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setReceiveBufferSize(a0: jint) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_setReceiveBufferSize_I__V(jobj)(a0)
    }

    private static let java$net$ServerSocket_getReceiveBufferSize__I = invoker("getReceiveBufferSize", returns: jint.jniType)
    public func getReceiveBufferSize() throws -> jint {
        return try java$net$ServerSocket$.java$net$ServerSocket_getReceiveBufferSize__I(jobj)()
    }

    private static let java$net$ServerSocket_setPerformancePreferences_I_I_I__V = invoker("setPerformancePreferences", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func setPerformancePreferences(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$net$ServerSocket$.java$net$ServerSocket_setPerformancePreferences_I_I_I__V(jobj)(a0, a1, a2)
    }

}

public typealias java$net$ServerSocket$ = java$net$ServerSocket

public class java$net$Socket : java$lang$Object$, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$Socket_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$Socket$.java$net$Socket_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$net$Proxy__V = constructor((JObjectType("java/net/Proxy")))
    public convenience init!(_ a0: java$net$Proxy?) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$net$Proxy__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$net$InetAddress_I__V = constructor((JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: java$net$InetAddress?, _ a1: jint) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$net$InetAddress_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$lang$String_I_java$net$InetAddress_I__V = constructor((JObjectType("java/lang/String"), jint.jniType, JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint, _ a2: java$net$InetAddress?, _ a3: jint) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$lang$String_I_java$net$InetAddress_I__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$net$InetAddress_I_java$net$InetAddress_I__V = constructor((JObjectType("java/net/InetAddress"), jint.jniType, JObjectType("java/net/InetAddress"), jint.jniType))
    public convenience init!(_ a0: java$net$InetAddress?, _ a1: jint, _ a2: java$net$InetAddress?, _ a3: jint) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$net$InetAddress_I_java$net$InetAddress_I__V(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$lang$String_I_Z__V = constructor((JObjectType("java/lang/String"), jint.jniType, jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint, _ a2: jboolean) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$lang$String_I_Z__V(a0?.jobj ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_init_java$net$InetAddress_I_Z__V = constructor((JObjectType("java/net/InetAddress"), jint.jniType, jboolean.jniType))
    public convenience init!(_ a0: java$net$InetAddress?, _ a1: jint, _ a2: jboolean) throws {
        let jobj = try java$net$Socket$.java$net$Socket_init_java$net$InetAddress_I_Z__V(a0?.jobj ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$net$Socket_connect_java$net$SocketAddress__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func connect(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$Socket$.java$net$Socket_connect_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$Socket_connect_java$net$SocketAddress_I__V = invoker("connect", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress"), jint.jniType))
    public func connect(a0: java$net$SocketAddress?, _ a1: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_connect_java$net$SocketAddress_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$Socket_bind_java$net$SocketAddress__V = invoker("bind", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketAddress")))
    public func bind(a0: java$net$SocketAddress?) throws -> Void {
        return try java$net$Socket$.java$net$Socket_bind_java$net$SocketAddress__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$Socket_getInetAddress__java$net$InetAddress = invoker("getInetAddress", returns: JObjectType("java/net/InetAddress"))
    public func getInetAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Socket$.java$net$Socket_getInetAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$Socket_getLocalAddress__java$net$InetAddress = invoker("getLocalAddress", returns: JObjectType("java/net/InetAddress"))
    public func getLocalAddress() throws -> java$net$InetAddress? {
        return try java$net$InetAddress$(jobj: java$net$Socket$.java$net$Socket_getLocalAddress__java$net$InetAddress(jobj)())
    }

    private static let java$net$Socket_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getPort__I(jobj)()
    }

    private static let java$net$Socket_getLocalPort__I = invoker("getLocalPort", returns: jint.jniType)
    public func getLocalPort() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getLocalPort__I(jobj)()
    }

    private static let java$net$Socket_getRemoteSocketAddress__java$net$SocketAddress = invoker("getRemoteSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getRemoteSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$Socket$.java$net$Socket_getRemoteSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$Socket_getLocalSocketAddress__java$net$SocketAddress = invoker("getLocalSocketAddress", returns: JObjectType("java/net/SocketAddress"))
    public func getLocalSocketAddress() throws -> java$net$SocketAddress? {
        return try java$net$SocketAddress$(jobj: java$net$Socket$.java$net$Socket_getLocalSocketAddress__java$net$SocketAddress(jobj)())
    }

    private static let java$net$Socket_getChannel__java$nio$channels$SocketChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/SocketChannel"))
    public func getChannel() throws -> java$nio$channels$SocketChannel? {
        return try java$nio$channels$SocketChannel$(jobj: java$net$Socket$.java$net$Socket_getChannel__java$nio$channels$SocketChannel(jobj)())
    }

    private static let java$net$Socket_getInputStream__java$io$InputStream = invoker("getInputStream", returns: JObjectType("java/io/InputStream"))
    public func getInputStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$net$Socket$.java$net$Socket_getInputStream__java$io$InputStream(jobj)())
    }

    private static let java$net$Socket_getOutputStream__java$io$OutputStream = invoker("getOutputStream", returns: JObjectType("java/io/OutputStream"))
    public func getOutputStream() throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$net$Socket$.java$net$Socket_getOutputStream__java$io$OutputStream(jobj)())
    }

    private static let java$net$Socket_setTcpNoDelay_Z__V = invoker("setTcpNoDelay", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setTcpNoDelay(a0: jboolean) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setTcpNoDelay_Z__V(jobj)(a0)
    }

    private static let java$net$Socket_getTcpNoDelay__Z = invoker("getTcpNoDelay", returns: jboolean.jniType)
    public func getTcpNoDelay() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_getTcpNoDelay__Z(jobj)()
    }

    private static let java$net$Socket_setSoLinger_Z_I__V = invoker("setSoLinger", returns: JVoid.jniType, arguments: (jboolean.jniType, jint.jniType))
    public func setSoLinger(a0: jboolean, _ a1: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setSoLinger_Z_I__V(jobj)(a0, a1)
    }

    private static let java$net$Socket_getSoLinger__I = invoker("getSoLinger", returns: jint.jniType)
    public func getSoLinger() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getSoLinger__I(jobj)()
    }

    private static let java$net$Socket_sendUrgentData_I__V = invoker("sendUrgentData", returns: JVoid.jniType, arguments: (jint.jniType))
    public func sendUrgentData(a0: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_sendUrgentData_I__V(jobj)(a0)
    }

    private static let java$net$Socket_setOOBInline_Z__V = invoker("setOOBInline", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setOOBInline(a0: jboolean) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setOOBInline_Z__V(jobj)(a0)
    }

    private static let java$net$Socket_getOOBInline__Z = invoker("getOOBInline", returns: jboolean.jniType)
    public func getOOBInline() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_getOOBInline__Z(jobj)()
    }

    private static let java$net$Socket_setSoTimeout_I__V = invoker("setSoTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSoTimeout(a0: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setSoTimeout_I__V(jobj)(a0)
    }

    private static let java$net$Socket_getSoTimeout__I = invoker("getSoTimeout", returns: jint.jniType)
    public func getSoTimeout() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getSoTimeout__I(jobj)()
    }

    private static let java$net$Socket_setSendBufferSize_I__V = invoker("setSendBufferSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSendBufferSize(a0: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setSendBufferSize_I__V(jobj)(a0)
    }

    private static let java$net$Socket_getSendBufferSize__I = invoker("getSendBufferSize", returns: jint.jniType)
    public func getSendBufferSize() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getSendBufferSize__I(jobj)()
    }

    private static let java$net$Socket_setReceiveBufferSize_I__V = invoker("setReceiveBufferSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setReceiveBufferSize(a0: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setReceiveBufferSize_I__V(jobj)(a0)
    }

    private static let java$net$Socket_getReceiveBufferSize__I = invoker("getReceiveBufferSize", returns: jint.jniType)
    public func getReceiveBufferSize() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getReceiveBufferSize__I(jobj)()
    }

    private static let java$net$Socket_setKeepAlive_Z__V = invoker("setKeepAlive", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setKeepAlive(a0: jboolean) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setKeepAlive_Z__V(jobj)(a0)
    }

    private static let java$net$Socket_getKeepAlive__Z = invoker("getKeepAlive", returns: jboolean.jniType)
    public func getKeepAlive() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_getKeepAlive__Z(jobj)()
    }

    private static let java$net$Socket_setTrafficClass_I__V = invoker("setTrafficClass", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setTrafficClass(a0: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setTrafficClass_I__V(jobj)(a0)
    }

    private static let java$net$Socket_getTrafficClass__I = invoker("getTrafficClass", returns: jint.jniType)
    public func getTrafficClass() throws -> jint {
        return try java$net$Socket$.java$net$Socket_getTrafficClass__I(jobj)()
    }

    private static let java$net$Socket_setReuseAddress_Z__V = invoker("setReuseAddress", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setReuseAddress(a0: jboolean) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setReuseAddress_Z__V(jobj)(a0)
    }

    private static let java$net$Socket_getReuseAddress__Z = invoker("getReuseAddress", returns: jboolean.jniType)
    public func getReuseAddress() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_getReuseAddress__Z(jobj)()
    }

    private static let java$net$Socket_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$net$Socket$.java$net$Socket_close__V(jobj)()
    }

    private static let java$net$Socket_shutdownInput__V = invoker("shutdownInput", returns: JVoid.jniType)
    public func shutdownInput() throws -> Void {
        return try java$net$Socket$.java$net$Socket_shutdownInput__V(jobj)()
    }

    private static let java$net$Socket_shutdownOutput__V = invoker("shutdownOutput", returns: JVoid.jniType)
    public func shutdownOutput() throws -> Void {
        return try java$net$Socket$.java$net$Socket_shutdownOutput__V(jobj)()
    }

    private static let java$net$Socket_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$Socket_isConnected__Z = invoker("isConnected", returns: jboolean.jniType)
    public func isConnected() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_isConnected__Z(jobj)()
    }

    private static let java$net$Socket_isBound__Z = invoker("isBound", returns: jboolean.jniType)
    public func isBound() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_isBound__Z(jobj)()
    }

    private static let java$net$Socket_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    public func isClosed() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_isClosed__Z(jobj)()
    }

    private static let java$net$Socket_isInputShutdown__Z = invoker("isInputShutdown", returns: jboolean.jniType)
    public func isInputShutdown() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_isInputShutdown__Z(jobj)()
    }

    private static let java$net$Socket_isOutputShutdown__Z = invoker("isOutputShutdown", returns: jboolean.jniType)
    public func isOutputShutdown() throws -> jboolean {
        return try java$net$Socket$.java$net$Socket_isOutputShutdown__Z(jobj)()
    }

    private static let java$net$Socket_setSocketImplFactory_java$net$SocketImplFactory__V = svoker("setSocketImplFactory", returns: JVoid.jniType, arguments: (JObjectType("java/net/SocketImplFactory")))
    public static func setSocketImplFactory(a0: java$net$SocketImplFactory?) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setSocketImplFactory_java$net$SocketImplFactory__V(a0?.jobj ?? nil)
    }

    private static let java$net$Socket_setPerformancePreferences_I_I_I__V = invoker("setPerformancePreferences", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func setPerformancePreferences(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$net$Socket$.java$net$Socket_setPerformancePreferences_I_I_I__V(jobj)(a0, a1, a2)
    }

}

public typealias java$net$Socket$ = java$net$Socket

public class java$net$SocketAddress : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketAddress_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$SocketAddress$.java$net$SocketAddress_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$SocketAddress$ = java$net$SocketAddress

public class java$net$SocketException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$SocketException$.java$net$SocketException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$SocketException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$SocketException$.java$net$SocketException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$SocketException$ = java$net$SocketException

public class java$net$SocketImpl : java$lang$Object$, java$net$SocketOptions {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketImpl_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$SocketImpl$.java$net$SocketImpl_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$SocketImpl_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$net$SocketImpl$ = java$net$SocketImpl

public protocol java$net$SocketImplFactory : JavaObject {
    func createSocketImpl() throws -> java$net$SocketImpl?
}

public class java$net$SocketImplFactory$ : java$lang$Object$, java$net$SocketImplFactory {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketImplFactory_createSocketImpl__java$net$SocketImpl = invoker("createSocketImpl", returns: JObjectType("java/net/SocketImpl"))
}

public extension java$net$SocketImplFactory {
    func createSocketImpl() throws -> java$net$SocketImpl? {
        return try java$net$SocketImpl$(jobj: java$net$SocketImplFactory$.java$net$SocketImplFactory_createSocketImpl__java$net$SocketImpl(jobj)())
    }

}

public class java$net$SocketInputStream : java$io$FileInputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketInputStream_getChannel__java$nio$channels$FileChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/FileChannel"))
    private static let java$net$SocketInputStream_read_AB__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$net$SocketInputStream_read_AB_I_I__I = invoker("read", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$net$SocketInputStream_read__I = invoker("read", returns: jint.jniType)
    private static let java$net$SocketInputStream_skip_J__J = invoker("skip", returns: jlong.jniType, arguments: (jlong.jniType))
    private static let java$net$SocketInputStream_available__I = invoker("available", returns: jint.jniType)
    private static let java$net$SocketInputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$net$SocketInputStream$ = java$net$SocketInputStream

public protocol java$net$SocketOption : JavaObject {
    func name() throws -> java$lang$String?
    func type() throws -> java$lang$Class?
}

public class java$net$SocketOption$ : java$lang$Object$, java$net$SocketOption {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketOption_name__java$lang$String = invoker("name", returns: JObjectType("java/lang/String"))
    private static let java$net$SocketOption_type__java$lang$Class = invoker("type", returns: JObjectType("java/lang/Class"))
}

public extension java$net$SocketOption {
    func name() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$SocketOption$.java$net$SocketOption_name__java$lang$String(jobj)())
    }

    func type() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$net$SocketOption$.java$net$SocketOption_type__java$lang$Class(jobj)())
    }

}

public protocol java$net$SocketOptions : JavaObject {
    func setOption(a0: jint, _ a1: java$lang$Object?) throws -> Void
    func getOption(a0: jint) throws -> java$lang$Object?
}

public class java$net$SocketOptions$ : java$lang$Object$, java$net$SocketOptions {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketOptions_setOption_I_java$lang$Object__V = invoker("setOption", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$net$SocketOptions_getOption_I__java$lang$Object = invoker("getOption", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
}

public extension java$net$SocketOptions {
    func setOption(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$net$SocketOptions$.java$net$SocketOptions_setOption_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func getOption(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$SocketOptions$.java$net$SocketOptions_getOption_I__java$lang$Object(jobj)(a0))
    }

}

public class java$net$SocketOutputStream : java$io$FileOutputStream$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketOutputStream_getChannel__java$nio$channels$FileChannel = invoker("getChannel", returns: JObjectType("java/nio/channels/FileChannel"))
    private static let java$net$SocketOutputStream_write_I__V = invoker("write", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$net$SocketOutputStream_write_AB__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$net$SocketOutputStream_write_AB_I_I__V = invoker("write", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$net$SocketOutputStream_close__V = invoker("close", returns: JVoid.jniType)
}

public typealias java$net$SocketOutputStream$ = java$net$SocketOutputStream

public class java$net$SocketSecrets : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$SocketSecrets$ = java$net$SocketSecrets

public class java$net$SocketTimeoutException : java$io$InterruptedIOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$SocketTimeoutException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$SocketTimeoutException$.java$net$SocketTimeoutException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$SocketTimeoutException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$SocketTimeoutException$.java$net$SocketTimeoutException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$SocketTimeoutException$ = java$net$SocketTimeoutException

public protocol java$net$SocksConsts : JavaObject {
}

public class java$net$SocksConsts$ : java$lang$Object$, java$net$SocksConsts {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$net$SocksConsts {
}

public class java$net$SocksSocketImpl : java$net$PlainSocketImpl$, java$net$SocksConsts {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$SocksSocketImpl$ = java$net$SocksSocketImpl

public final class java$net$StandardProtocolFamily : java$lang$Enum$, java$net$ProtocolFamily {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$StandardProtocolFamily_values__Ajava$net$StandardProtocolFamily = svoker("values", returns: JArray(JObjectType("java/net/StandardProtocolFamily")))
    public static func values() throws -> [java$net$StandardProtocolFamily?]? {
        return try java$net$StandardProtocolFamily$.java$net$StandardProtocolFamily_values__Ajava$net$StandardProtocolFamily().jarrayToArray(java$net$StandardProtocolFamily$.self)?.map({ $0 as java$net$StandardProtocolFamily? })
    }

    private static let java$net$StandardProtocolFamily_valueOf_java$lang$String__java$net$StandardProtocolFamily = svoker("valueOf", returns: JObjectType("java/net/StandardProtocolFamily"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$net$StandardProtocolFamily? {
        return try java$net$StandardProtocolFamily$(jobj: java$net$StandardProtocolFamily$.java$net$StandardProtocolFamily_valueOf_java$lang$String__java$net$StandardProtocolFamily(a0?.jobj ?? nil))
    }

}

public typealias java$net$StandardProtocolFamily$ = java$net$StandardProtocolFamily

public final class java$net$StandardSocketOptions : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$net$StandardSocketOptions$ = java$net$StandardSocketOptions

public final class java$net$URI : java$lang$Object$, java$lang$Comparable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URI_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$URI$.java$net$URI_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_I_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jint, _ a4: java$lang$String?, _ a5: java$lang$String?, _ a6: java$lang$String?) throws {
        let jobj = try java$net$URI$.java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_I_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3, a4?.jobj ?? nil, a5?.jobj ?? nil, a6?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?, _ a4: java$lang$String?) throws {
        let jobj = try java$net$URI$.java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil, a4?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws {
        let jobj = try java$net$URI$.java$net$URI_init_java$lang$String_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URI_init_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws {
        let jobj = try java$net$URI$.java$net$URI_init_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URI_create_java$lang$String__java$net$URI = svoker("create", returns: JObjectType("java/net/URI"), arguments: (JObjectType("java/lang/String")))
    public static func create(a0: java$lang$String?) throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_create_java$lang$String__java$net$URI(a0?.jobj ?? nil))
    }

    private static let java$net$URI_parseServerAuthority__java$net$URI = invoker("parseServerAuthority", returns: JObjectType("java/net/URI"))
    public func parseServerAuthority() throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_parseServerAuthority__java$net$URI(jobj)())
    }

    private static let java$net$URI_normalize__java$net$URI = invoker("normalize", returns: JObjectType("java/net/URI"))
    public func normalize() throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_normalize__java$net$URI(jobj)())
    }

    private static let java$net$URI_resolve_java$net$URI__java$net$URI = invoker("resolve", returns: JObjectType("java/net/URI"), arguments: (JObjectType("java/net/URI")))
    public func resolve(a0: java$net$URI?) throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_resolve_java$net$URI__java$net$URI(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URI_resolve_java$lang$String__java$net$URI = invoker("resolve", returns: JObjectType("java/net/URI"), arguments: (JObjectType("java/lang/String")))
    public func resolve(a0: java$lang$String?) throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_resolve_java$lang$String__java$net$URI(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URI_relativize_java$net$URI__java$net$URI = invoker("relativize", returns: JObjectType("java/net/URI"), arguments: (JObjectType("java/net/URI")))
    public func relativize(a0: java$net$URI?) throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URI$.java$net$URI_relativize_java$net$URI__java$net$URI(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URI_toURL__java$net$URL = invoker("toURL", returns: JObjectType("java/net/URL"))
    public func toURL() throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$net$URI$.java$net$URI_toURL__java$net$URL(jobj)())
    }

    private static let java$net$URI_getScheme__java$lang$String = invoker("getScheme", returns: JObjectType("java/lang/String"))
    public func getScheme() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getScheme__java$lang$String(jobj)())
    }

    private static let java$net$URI_isAbsolute__Z = invoker("isAbsolute", returns: jboolean.jniType)
    public func isAbsolute() throws -> jboolean {
        return try java$net$URI$.java$net$URI_isAbsolute__Z(jobj)()
    }

    private static let java$net$URI_isOpaque__Z = invoker("isOpaque", returns: jboolean.jniType)
    public func isOpaque() throws -> jboolean {
        return try java$net$URI$.java$net$URI_isOpaque__Z(jobj)()
    }

    private static let java$net$URI_getRawSchemeSpecificPart__java$lang$String = invoker("getRawSchemeSpecificPart", returns: JObjectType("java/lang/String"))
    public func getRawSchemeSpecificPart() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawSchemeSpecificPart__java$lang$String(jobj)())
    }

    private static let java$net$URI_getSchemeSpecificPart__java$lang$String = invoker("getSchemeSpecificPart", returns: JObjectType("java/lang/String"))
    public func getSchemeSpecificPart() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getSchemeSpecificPart__java$lang$String(jobj)())
    }

    private static let java$net$URI_getRawAuthority__java$lang$String = invoker("getRawAuthority", returns: JObjectType("java/lang/String"))
    public func getRawAuthority() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawAuthority__java$lang$String(jobj)())
    }

    private static let java$net$URI_getAuthority__java$lang$String = invoker("getAuthority", returns: JObjectType("java/lang/String"))
    public func getAuthority() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getAuthority__java$lang$String(jobj)())
    }

    private static let java$net$URI_getRawUserInfo__java$lang$String = invoker("getRawUserInfo", returns: JObjectType("java/lang/String"))
    public func getRawUserInfo() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawUserInfo__java$lang$String(jobj)())
    }

    private static let java$net$URI_getUserInfo__java$lang$String = invoker("getUserInfo", returns: JObjectType("java/lang/String"))
    public func getUserInfo() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getUserInfo__java$lang$String(jobj)())
    }

    private static let java$net$URI_getHost__java$lang$String = invoker("getHost", returns: JObjectType("java/lang/String"))
    public func getHost() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getHost__java$lang$String(jobj)())
    }

    private static let java$net$URI_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$URI$.java$net$URI_getPort__I(jobj)()
    }

    private static let java$net$URI_getRawPath__java$lang$String = invoker("getRawPath", returns: JObjectType("java/lang/String"))
    public func getRawPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawPath__java$lang$String(jobj)())
    }

    private static let java$net$URI_getPath__java$lang$String = invoker("getPath", returns: JObjectType("java/lang/String"))
    public func getPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getPath__java$lang$String(jobj)())
    }

    private static let java$net$URI_getRawQuery__java$lang$String = invoker("getRawQuery", returns: JObjectType("java/lang/String"))
    public func getRawQuery() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawQuery__java$lang$String(jobj)())
    }

    private static let java$net$URI_getQuery__java$lang$String = invoker("getQuery", returns: JObjectType("java/lang/String"))
    public func getQuery() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getQuery__java$lang$String(jobj)())
    }

    private static let java$net$URI_getRawFragment__java$lang$String = invoker("getRawFragment", returns: JObjectType("java/lang/String"))
    public func getRawFragment() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getRawFragment__java$lang$String(jobj)())
    }

    private static let java$net$URI_getFragment__java$lang$String = invoker("getFragment", returns: JObjectType("java/lang/String"))
    public func getFragment() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_getFragment__java$lang$String(jobj)())
    }

    private static let java$net$URI_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$URI_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$URI_compareTo_java$net$URI__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/net/URI")))
    public func compareTo(a0: java$net$URI?) throws -> jint {
        return try java$net$URI$.java$net$URI_compareTo_java$net$URI__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$URI_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$URI_toASCIIString__java$lang$String = invoker("toASCIIString", returns: JObjectType("java/lang/String"))
    public func toASCIIString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URI$.java$net$URI_toASCIIString__java$lang$String(jobj)())
    }

    private static let java$net$URI_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$net$URI$.java$net$URI_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$net$URI$ = java$net$URI

public class java$net$URISyntaxException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URISyntaxException_init_java$lang$String_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint) throws {
        let jobj = try java$net$URISyntaxException$.java$net$URISyntaxException_init_java$lang$String_java$lang$String_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let java$net$URISyntaxException_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$net$URISyntaxException$.java$net$URISyntaxException_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URISyntaxException_getInput__java$lang$String = invoker("getInput", returns: JObjectType("java/lang/String"))
    public func getInput() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URISyntaxException$.java$net$URISyntaxException_getInput__java$lang$String(jobj)())
    }

    private static let java$net$URISyntaxException_getReason__java$lang$String = invoker("getReason", returns: JObjectType("java/lang/String"))
    public func getReason() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URISyntaxException$.java$net$URISyntaxException_getReason__java$lang$String(jobj)())
    }

    private static let java$net$URISyntaxException_getIndex__I = invoker("getIndex", returns: jint.jniType)
    public func getIndex() throws -> jint {
        return try java$net$URISyntaxException$.java$net$URISyntaxException_getIndex__I(jobj)()
    }

    private static let java$net$URISyntaxException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$net$URISyntaxException$ = java$net$URISyntaxException

public final class java$net$URL : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URL_init_java$lang$String_java$lang$String_I_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint, _ a3: java$lang$String?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$lang$String_java$lang$String_I_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_init_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_init_java$lang$String_java$lang$String_I_java$lang$String_java$net$URLStreamHandler__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String"), JObjectType("java/net/URLStreamHandler")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint, _ a3: java$lang$String?, _ a4: java$net$URLStreamHandler?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$lang$String_java$lang$String_I_java$lang$String_java$net$URLStreamHandler__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil, a4?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_init_java$net$URL_java$lang$String__V = constructor((JObjectType("java/net/URL"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$net$URL?, _ a1: java$lang$String?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$net$URL_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_init_java$net$URL_java$lang$String_java$net$URLStreamHandler__V = constructor((JObjectType("java/net/URL"), JObjectType("java/lang/String"), JObjectType("java/net/URLStreamHandler")))
    public convenience init!(_ a0: java$net$URL?, _ a1: java$lang$String?, _ a2: java$net$URLStreamHandler?) throws {
        let jobj = try java$net$URL$.java$net$URL_init_java$net$URL_java$lang$String_java$net$URLStreamHandler__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URL_getQuery__java$lang$String = invoker("getQuery", returns: JObjectType("java/lang/String"))
    public func getQuery() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getQuery__java$lang$String(jobj)())
    }

    private static let java$net$URL_getPath__java$lang$String = invoker("getPath", returns: JObjectType("java/lang/String"))
    public func getPath() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getPath__java$lang$String(jobj)())
    }

    private static let java$net$URL_getUserInfo__java$lang$String = invoker("getUserInfo", returns: JObjectType("java/lang/String"))
    public func getUserInfo() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getUserInfo__java$lang$String(jobj)())
    }

    private static let java$net$URL_getAuthority__java$lang$String = invoker("getAuthority", returns: JObjectType("java/lang/String"))
    public func getAuthority() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getAuthority__java$lang$String(jobj)())
    }

    private static let java$net$URL_getPort__I = invoker("getPort", returns: jint.jniType)
    public func getPort() throws -> jint {
        return try java$net$URL$.java$net$URL_getPort__I(jobj)()
    }

    private static let java$net$URL_getDefaultPort__I = invoker("getDefaultPort", returns: jint.jniType)
    public func getDefaultPort() throws -> jint {
        return try java$net$URL$.java$net$URL_getDefaultPort__I(jobj)()
    }

    private static let java$net$URL_getProtocol__java$lang$String = invoker("getProtocol", returns: JObjectType("java/lang/String"))
    public func getProtocol() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getProtocol__java$lang$String(jobj)())
    }

    private static let java$net$URL_getHost__java$lang$String = invoker("getHost", returns: JObjectType("java/lang/String"))
    public func getHost() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getHost__java$lang$String(jobj)())
    }

    private static let java$net$URL_getFile__java$lang$String = invoker("getFile", returns: JObjectType("java/lang/String"))
    public func getFile() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getFile__java$lang$String(jobj)())
    }

    private static let java$net$URL_getRef__java$lang$String = invoker("getRef", returns: JObjectType("java/lang/String"))
    public func getRef() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_getRef__java$lang$String(jobj)())
    }

    private static let java$net$URL_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$net$URL_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$net$URL_sameFile_java$net$URL__Z = invoker("sameFile", returns: jboolean.jniType, arguments: (JObjectType("java/net/URL")))
    public func sameFile(a0: java$net$URL?) throws -> jboolean {
        return try java$net$URL$.java$net$URL_sameFile_java$net$URL__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$net$URL_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$URL_toExternalForm__java$lang$String = invoker("toExternalForm", returns: JObjectType("java/lang/String"))
    public func toExternalForm() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URL$.java$net$URL_toExternalForm__java$lang$String(jobj)())
    }

    private static let java$net$URL_toURI__java$net$URI = invoker("toURI", returns: JObjectType("java/net/URI"))
    public func toURI() throws -> java$net$URI? {
        return try java$net$URI$(jobj: java$net$URL$.java$net$URL_toURI__java$net$URI(jobj)())
    }

    private static let java$net$URL_openConnection__java$net$URLConnection = invoker("openConnection", returns: JObjectType("java/net/URLConnection"))
    public func openConnection() throws -> java$net$URLConnection? {
        return try java$net$URLConnection$(jobj: java$net$URL$.java$net$URL_openConnection__java$net$URLConnection(jobj)())
    }

    private static let java$net$URL_openConnection_java$net$Proxy__java$net$URLConnection = invoker("openConnection", returns: JObjectType("java/net/URLConnection"), arguments: (JObjectType("java/net/Proxy")))
    public func openConnection(a0: java$net$Proxy?) throws -> java$net$URLConnection? {
        return try java$net$URLConnection$(jobj: java$net$URL$.java$net$URL_openConnection_java$net$Proxy__java$net$URLConnection(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URL_openStream__java$io$InputStream = invoker("openStream", returns: JObjectType("java/io/InputStream"))
    public func openStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$net$URL$.java$net$URL_openStream__java$io$InputStream(jobj)())
    }

    private static let java$net$URL_getContent__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"))
    public func getContent() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$URL$.java$net$URL_getContent__java$lang$Object(jobj)())
    }

    private static let java$net$URL_getContent_Ajava$lang$Class__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"), arguments: (JArray(JObjectType("java/lang/Class"))))
    public func getContent(a0: [java$lang$Class?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$URL$.java$net$URL_getContent_Ajava$lang$Class__java$lang$Object(jobj)(a0?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$net$URL_setURLStreamHandlerFactory_java$net$URLStreamHandlerFactory__V = svoker("setURLStreamHandlerFactory", returns: JVoid.jniType, arguments: (JObjectType("java/net/URLStreamHandlerFactory")))
    public static func setURLStreamHandlerFactory(a0: java$net$URLStreamHandlerFactory?) throws -> Void {
        return try java$net$URL$.java$net$URL_setURLStreamHandlerFactory_java$net$URLStreamHandlerFactory__V(a0?.jobj ?? nil)
    }

}

public typealias java$net$URL$ = java$net$URL

public class java$net$URLClassLoader : java$security$SecureClassLoader$, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLClassLoader_init_Ajava$net$URL_java$lang$ClassLoader__V = constructor((JArray(JObjectType("java/net/URL")), JObjectType("java/lang/ClassLoader")))
    public convenience init!(_ a0: [java$net$URL?]?, _ a1: java$lang$ClassLoader?) throws {
        let jobj = try java$net$URLClassLoader$.java$net$URLClassLoader_init_Ajava$net$URL_java$lang$ClassLoader__V(a0?.map({ java$net$URL$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URLClassLoader_init_Ajava$net$URL__V = constructor((JArray(JObjectType("java/net/URL"))))
    public convenience init!(_ a0: [java$net$URL?]?) throws {
        let jobj = try java$net$URLClassLoader$.java$net$URLClassLoader_init_Ajava$net$URL__V(a0?.map({ java$net$URL$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URLClassLoader_init_Ajava$net$URL_java$lang$ClassLoader_java$net$URLStreamHandlerFactory__V = constructor((JArray(JObjectType("java/net/URL")), JObjectType("java/lang/ClassLoader"), JObjectType("java/net/URLStreamHandlerFactory")))
    public convenience init!(_ a0: [java$net$URL?]?, _ a1: java$lang$ClassLoader?, _ a2: java$net$URLStreamHandlerFactory?) throws {
        let jobj = try java$net$URLClassLoader$.java$net$URLClassLoader_init_Ajava$net$URL_java$lang$ClassLoader_java$net$URLStreamHandlerFactory__V(a0?.map({ java$net$URL$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$URLClassLoader_getResourceAsStream_java$lang$String__java$io$InputStream = invoker("getResourceAsStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    private static let java$net$URLClassLoader_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$net$URLClassLoader$.java$net$URLClassLoader_close__V(jobj)()
    }

    private static let java$net$URLClassLoader_getURLs__Ajava$net$URL = invoker("getURLs", returns: JArray(JObjectType("java/net/URL")))
    public func getURLs() throws -> [java$net$URL?]? {
        return try java$net$URLClassLoader$.java$net$URLClassLoader_getURLs__Ajava$net$URL(jobj)().jarrayToArray(java$net$URL$.self)?.map({ $0 as java$net$URL? })
    }

    private static let java$net$URLClassLoader_findResource_java$lang$String__java$net$URL = invoker("findResource", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    public func findResource(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$net$URLClassLoader$.java$net$URLClassLoader_findResource_java$lang$String__java$net$URL(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URLClassLoader_findResources_java$lang$String__java$util$Enumeration = invoker("findResources", returns: JObjectType("java/util/Enumeration"), arguments: (JObjectType("java/lang/String")))
    public func findResources(a0: java$lang$String?) throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$net$URLClassLoader$.java$net$URLClassLoader_findResources_java$lang$String__java$util$Enumeration(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URLClassLoader_newInstance_Ajava$net$URL_java$lang$ClassLoader__java$net$URLClassLoader = svoker("newInstance", returns: JObjectType("java/net/URLClassLoader"), arguments: (JArray(JObjectType("java/net/URL")), JObjectType("java/lang/ClassLoader")))
    public static func newInstance(a0: [java$net$URL?]?, _ a1: java$lang$ClassLoader?) throws -> java$net$URLClassLoader? {
        return try java$net$URLClassLoader$(jobj: java$net$URLClassLoader$.java$net$URLClassLoader_newInstance_Ajava$net$URL_java$lang$ClassLoader__java$net$URLClassLoader(a0?.map({ java$net$URL$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil))
    }

    private static let java$net$URLClassLoader_newInstance_Ajava$net$URL__java$net$URLClassLoader = svoker("newInstance", returns: JObjectType("java/net/URLClassLoader"), arguments: (JArray(JObjectType("java/net/URL"))))
    public static func newInstance(a0: [java$net$URL?]?) throws -> java$net$URLClassLoader? {
        return try java$net$URLClassLoader$(jobj: java$net$URLClassLoader$.java$net$URLClassLoader_newInstance_Ajava$net$URL__java$net$URLClassLoader(a0?.map({ java$net$URL$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

}

public typealias java$net$URLClassLoader$ = java$net$URLClassLoader

public class java$net$URLConnection : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLConnection_getFileNameMap__java$net$FileNameMap = svoker("getFileNameMap", returns: JObjectType("java/net/FileNameMap"))
    public static func getFileNameMap() throws -> java$net$FileNameMap? {
        return try java$net$FileNameMap$(jobj: java$net$URLConnection$.java$net$URLConnection_getFileNameMap__java$net$FileNameMap())
    }

    private static let java$net$URLConnection_setFileNameMap_java$net$FileNameMap__V = svoker("setFileNameMap", returns: JVoid.jniType, arguments: (JObjectType("java/net/FileNameMap")))
    public static func setFileNameMap(a0: java$net$FileNameMap?) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setFileNameMap_java$net$FileNameMap__V(a0?.jobj ?? nil)
    }

    private static let java$net$URLConnection_connect__V = invoker("connect", returns: JVoid.jniType)
    public func connect() throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_connect__V(jobj)()
    }

    private static let java$net$URLConnection_setConnectTimeout_I__V = invoker("setConnectTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setConnectTimeout(a0: jint) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setConnectTimeout_I__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getConnectTimeout__I = invoker("getConnectTimeout", returns: jint.jniType)
    public func getConnectTimeout() throws -> jint {
        return try java$net$URLConnection$.java$net$URLConnection_getConnectTimeout__I(jobj)()
    }

    private static let java$net$URLConnection_setReadTimeout_I__V = invoker("setReadTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setReadTimeout(a0: jint) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setReadTimeout_I__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getReadTimeout__I = invoker("getReadTimeout", returns: jint.jniType)
    public func getReadTimeout() throws -> jint {
        return try java$net$URLConnection$.java$net$URLConnection_getReadTimeout__I(jobj)()
    }

    private static let java$net$URLConnection_getURL__java$net$URL = invoker("getURL", returns: JObjectType("java/net/URL"))
    public func getURL() throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$net$URLConnection$.java$net$URLConnection_getURL__java$net$URL(jobj)())
    }

    private static let java$net$URLConnection_getContentLength__I = invoker("getContentLength", returns: jint.jniType)
    public func getContentLength() throws -> jint {
        return try java$net$URLConnection$.java$net$URLConnection_getContentLength__I(jobj)()
    }

    private static let java$net$URLConnection_getContentLengthLong__J = invoker("getContentLengthLong", returns: jlong.jniType)
    public func getContentLengthLong() throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getContentLengthLong__J(jobj)()
    }

    private static let java$net$URLConnection_getContentType__java$lang$String = invoker("getContentType", returns: JObjectType("java/lang/String"))
    public func getContentType() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getContentType__java$lang$String(jobj)())
    }

    private static let java$net$URLConnection_getContentEncoding__java$lang$String = invoker("getContentEncoding", returns: JObjectType("java/lang/String"))
    public func getContentEncoding() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getContentEncoding__java$lang$String(jobj)())
    }

    private static let java$net$URLConnection_getExpiration__J = invoker("getExpiration", returns: jlong.jniType)
    public func getExpiration() throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getExpiration__J(jobj)()
    }

    private static let java$net$URLConnection_getDate__J = invoker("getDate", returns: jlong.jniType)
    public func getDate() throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getDate__J(jobj)()
    }

    private static let java$net$URLConnection_getLastModified__J = invoker("getLastModified", returns: jlong.jniType)
    public func getLastModified() throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getLastModified__J(jobj)()
    }

    private static let java$net$URLConnection_getHeaderField_java$lang$String__java$lang$String = invoker("getHeaderField", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func getHeaderField(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getHeaderField_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URLConnection_getHeaderFields__java$util$Map = invoker("getHeaderFields", returns: JObjectType("java/util/Map"))
    public func getHeaderFields() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$net$URLConnection$.java$net$URLConnection_getHeaderFields__java$util$Map(jobj)())
    }

    private static let java$net$URLConnection_getHeaderFieldInt_java$lang$String_I__I = invoker("getHeaderFieldInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func getHeaderFieldInt(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$net$URLConnection$.java$net$URLConnection_getHeaderFieldInt_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$URLConnection_getHeaderFieldLong_java$lang$String_J__J = invoker("getHeaderFieldLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    public func getHeaderFieldLong(a0: java$lang$String?, _ a1: jlong) throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getHeaderFieldLong_java$lang$String_J__J(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$URLConnection_getHeaderFieldDate_java$lang$String_J__J = invoker("getHeaderFieldDate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    public func getHeaderFieldDate(a0: java$lang$String?, _ a1: jlong) throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getHeaderFieldDate_java$lang$String_J__J(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$net$URLConnection_getHeaderFieldKey_I__java$lang$String = invoker("getHeaderFieldKey", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func getHeaderFieldKey(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getHeaderFieldKey_I__java$lang$String(jobj)(a0))
    }

    private static let java$net$URLConnection_getHeaderField_I__java$lang$String = invoker("getHeaderField", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    public func getHeaderField(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getHeaderField_I__java$lang$String(jobj)(a0))
    }

    private static let java$net$URLConnection_getContent__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"))
    public func getContent() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$URLConnection$.java$net$URLConnection_getContent__java$lang$Object(jobj)())
    }

    private static let java$net$URLConnection_getContent_Ajava$lang$Class__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"), arguments: (JArray(JObjectType("java/lang/Class"))))
    public func getContent(a0: [java$lang$Class?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$net$URLConnection$.java$net$URLConnection_getContent_Ajava$lang$Class__java$lang$Object(jobj)(a0?.map({ java$lang$Class$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$net$URLConnection_getPermission__java$security$Permission = invoker("getPermission", returns: JObjectType("java/security/Permission"))
    public func getPermission() throws -> java$security$Permission? {
        return try java$security$Permission$(jobj: java$net$URLConnection$.java$net$URLConnection_getPermission__java$security$Permission(jobj)())
    }

    private static let java$net$URLConnection_getInputStream__java$io$InputStream = invoker("getInputStream", returns: JObjectType("java/io/InputStream"))
    public func getInputStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$net$URLConnection$.java$net$URLConnection_getInputStream__java$io$InputStream(jobj)())
    }

    private static let java$net$URLConnection_getOutputStream__java$io$OutputStream = invoker("getOutputStream", returns: JObjectType("java/io/OutputStream"))
    public func getOutputStream() throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$net$URLConnection$.java$net$URLConnection_getOutputStream__java$io$OutputStream(jobj)())
    }

    private static let java$net$URLConnection_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$net$URLConnection_setDoInput_Z__V = invoker("setDoInput", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDoInput(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setDoInput_Z__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getDoInput__Z = invoker("getDoInput", returns: jboolean.jniType)
    public func getDoInput() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getDoInput__Z(jobj)()
    }

    private static let java$net$URLConnection_setDoOutput_Z__V = invoker("setDoOutput", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDoOutput(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setDoOutput_Z__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getDoOutput__Z = invoker("getDoOutput", returns: jboolean.jniType)
    public func getDoOutput() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getDoOutput__Z(jobj)()
    }

    private static let java$net$URLConnection_setAllowUserInteraction_Z__V = invoker("setAllowUserInteraction", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setAllowUserInteraction(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setAllowUserInteraction_Z__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getAllowUserInteraction__Z = invoker("getAllowUserInteraction", returns: jboolean.jniType)
    public func getAllowUserInteraction() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getAllowUserInteraction__Z(jobj)()
    }

    private static let java$net$URLConnection_setDefaultAllowUserInteraction_Z__V = svoker("setDefaultAllowUserInteraction", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public static func setDefaultAllowUserInteraction(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setDefaultAllowUserInteraction_Z__V(a0)
    }

    private static let java$net$URLConnection_getDefaultAllowUserInteraction__Z = svoker("getDefaultAllowUserInteraction", returns: jboolean.jniType)
    public static func getDefaultAllowUserInteraction() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getDefaultAllowUserInteraction__Z()
    }

    private static let java$net$URLConnection_setUseCaches_Z__V = invoker("setUseCaches", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setUseCaches(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setUseCaches_Z__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getUseCaches__Z = invoker("getUseCaches", returns: jboolean.jniType)
    public func getUseCaches() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getUseCaches__Z(jobj)()
    }

    private static let java$net$URLConnection_setIfModifiedSince_J__V = invoker("setIfModifiedSince", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setIfModifiedSince(a0: jlong) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setIfModifiedSince_J__V(jobj)(a0)
    }

    private static let java$net$URLConnection_getIfModifiedSince__J = invoker("getIfModifiedSince", returns: jlong.jniType)
    public func getIfModifiedSince() throws -> jlong {
        return try java$net$URLConnection$.java$net$URLConnection_getIfModifiedSince__J(jobj)()
    }

    private static let java$net$URLConnection_getDefaultUseCaches__Z = invoker("getDefaultUseCaches", returns: jboolean.jniType)
    public func getDefaultUseCaches() throws -> jboolean {
        return try java$net$URLConnection$.java$net$URLConnection_getDefaultUseCaches__Z(jobj)()
    }

    private static let java$net$URLConnection_setDefaultUseCaches_Z__V = invoker("setDefaultUseCaches", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDefaultUseCaches(a0: jboolean) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setDefaultUseCaches_Z__V(jobj)(a0)
    }

    private static let java$net$URLConnection_setRequestProperty_java$lang$String_java$lang$String__V = invoker("setRequestProperty", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func setRequestProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setRequestProperty_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$URLConnection_addRequestProperty_java$lang$String_java$lang$String__V = invoker("addRequestProperty", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func addRequestProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_addRequestProperty_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$URLConnection_getRequestProperty_java$lang$String__java$lang$String = invoker("getRequestProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func getRequestProperty(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getRequestProperty_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$net$URLConnection_getRequestProperties__java$util$Map = invoker("getRequestProperties", returns: JObjectType("java/util/Map"))
    public func getRequestProperties() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$net$URLConnection$.java$net$URLConnection_getRequestProperties__java$util$Map(jobj)())
    }

    private static let java$net$URLConnection_setDefaultRequestProperty_java$lang$String_java$lang$String__V = svoker("setDefaultRequestProperty", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func setDefaultRequestProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setDefaultRequestProperty_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$net$URLConnection_getDefaultRequestProperty_java$lang$String__java$lang$String = svoker("getDefaultRequestProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func getDefaultRequestProperty(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_getDefaultRequestProperty_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$net$URLConnection_setContentHandlerFactory_java$net$ContentHandlerFactory__V = svoker("setContentHandlerFactory", returns: JVoid.jniType, arguments: (JObjectType("java/net/ContentHandlerFactory")))
    public static func setContentHandlerFactory(a0: java$net$ContentHandlerFactory?) throws -> Void {
        return try java$net$URLConnection$.java$net$URLConnection_setContentHandlerFactory_java$net$ContentHandlerFactory__V(a0?.jobj ?? nil)
    }

    private static let java$net$URLConnection_guessContentTypeFromName_java$lang$String__java$lang$String = svoker("guessContentTypeFromName", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func guessContentTypeFromName(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_guessContentTypeFromName_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$net$URLConnection_guessContentTypeFromStream_java$io$InputStream__java$lang$String = svoker("guessContentTypeFromStream", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/io/InputStream")))
    public static func guessContentTypeFromStream(a0: java$io$InputStream?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLConnection$.java$net$URLConnection_guessContentTypeFromStream_java$io$InputStream__java$lang$String(a0?.jobj ?? nil))
    }

}

public typealias java$net$URLConnection$ = java$net$URLConnection

public class java$net$URLDecoder : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLDecoder_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$URLDecoder$.java$net$URLDecoder_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$URLDecoder_decode_java$lang$String__java$lang$String = svoker("decode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLDecoder$.java$net$URLDecoder_decode_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$net$URLDecoder_decode_java$lang$String_java$lang$String__java$lang$String = svoker("decode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func decode(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLDecoder$.java$net$URLDecoder_decode_java$lang$String_java$lang$String__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias java$net$URLDecoder$ = java$net$URLDecoder

public class java$net$URLEncoder : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLEncoder_encode_java$lang$String__java$lang$String = svoker("encode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public static func encode(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLEncoder$.java$net$URLEncoder_encode_java$lang$String__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$net$URLEncoder_encode_java$lang$String_java$lang$String__java$lang$String = svoker("encode", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func encode(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$net$URLEncoder$.java$net$URLEncoder_encode_java$lang$String_java$lang$String__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias java$net$URLEncoder$ = java$net$URLEncoder

public class java$net$URLStreamHandler : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLStreamHandler_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$URLStreamHandler$.java$net$URLStreamHandler_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$URLStreamHandler$ = java$net$URLStreamHandler

public protocol java$net$URLStreamHandlerFactory : JavaObject {
    func createURLStreamHandler(a0: java$lang$String?) throws -> java$net$URLStreamHandler?
}

public class java$net$URLStreamHandlerFactory$ : java$lang$Object$, java$net$URLStreamHandlerFactory {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$URLStreamHandlerFactory_createURLStreamHandler_java$lang$String__java$net$URLStreamHandler = invoker("createURLStreamHandler", returns: JObjectType("java/net/URLStreamHandler"), arguments: (JObjectType("java/lang/String")))
}

public extension java$net$URLStreamHandlerFactory {
    func createURLStreamHandler(a0: java$lang$String?) throws -> java$net$URLStreamHandler? {
        return try java$net$URLStreamHandler$(jobj: java$net$URLStreamHandlerFactory$.java$net$URLStreamHandlerFactory_createURLStreamHandler_java$lang$String__java$net$URLStreamHandler(jobj)(a0?.jobj ?? nil))
    }

}

public class java$net$UnknownContentHandler : java$net$ContentHandler$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$UnknownContentHandler_getContent_java$net$URLConnection__java$lang$Object = invoker("getContent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/net/URLConnection")))
}

public typealias java$net$UnknownContentHandler$ = java$net$UnknownContentHandler

public class java$net$UnknownHostException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$UnknownHostException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$UnknownHostException$.java$net$UnknownHostException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$net$UnknownHostException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$UnknownHostException$.java$net$UnknownHostException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$net$UnknownHostException$ = java$net$UnknownHostException

public class java$net$UnknownServiceException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$net$UnknownServiceException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$net$UnknownServiceException$.java$net$UnknownServiceException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$net$UnknownServiceException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$net$UnknownServiceException$.java$net$UnknownServiceException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$net$UnknownServiceException$ = java$net$UnknownServiceException

public class java$security$SecureClassLoader : java$lang$ClassLoader$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$security$SecureClassLoader$ = java$security$SecureClassLoader

public protocol java$sql$Array : JavaObject {
    func getBaseTypeName() throws -> java$lang$String?
    func getBaseType() throws -> jint
    func getArray() throws -> java$lang$Object?
    func getArray(a0: java$util$Map?) throws -> java$lang$Object?
    func getArray(a0: jlong, _ a1: jint) throws -> java$lang$Object?
    func getArray(a0: jlong, _ a1: jint, _ a2: java$util$Map?) throws -> java$lang$Object?
    func getResultSet() throws -> java$sql$ResultSet?
    func getResultSet(a0: java$util$Map?) throws -> java$sql$ResultSet?
    func getResultSet(a0: jlong, _ a1: jint) throws -> java$sql$ResultSet?
    func getResultSet(a0: jlong, _ a1: jint, _ a2: java$util$Map?) throws -> java$sql$ResultSet?
    func free() throws -> Void
}

public class java$sql$Array$ : java$lang$Object$, java$sql$Array {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Array_getBaseTypeName__java$lang$String = invoker("getBaseTypeName", returns: JObjectType("java/lang/String"))
    private static let java$sql$Array_getBaseType__I = invoker("getBaseType", returns: jint.jniType)
    private static let java$sql$Array_getArray__java$lang$Object = invoker("getArray", returns: JObjectType("java/lang/Object"))
    private static let java$sql$Array_getArray_java$util$Map__java$lang$Object = invoker("getArray", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Map")))
    private static let java$sql$Array_getArray_J_I__java$lang$Object = invoker("getArray", returns: JObjectType("java/lang/Object"), arguments: (jlong.jniType, jint.jniType))
    private static let java$sql$Array_getArray_J_I_java$util$Map__java$lang$Object = invoker("getArray", returns: JObjectType("java/lang/Object"), arguments: (jlong.jniType, jint.jniType, JObjectType("java/util/Map")))
    private static let java$sql$Array_getResultSet__java$sql$ResultSet = invoker("getResultSet", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$Array_getResultSet_java$util$Map__java$sql$ResultSet = invoker("getResultSet", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/util/Map")))
    private static let java$sql$Array_getResultSet_J_I__java$sql$ResultSet = invoker("getResultSet", returns: JObjectType("java/sql/ResultSet"), arguments: (jlong.jniType, jint.jniType))
    private static let java$sql$Array_getResultSet_J_I_java$util$Map__java$sql$ResultSet = invoker("getResultSet", returns: JObjectType("java/sql/ResultSet"), arguments: (jlong.jniType, jint.jniType, JObjectType("java/util/Map")))
    private static let java$sql$Array_free__V = invoker("free", returns: JVoid.jniType)
}

public extension java$sql$Array {
    func getBaseTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Array$.java$sql$Array_getBaseTypeName__java$lang$String(jobj)())
    }

    func getBaseType() throws -> jint {
        return try java$sql$Array$.java$sql$Array_getBaseType__I(jobj)()
    }

    func getArray() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Array$.java$sql$Array_getArray__java$lang$Object(jobj)())
    }

    func getArray(a0: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Array$.java$sql$Array_getArray_java$util$Map__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getArray(a0: jlong, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Array$.java$sql$Array_getArray_J_I__java$lang$Object(jobj)(a0, a1))
    }

    func getArray(a0: jlong, _ a1: jint, _ a2: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Array$.java$sql$Array_getArray_J_I_java$util$Map__java$lang$Object(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    func getResultSet() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Array$.java$sql$Array_getResultSet__java$sql$ResultSet(jobj)())
    }

    func getResultSet(a0: java$util$Map?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Array$.java$sql$Array_getResultSet_java$util$Map__java$sql$ResultSet(jobj)(a0?.jobj ?? nil))
    }

    func getResultSet(a0: jlong, _ a1: jint) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Array$.java$sql$Array_getResultSet_J_I__java$sql$ResultSet(jobj)(a0, a1))
    }

    func getResultSet(a0: jlong, _ a1: jint, _ a2: java$util$Map?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Array$.java$sql$Array_getResultSet_J_I_java$util$Map__java$sql$ResultSet(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    func free() throws -> Void {
        return try java$sql$Array$.java$sql$Array_free__V(jobj)()
    }

}

public protocol java$sql$Blob : JavaObject {
    func length() throws -> jlong
    func getBytes(a0: jlong, _ a1: jint) throws -> [jbyte]?
    func getBinaryStream() throws -> java$io$InputStream?
    func position(a0: [jbyte]?, _ a1: jlong) throws -> jlong
    func position(a0: java$sql$Blob?, _ a1: jlong) throws -> jlong
    func setBytes(a0: jlong, _ a1: [jbyte]?) throws -> jint
    func setBytes(a0: jlong, _ a1: [jbyte]?, _ a2: jint, _ a3: jint) throws -> jint
    func setBinaryStream(a0: jlong) throws -> java$io$OutputStream?
    func truncate(a0: jlong) throws -> Void
    func free() throws -> Void
    func getBinaryStream(a0: jlong, _ a1: jlong) throws -> java$io$InputStream?
}

public class java$sql$Blob$ : java$lang$Object$, java$sql$Blob {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Blob_length__J = invoker("length", returns: jlong.jniType)
    private static let java$sql$Blob_getBytes_J_I__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (jlong.jniType, jint.jniType))
    private static let java$sql$Blob_getBinaryStream__java$io$InputStream = invoker("getBinaryStream", returns: JObjectType("java/io/InputStream"))
    private static let java$sql$Blob_position_AB_J__J = invoker("position", returns: jlong.jniType, arguments: (JArray(jbyte.jniType), jlong.jniType))
    private static let java$sql$Blob_position_java$sql$Blob_J__J = invoker("position", returns: jlong.jniType, arguments: (JObjectType("java/sql/Blob"), jlong.jniType))
    private static let java$sql$Blob_setBytes_J_AB__I = invoker("setBytes", returns: jint.jniType, arguments: (jlong.jniType, JArray(jbyte.jniType)))
    private static let java$sql$Blob_setBytes_J_AB_I_I__I = invoker("setBytes", returns: jint.jniType, arguments: (jlong.jniType, JArray(jbyte.jniType), jint.jniType, jint.jniType))
    private static let java$sql$Blob_setBinaryStream_J__java$io$OutputStream = invoker("setBinaryStream", returns: JObjectType("java/io/OutputStream"), arguments: (jlong.jniType))
    private static let java$sql$Blob_truncate_J__V = invoker("truncate", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Blob_free__V = invoker("free", returns: JVoid.jniType)
    private static let java$sql$Blob_getBinaryStream_J_J__java$io$InputStream = invoker("getBinaryStream", returns: JObjectType("java/io/InputStream"), arguments: (jlong.jniType, jlong.jniType))
}

public extension java$sql$Blob {
    func length() throws -> jlong {
        return try java$sql$Blob$.java$sql$Blob_length__J(jobj)()
    }

    func getBytes(a0: jlong, _ a1: jint) throws -> [jbyte]? {
        return try java$sql$Blob$.java$sql$Blob_getBytes_J_I__AB(jobj)(a0, a1).jarrayToArray()
    }

    func getBinaryStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$Blob$.java$sql$Blob_getBinaryStream__java$io$InputStream(jobj)())
    }

    func position(a0: [jbyte]?, _ a1: jlong) throws -> jlong {
        return try java$sql$Blob$.java$sql$Blob_position_AB_J__J(jobj)(a0?.arrayToJArray() ?? nil, a1)
    }

    func position(a0: java$sql$Blob?, _ a1: jlong) throws -> jlong {
        return try java$sql$Blob$.java$sql$Blob_position_java$sql$Blob_J__J(jobj)(a0?.jobj ?? nil, a1)
    }

    func setBytes(a0: jlong, _ a1: [jbyte]?) throws -> jint {
        return try java$sql$Blob$.java$sql$Blob_setBytes_J_AB__I(jobj)(a0, a1?.arrayToJArray() ?? nil)
    }

    func setBytes(a0: jlong, _ a1: [jbyte]?, _ a2: jint, _ a3: jint) throws -> jint {
        return try java$sql$Blob$.java$sql$Blob_setBytes_J_AB_I_I__I(jobj)(a0, a1?.arrayToJArray() ?? nil, a2, a3)
    }

    func setBinaryStream(a0: jlong) throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$sql$Blob$.java$sql$Blob_setBinaryStream_J__java$io$OutputStream(jobj)(a0))
    }

    func truncate(a0: jlong) throws -> Void {
        return try java$sql$Blob$.java$sql$Blob_truncate_J__V(jobj)(a0)
    }

    func free() throws -> Void {
        return try java$sql$Blob$.java$sql$Blob_free__V(jobj)()
    }

    func getBinaryStream(a0: jlong, _ a1: jlong) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$Blob$.java$sql$Blob_getBinaryStream_J_J__java$io$InputStream(jobj)(a0, a1))
    }

}

public protocol java$sql$CallableStatement : java$sql$PreparedStatement {
    func registerOutParameter(a0: jint, _ a1: jint) throws -> Void
    func registerOutParameter(a0: jint, _ a1: jint, _ a2: jint) throws -> Void
    func wasNull() throws -> jboolean
    func getString(a0: jint) throws -> java$lang$String?
    func getBoolean(a0: jint) throws -> jboolean
    func getByte(a0: jint) throws -> jbyte
    func getShort(a0: jint) throws -> jshort
    func getInt(a0: jint) throws -> jint
    func getLong(a0: jint) throws -> jlong
    func getFloat(a0: jint) throws -> jfloat
    func getDouble(a0: jint) throws -> jdouble
    func getBigDecimal(a0: jint, _ a1: jint) throws -> java$math$BigDecimal?
    func getBytes(a0: jint) throws -> [jbyte]?
    func getDate(a0: jint) throws -> java$sql$Date?
    func getTime(a0: jint) throws -> java$sql$Time?
    func getTimestamp(a0: jint) throws -> java$sql$Timestamp?
    func getObject(a0: jint) throws -> java$lang$Object?
    func getBigDecimal(a0: jint) throws -> java$math$BigDecimal?
    func getObject(a0: jint, _ a1: java$util$Map?) throws -> java$lang$Object?
    func getRef(a0: jint) throws -> java$sql$Ref?
    func getBlob(a0: jint) throws -> java$sql$Blob?
    func getClob(a0: jint) throws -> java$sql$Clob?
    func getArray(a0: jint) throws -> java$sql$Array?
    func getDate(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Date?
    func getTime(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Time?
    func getTimestamp(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp?
    func registerOutParameter(a0: jint, _ a1: jint, _ a2: java$lang$String?) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: jint) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: jint, _ a2: java$lang$String?) throws -> Void
    func getURL(a0: jint) throws -> java$net$URL?
    func setURL(a0: java$lang$String?, _ a1: java$net$URL?) throws -> Void
    func setNull(a0: java$lang$String?, _ a1: jint) throws -> Void
    func setBoolean(a0: java$lang$String?, _ a1: jboolean) throws -> Void
    func setByte(a0: java$lang$String?, _ a1: jbyte) throws -> Void
    func setShort(a0: java$lang$String?, _ a1: jshort) throws -> Void
    func setInt(a0: java$lang$String?, _ a1: jint) throws -> Void
    func setLong(a0: java$lang$String?, _ a1: jlong) throws -> Void
    func setFloat(a0: java$lang$String?, _ a1: jfloat) throws -> Void
    func setDouble(a0: java$lang$String?, _ a1: jdouble) throws -> Void
    func setBigDecimal(a0: java$lang$String?, _ a1: java$math$BigDecimal?) throws -> Void
    func setString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void
    func setBytes(a0: java$lang$String?, _ a1: [jbyte]?) throws -> Void
    func setDate(a0: java$lang$String?, _ a1: java$sql$Date?) throws -> Void
    func setTime(a0: java$lang$String?, _ a1: java$sql$Time?) throws -> Void
    func setTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?) throws -> Void
    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint) throws -> Void
    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void
    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void
    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jint) throws -> Void
    func setDate(a0: java$lang$String?, _ a1: java$sql$Date?, _ a2: java$util$Calendar?) throws -> Void
    func setTime(a0: java$lang$String?, _ a1: java$sql$Time?, _ a2: java$util$Calendar?) throws -> Void
    func setTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?, _ a2: java$util$Calendar?) throws -> Void
    func setNull(a0: java$lang$String?, _ a1: jint, _ a2: java$lang$String?) throws -> Void
    func getString(a0: java$lang$String?) throws -> java$lang$String?
    func getBoolean(a0: java$lang$String?) throws -> jboolean
    func getByte(a0: java$lang$String?) throws -> jbyte
    func getShort(a0: java$lang$String?) throws -> jshort
    func getInt(a0: java$lang$String?) throws -> jint
    func getLong(a0: java$lang$String?) throws -> jlong
    func getFloat(a0: java$lang$String?) throws -> jfloat
    func getDouble(a0: java$lang$String?) throws -> jdouble
    func getBytes(a0: java$lang$String?) throws -> [jbyte]?
    func getDate(a0: java$lang$String?) throws -> java$sql$Date?
    func getTime(a0: java$lang$String?) throws -> java$sql$Time?
    func getTimestamp(a0: java$lang$String?) throws -> java$sql$Timestamp?
    func getObject(a0: java$lang$String?) throws -> java$lang$Object?
    func getBigDecimal(a0: java$lang$String?) throws -> java$math$BigDecimal?
    func getObject(a0: java$lang$String?, _ a1: java$util$Map?) throws -> java$lang$Object?
    func getRef(a0: java$lang$String?) throws -> java$sql$Ref?
    func getBlob(a0: java$lang$String?) throws -> java$sql$Blob?
    func getClob(a0: java$lang$String?) throws -> java$sql$Clob?
    func getArray(a0: java$lang$String?) throws -> java$sql$Array?
    func getDate(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Date?
    func getTime(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Time?
    func getTimestamp(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp?
    func getURL(a0: java$lang$String?) throws -> java$net$URL?
    func getRowId(a0: jint) throws -> java$sql$RowId?
    func getRowId(a0: java$lang$String?) throws -> java$sql$RowId?
    func setRowId(a0: java$lang$String?, _ a1: java$sql$RowId?) throws -> Void
    func setNString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void
    func setNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setNClob(a0: java$lang$String?, _ a1: java$sql$NClob?) throws -> Void
    func setClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setBlob(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setNClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func getNClob(a0: jint) throws -> java$sql$NClob?
    func getNClob(a0: java$lang$String?) throws -> java$sql$NClob?
    func setSQLXML(a0: java$lang$String?, _ a1: java$sql$SQLXML?) throws -> Void
    func getSQLXML(a0: jint) throws -> java$sql$SQLXML?
    func getSQLXML(a0: java$lang$String?) throws -> java$sql$SQLXML?
    func getNString(a0: jint) throws -> java$lang$String?
    func getNString(a0: java$lang$String?) throws -> java$lang$String?
    func getNCharacterStream(a0: jint) throws -> java$io$Reader?
    func getNCharacterStream(a0: java$lang$String?) throws -> java$io$Reader?
    func getCharacterStream(a0: jint) throws -> java$io$Reader?
    func getCharacterStream(a0: java$lang$String?) throws -> java$io$Reader?
    func setBlob(a0: java$lang$String?, _ a1: java$sql$Blob?) throws -> Void
    func setClob(a0: java$lang$String?, _ a1: java$sql$Clob?) throws -> Void
    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func setNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func setClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func setBlob(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func setNClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func getObject(a0: jint, _ a1: java$lang$Class?) throws -> java$lang$Object?
    func getObject(a0: java$lang$String?, _ a1: java$lang$Class?) throws -> java$lang$Object?
    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void
    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void
    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?) throws -> Void
    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?, _ a2: jint) throws -> Void
    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?, _ a2: java$lang$String?) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?, _ a2: jint) throws -> Void
    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?, _ a2: java$lang$String?) throws -> Void
}

public class java$sql$CallableStatement$ : java$lang$Object$, java$sql$CallableStatement, java$sql$PreparedStatement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$CallableStatement_registerOutParameter_I_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$CallableStatement_registerOutParameter_I_I_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    private static let java$sql$CallableStatement_wasNull__Z = invoker("wasNull", returns: jboolean.jniType)
    private static let java$sql$CallableStatement_getString_I__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getBoolean_I__Z = invoker("getBoolean", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getByte_I__B = invoker("getByte", returns: jbyte.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getShort_I__S = invoker("getShort", returns: jshort.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getInt_I__I = invoker("getInt", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getLong_I__J = invoker("getLong", returns: jlong.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getFloat_I__F = invoker("getFloat", returns: jfloat.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getDouble_I__D = invoker("getDouble", returns: jdouble.jniType, arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getBigDecimal_I_I__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType, jint.jniType))
    private static let java$sql$CallableStatement_getBytes_I__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getDate_I__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getTime_I__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getTimestamp_I__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getObject_I__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getBigDecimal_I__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getObject_I_java$util$Map__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/util/Map")))
    private static let java$sql$CallableStatement_getRef_I__java$sql$Ref = invoker("getRef", returns: JObjectType("java/sql/Ref"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getBlob_I__java$sql$Blob = invoker("getBlob", returns: JObjectType("java/sql/Blob"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getClob_I__java$sql$Clob = invoker("getClob", returns: JObjectType("java/sql/Clob"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getArray_I__java$sql$Array = invoker("getArray", returns: JObjectType("java/sql/Array"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getDate_I_java$util$Calendar__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_getTime_I_java$util$Calendar__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_getTimestamp_I_java$util$Calendar__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_registerOutParameter_I_I_java$lang$String__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_I_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_I_java$lang$String__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getURL_I__java$net$URL = invoker("getURL", returns: JObjectType("java/net/URL"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_setURL_java$lang$String_java$net$URL__V = invoker("setURL", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/net/URL")))
    private static let java$sql$CallableStatement_setNull_java$lang$String_I__V = invoker("setNull", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$CallableStatement_setBoolean_java$lang$String_Z__V = invoker("setBoolean", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jboolean.jniType))
    private static let java$sql$CallableStatement_setByte_java$lang$String_B__V = invoker("setByte", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jbyte.jniType))
    private static let java$sql$CallableStatement_setShort_java$lang$String_S__V = invoker("setShort", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jshort.jniType))
    private static let java$sql$CallableStatement_setInt_java$lang$String_I__V = invoker("setInt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$CallableStatement_setLong_java$lang$String_J__V = invoker("setLong", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    private static let java$sql$CallableStatement_setFloat_java$lang$String_F__V = invoker("setFloat", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jfloat.jniType))
    private static let java$sql$CallableStatement_setDouble_java$lang$String_D__V = invoker("setDouble", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jdouble.jniType))
    private static let java$sql$CallableStatement_setBigDecimal_java$lang$String_java$math$BigDecimal__V = invoker("setBigDecimal", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/math/BigDecimal")))
    private static let java$sql$CallableStatement_setString_java$lang$String_java$lang$String__V = invoker("setString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_setBytes_java$lang$String_AB__V = invoker("setBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JArray(jbyte.jniType)))
    private static let java$sql$CallableStatement_setDate_java$lang$String_java$sql$Date__V = invoker("setDate", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Date")))
    private static let java$sql$CallableStatement_setTime_java$lang$String_java$sql$Time__V = invoker("setTime", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Time")))
    private static let java$sql$CallableStatement_setTimestamp_java$lang$String_java$sql$Timestamp__V = invoker("setTimestamp", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Timestamp")))
    private static let java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream_I__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream_I__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_I_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), jint.jniType, jint.jniType))
    private static let java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), jint.jniType))
    private static let java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    private static let java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader_I__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jint.jniType))
    private static let java$sql$CallableStatement_setDate_java$lang$String_java$sql$Date_java$util$Calendar__V = invoker("setDate", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Date"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_setTime_java$lang$String_java$sql$Time_java$util$Calendar__V = invoker("setTime", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Time"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_setTimestamp_java$lang$String_java$sql$Timestamp_java$util$Calendar__V = invoker("setTimestamp", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Timestamp"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_setNull_java$lang$String_I_java$lang$String__V = invoker("setNull", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getString_java$lang$String__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getBoolean_java$lang$String__Z = invoker("getBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getByte_java$lang$String__B = invoker("getByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getShort_java$lang$String__S = invoker("getShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getInt_java$lang$String__I = invoker("getInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getLong_java$lang$String__J = invoker("getLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getFloat_java$lang$String__F = invoker("getFloat", returns: jfloat.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getDouble_java$lang$String__D = invoker("getDouble", returns: jdouble.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getBytes_java$lang$String__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getDate_java$lang$String__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getTime_java$lang$String__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getTimestamp_java$lang$String__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getObject_java$lang$String__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getBigDecimal_java$lang$String__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getObject_java$lang$String_java$util$Map__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Map")))
    private static let java$sql$CallableStatement_getRef_java$lang$String__java$sql$Ref = invoker("getRef", returns: JObjectType("java/sql/Ref"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getBlob_java$lang$String__java$sql$Blob = invoker("getBlob", returns: JObjectType("java/sql/Blob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getClob_java$lang$String__java$sql$Clob = invoker("getClob", returns: JObjectType("java/sql/Clob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getArray_java$lang$String__java$sql$Array = invoker("getArray", returns: JObjectType("java/sql/Array"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getDate_java$lang$String_java$util$Calendar__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_getTime_java$lang$String_java$util$Calendar__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_getTimestamp_java$lang$String_java$util$Calendar__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$CallableStatement_getURL_java$lang$String__java$net$URL = invoker("getURL", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getRowId_I__java$sql$RowId = invoker("getRowId", returns: JObjectType("java/sql/RowId"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getRowId_java$lang$String__java$sql$RowId = invoker("getRowId", returns: JObjectType("java/sql/RowId"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_setRowId_java$lang$String_java$sql$RowId__V = invoker("setRowId", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/RowId")))
    private static let java$sql$CallableStatement_setNString_java$lang$String_java$lang$String__V = invoker("setNString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_setNCharacterStream_java$lang$String_java$io$Reader_J__V = invoker("setNCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$CallableStatement_setNClob_java$lang$String_java$sql$NClob__V = invoker("setNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/NClob")))
    private static let java$sql$CallableStatement_setClob_java$lang$String_java$io$Reader_J__V = invoker("setClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$CallableStatement_setBlob_java$lang$String_java$io$InputStream_J__V = invoker("setBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$CallableStatement_setNClob_java$lang$String_java$io$Reader_J__V = invoker("setNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$CallableStatement_getNClob_I__java$sql$NClob = invoker("getNClob", returns: JObjectType("java/sql/NClob"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getNClob_java$lang$String__java$sql$NClob = invoker("getNClob", returns: JObjectType("java/sql/NClob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_setSQLXML_java$lang$String_java$sql$SQLXML__V = invoker("setSQLXML", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/SQLXML")))
    private static let java$sql$CallableStatement_getSQLXML_I__java$sql$SQLXML = invoker("getSQLXML", returns: JObjectType("java/sql/SQLXML"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getSQLXML_java$lang$String__java$sql$SQLXML = invoker("getSQLXML", returns: JObjectType("java/sql/SQLXML"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getNString_I__java$lang$String = invoker("getNString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getNString_java$lang$String__java$lang$String = invoker("getNString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getNCharacterStream_I__java$io$Reader = invoker("getNCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getNCharacterStream_java$lang$String__java$io$Reader = invoker("getNCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_getCharacterStream_I__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (jint.jniType))
    private static let java$sql$CallableStatement_getCharacterStream_java$lang$String__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_setBlob_java$lang$String_java$sql$Blob__V = invoker("setBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Blob")))
    private static let java$sql$CallableStatement_setClob_java$lang$String_java$sql$Clob__V = invoker("setClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Clob")))
    private static let java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream_J__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream_J__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader_J__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$CallableStatement_setNCharacterStream_java$lang$String_java$io$Reader__V = invoker("setNCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$CallableStatement_setClob_java$lang$String_java$io$Reader__V = invoker("setClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$CallableStatement_setBlob_java$lang$String_java$io$InputStream__V = invoker("setBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$CallableStatement_setNClob_java$lang$String_java$io$Reader__V = invoker("setNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$CallableStatement_getObject_I_java$lang$Class__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Class")))
    private static let java$sql$CallableStatement_getObject_java$lang$String_java$lang$Class__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Class")))
    private static let java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_java$sql$SQLType_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_java$sql$SQLType__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType")))
    private static let java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/SQLType")))
    private static let java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType_java$lang$String__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/SQLType"), JObjectType("java/lang/String")))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/SQLType")))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType_I__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType_java$lang$String__V = invoker("registerOutParameter", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/SQLType"), JObjectType("java/lang/String")))
}

public extension java$sql$CallableStatement {
    func registerOutParameter(a0: jint, _ a1: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_I__V(jobj)(a0, a1)
    }

    func registerOutParameter(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_I_I__V(jobj)(a0, a1, a2)
    }

    func wasNull() throws -> jboolean {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_wasNull__Z(jobj)()
    }

    func getString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getString_I__java$lang$String(jobj)(a0))
    }

    func getBoolean(a0: jint) throws -> jboolean {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getBoolean_I__Z(jobj)(a0)
    }

    func getByte(a0: jint) throws -> jbyte {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getByte_I__B(jobj)(a0)
    }

    func getShort(a0: jint) throws -> jshort {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getShort_I__S(jobj)(a0)
    }

    func getInt(a0: jint) throws -> jint {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getInt_I__I(jobj)(a0)
    }

    func getLong(a0: jint) throws -> jlong {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getLong_I__J(jobj)(a0)
    }

    func getFloat(a0: jint) throws -> jfloat {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getFloat_I__F(jobj)(a0)
    }

    func getDouble(a0: jint) throws -> jdouble {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getDouble_I__D(jobj)(a0)
    }

    func getBigDecimal(a0: jint, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getBigDecimal_I_I__java$math$BigDecimal(jobj)(a0, a1))
    }

    func getBytes(a0: jint) throws -> [jbyte]? {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getBytes_I__AB(jobj)(a0).jarrayToArray()
    }

    func getDate(a0: jint) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getDate_I__java$sql$Date(jobj)(a0))
    }

    func getTime(a0: jint) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTime_I__java$sql$Time(jobj)(a0))
    }

    func getTimestamp(a0: jint) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTimestamp_I__java$sql$Timestamp(jobj)(a0))
    }

    func getObject(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_I__java$lang$Object(jobj)(a0))
    }

    func getBigDecimal(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getBigDecimal_I__java$math$BigDecimal(jobj)(a0))
    }

    func getObject(a0: jint, _ a1: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_I_java$util$Map__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    func getRef(a0: jint) throws -> java$sql$Ref? {
        return try java$sql$Ref$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getRef_I__java$sql$Ref(jobj)(a0))
    }

    func getBlob(a0: jint) throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getBlob_I__java$sql$Blob(jobj)(a0))
    }

    func getClob(a0: jint) throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getClob_I__java$sql$Clob(jobj)(a0))
    }

    func getArray(a0: jint) throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getArray_I__java$sql$Array(jobj)(a0))
    }

    func getDate(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getDate_I_java$util$Calendar__java$sql$Date(jobj)(a0, a1?.jobj ?? nil))
    }

    func getTime(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTime_I_java$util$Calendar__java$sql$Time(jobj)(a0, a1?.jobj ?? nil))
    }

    func getTimestamp(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTimestamp_I_java$util$Calendar__java$sql$Timestamp(jobj)(a0, a1?.jobj ?? nil))
    }

    func registerOutParameter(a0: jint, _ a1: jint, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_I_java$lang$String__V(jobj)(a0, a1, a2?.jobj ?? nil)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_I_I__V(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: jint, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_I_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
    }

    func getURL(a0: jint) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getURL_I__java$net$URL(jobj)(a0))
    }

    func setURL(a0: java$lang$String?, _ a1: java$net$URL?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setURL_java$lang$String_java$net$URL__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setNull(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNull_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setBoolean(a0: java$lang$String?, _ a1: jboolean) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBoolean_java$lang$String_Z__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setByte(a0: java$lang$String?, _ a1: jbyte) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setByte_java$lang$String_B__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setShort(a0: java$lang$String?, _ a1: jshort) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setShort_java$lang$String_S__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setInt(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setInt_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setLong(a0: java$lang$String?, _ a1: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setLong_java$lang$String_J__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setFloat(a0: java$lang$String?, _ a1: jfloat) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setFloat_java$lang$String_F__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setDouble(a0: java$lang$String?, _ a1: jdouble) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setDouble_java$lang$String_D__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func setBigDecimal(a0: java$lang$String?, _ a1: java$math$BigDecimal?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBigDecimal_java$lang$String_java$math$BigDecimal__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setString_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setBytes(a0: java$lang$String?, _ a1: [jbyte]?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBytes_java$lang$String_AB__V(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
    }

    func setDate(a0: java$lang$String?, _ a1: java$sql$Date?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setDate_java$lang$String_java$sql$Date__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setTime(a0: java$lang$String?, _ a1: java$sql$Time?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setTime_java$lang$String_java$sql$Time__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setTimestamp_java$lang$String_java$sql$Timestamp__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_I_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3)
    }

    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setDate(a0: java$lang$String?, _ a1: java$sql$Date?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setDate_java$lang$String_java$sql$Date_java$util$Calendar__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setTime(a0: java$lang$String?, _ a1: java$sql$Time?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setTime_java$lang$String_java$sql$Time_java$util$Calendar__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setTimestamp_java$lang$String_java$sql$Timestamp_java$util$Calendar__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setNull(a0: java$lang$String?, _ a1: jint, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNull_java$lang$String_I_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil)
    }

    func getString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getBoolean(a0: java$lang$String?) throws -> jboolean {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getBoolean_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    func getByte(a0: java$lang$String?) throws -> jbyte {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getByte_java$lang$String__B(jobj)(a0?.jobj ?? nil)
    }

    func getShort(a0: java$lang$String?) throws -> jshort {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getShort_java$lang$String__S(jobj)(a0?.jobj ?? nil)
    }

    func getInt(a0: java$lang$String?) throws -> jint {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getInt_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    func getLong(a0: java$lang$String?) throws -> jlong {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getLong_java$lang$String__J(jobj)(a0?.jobj ?? nil)
    }

    func getFloat(a0: java$lang$String?) throws -> jfloat {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getFloat_java$lang$String__F(jobj)(a0?.jobj ?? nil)
    }

    func getDouble(a0: java$lang$String?) throws -> jdouble {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getDouble_java$lang$String__D(jobj)(a0?.jobj ?? nil)
    }

    func getBytes(a0: java$lang$String?) throws -> [jbyte]? {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_getBytes_java$lang$String__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    func getDate(a0: java$lang$String?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getDate_java$lang$String__java$sql$Date(jobj)(a0?.jobj ?? nil))
    }

    func getTime(a0: java$lang$String?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTime_java$lang$String__java$sql$Time(jobj)(a0?.jobj ?? nil))
    }

    func getTimestamp(a0: java$lang$String?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTimestamp_java$lang$String__java$sql$Timestamp(jobj)(a0?.jobj ?? nil))
    }

    func getObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getBigDecimal(a0: java$lang$String?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getBigDecimal_java$lang$String__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    func getObject(a0: java$lang$String?, _ a1: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_java$lang$String_java$util$Map__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getRef(a0: java$lang$String?) throws -> java$sql$Ref? {
        return try java$sql$Ref$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getRef_java$lang$String__java$sql$Ref(jobj)(a0?.jobj ?? nil))
    }

    func getBlob(a0: java$lang$String?) throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getBlob_java$lang$String__java$sql$Blob(jobj)(a0?.jobj ?? nil))
    }

    func getClob(a0: java$lang$String?) throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getClob_java$lang$String__java$sql$Clob(jobj)(a0?.jobj ?? nil))
    }

    func getArray(a0: java$lang$String?) throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getArray_java$lang$String__java$sql$Array(jobj)(a0?.jobj ?? nil))
    }

    func getDate(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getDate_java$lang$String_java$util$Calendar__java$sql$Date(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getTime(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTime_java$lang$String_java$util$Calendar__java$sql$Time(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getTimestamp(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getTimestamp_java$lang$String_java$util$Calendar__java$sql$Timestamp(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getURL(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getURL_java$lang$String__java$net$URL(jobj)(a0?.jobj ?? nil))
    }

    func getRowId(a0: jint) throws -> java$sql$RowId? {
        return try java$sql$RowId$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getRowId_I__java$sql$RowId(jobj)(a0))
    }

    func getRowId(a0: java$lang$String?) throws -> java$sql$RowId? {
        return try java$sql$RowId$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getRowId_java$lang$String__java$sql$RowId(jobj)(a0?.jobj ?? nil))
    }

    func setRowId(a0: java$lang$String?, _ a1: java$sql$RowId?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setRowId_java$lang$String_java$sql$RowId__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setNString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNString_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNCharacterStream_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setNClob(a0: java$lang$String?, _ a1: java$sql$NClob?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNClob_java$lang$String_java$sql$NClob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setClob_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setBlob(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBlob_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setNClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNClob_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func getNClob(a0: jint) throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNClob_I__java$sql$NClob(jobj)(a0))
    }

    func getNClob(a0: java$lang$String?) throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNClob_java$lang$String__java$sql$NClob(jobj)(a0?.jobj ?? nil))
    }

    func setSQLXML(a0: java$lang$String?, _ a1: java$sql$SQLXML?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setSQLXML_java$lang$String_java$sql$SQLXML__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getSQLXML(a0: jint) throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getSQLXML_I__java$sql$SQLXML(jobj)(a0))
    }

    func getSQLXML(a0: java$lang$String?) throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getSQLXML_java$lang$String__java$sql$SQLXML(jobj)(a0?.jobj ?? nil))
    }

    func getNString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNString_I__java$lang$String(jobj)(a0))
    }

    func getNString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getNCharacterStream(a0: jint) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNCharacterStream_I__java$io$Reader(jobj)(a0))
    }

    func getNCharacterStream(a0: java$lang$String?) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getNCharacterStream_java$lang$String__java$io$Reader(jobj)(a0?.jobj ?? nil))
    }

    func getCharacterStream(a0: jint) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getCharacterStream_I__java$io$Reader(jobj)(a0))
    }

    func getCharacterStream(a0: java$lang$String?) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getCharacterStream_java$lang$String__java$io$Reader(jobj)(a0?.jobj ?? nil))
    }

    func setBlob(a0: java$lang$String?, _ a1: java$sql$Blob?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBlob_java$lang$String_java$sql$Blob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setClob(a0: java$lang$String?, _ a1: java$sql$Clob?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setClob_java$lang$String_java$sql$Clob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func setAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setAsciiStream_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBinaryStream_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setCharacterStream_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNCharacterStream_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setClob_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setBlob(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setBlob_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setNClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setNClob_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getObject(a0: jint, _ a1: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_I_java$lang$Class__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    func getObject(a0: java$lang$String?, _ a1: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$CallableStatement$.java$sql$CallableStatement_getObject_java$lang$String_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_java$sql$SQLType_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
    }

    func setObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_setObject_java$lang$String_java$lang$Object_java$sql$SQLType__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func registerOutParameter(a0: jint, _ a1: java$sql$SQLType?, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_I_java$sql$SQLType_java$lang$String__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?, _ a2: jint) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func registerOutParameter(a0: java$lang$String?, _ a1: java$sql$SQLType?, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$CallableStatement$.java$sql$CallableStatement_registerOutParameter_java$lang$String_java$sql$SQLType_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

}

public final class java$sql$ClientInfoStatus : java$lang$Enum$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$ClientInfoStatus_values__Ajava$sql$ClientInfoStatus = svoker("values", returns: JArray(JObjectType("java/sql/ClientInfoStatus")))
    public static func values() throws -> [java$sql$ClientInfoStatus?]? {
        return try java$sql$ClientInfoStatus$.java$sql$ClientInfoStatus_values__Ajava$sql$ClientInfoStatus().jarrayToArray(java$sql$ClientInfoStatus$.self)?.map({ $0 as java$sql$ClientInfoStatus? })
    }

    private static let java$sql$ClientInfoStatus_valueOf_java$lang$String__java$sql$ClientInfoStatus = svoker("valueOf", returns: JObjectType("java/sql/ClientInfoStatus"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$ClientInfoStatus? {
        return try java$sql$ClientInfoStatus$(jobj: java$sql$ClientInfoStatus$.java$sql$ClientInfoStatus_valueOf_java$lang$String__java$sql$ClientInfoStatus(a0?.jobj ?? nil))
    }

}

public typealias java$sql$ClientInfoStatus$ = java$sql$ClientInfoStatus

public protocol java$sql$Clob : JavaObject {
    func length() throws -> jlong
    func getSubString(a0: jlong, _ a1: jint) throws -> java$lang$String?
    func getCharacterStream() throws -> java$io$Reader?
    func getAsciiStream() throws -> java$io$InputStream?
    func position(a0: java$lang$String?, _ a1: jlong) throws -> jlong
    func position(a0: java$sql$Clob?, _ a1: jlong) throws -> jlong
    func setString(a0: jlong, _ a1: java$lang$String?) throws -> jint
    func setString(a0: jlong, _ a1: java$lang$String?, _ a2: jint, _ a3: jint) throws -> jint
    func setAsciiStream(a0: jlong) throws -> java$io$OutputStream?
    func setCharacterStream(a0: jlong) throws -> java$io$Writer?
    func truncate(a0: jlong) throws -> Void
    func free() throws -> Void
    func getCharacterStream(a0: jlong, _ a1: jlong) throws -> java$io$Reader?
}

public class java$sql$Clob$ : java$lang$Object$, java$sql$Clob {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Clob_length__J = invoker("length", returns: jlong.jniType)
    private static let java$sql$Clob_getSubString_J_I__java$lang$String = invoker("getSubString", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType, jint.jniType))
    private static let java$sql$Clob_getCharacterStream__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"))
    private static let java$sql$Clob_getAsciiStream__java$io$InputStream = invoker("getAsciiStream", returns: JObjectType("java/io/InputStream"))
    private static let java$sql$Clob_position_java$lang$String_J__J = invoker("position", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    private static let java$sql$Clob_position_java$sql$Clob_J__J = invoker("position", returns: jlong.jniType, arguments: (JObjectType("java/sql/Clob"), jlong.jniType))
    private static let java$sql$Clob_setString_J_java$lang$String__I = invoker("setString", returns: jint.jniType, arguments: (jlong.jniType, JObjectType("java/lang/String")))
    private static let java$sql$Clob_setString_J_java$lang$String_I_I__I = invoker("setString", returns: jint.jniType, arguments: (jlong.jniType, JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$sql$Clob_setAsciiStream_J__java$io$OutputStream = invoker("setAsciiStream", returns: JObjectType("java/io/OutputStream"), arguments: (jlong.jniType))
    private static let java$sql$Clob_setCharacterStream_J__java$io$Writer = invoker("setCharacterStream", returns: JObjectType("java/io/Writer"), arguments: (jlong.jniType))
    private static let java$sql$Clob_truncate_J__V = invoker("truncate", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Clob_free__V = invoker("free", returns: JVoid.jniType)
    private static let java$sql$Clob_getCharacterStream_J_J__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (jlong.jniType, jlong.jniType))
}

public extension java$sql$Clob {
    func length() throws -> jlong {
        return try java$sql$Clob$.java$sql$Clob_length__J(jobj)()
    }

    func getSubString(a0: jlong, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Clob$.java$sql$Clob_getSubString_J_I__java$lang$String(jobj)(a0, a1))
    }

    func getCharacterStream() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$Clob$.java$sql$Clob_getCharacterStream__java$io$Reader(jobj)())
    }

    func getAsciiStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$Clob$.java$sql$Clob_getAsciiStream__java$io$InputStream(jobj)())
    }

    func position(a0: java$lang$String?, _ a1: jlong) throws -> jlong {
        return try java$sql$Clob$.java$sql$Clob_position_java$lang$String_J__J(jobj)(a0?.jobj ?? nil, a1)
    }

    func position(a0: java$sql$Clob?, _ a1: jlong) throws -> jlong {
        return try java$sql$Clob$.java$sql$Clob_position_java$sql$Clob_J__J(jobj)(a0?.jobj ?? nil, a1)
    }

    func setString(a0: jlong, _ a1: java$lang$String?) throws -> jint {
        return try java$sql$Clob$.java$sql$Clob_setString_J_java$lang$String__I(jobj)(a0, a1?.jobj ?? nil)
    }

    func setString(a0: jlong, _ a1: java$lang$String?, _ a2: jint, _ a3: jint) throws -> jint {
        return try java$sql$Clob$.java$sql$Clob_setString_J_java$lang$String_I_I__I(jobj)(a0, a1?.jobj ?? nil, a2, a3)
    }

    func setAsciiStream(a0: jlong) throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$sql$Clob$.java$sql$Clob_setAsciiStream_J__java$io$OutputStream(jobj)(a0))
    }

    func setCharacterStream(a0: jlong) throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: java$sql$Clob$.java$sql$Clob_setCharacterStream_J__java$io$Writer(jobj)(a0))
    }

    func truncate(a0: jlong) throws -> Void {
        return try java$sql$Clob$.java$sql$Clob_truncate_J__V(jobj)(a0)
    }

    func free() throws -> Void {
        return try java$sql$Clob$.java$sql$Clob_free__V(jobj)()
    }

    func getCharacterStream(a0: jlong, _ a1: jlong) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$Clob$.java$sql$Clob_getCharacterStream_J_J__java$io$Reader(jobj)(a0, a1))
    }

}

public protocol java$sql$Connection : java$sql$Wrapper, java$lang$AutoCloseable {
    func createStatement() throws -> java$sql$Statement?
    func prepareStatement(a0: java$lang$String?) throws -> java$sql$PreparedStatement?
    func prepareCall(a0: java$lang$String?) throws -> java$sql$CallableStatement?
    func nativeSQL(a0: java$lang$String?) throws -> java$lang$String?
    func setAutoCommit(a0: jboolean) throws -> Void
    func getAutoCommit() throws -> jboolean
    func commit() throws -> Void
    func rollback() throws -> Void
    func close() throws -> Void
    func isClosed() throws -> jboolean
    func getMetaData() throws -> java$sql$DatabaseMetaData?
    func setReadOnly(a0: jboolean) throws -> Void
    func isReadOnly() throws -> jboolean
    func setCatalog(a0: java$lang$String?) throws -> Void
    func getCatalog() throws -> java$lang$String?
    func setTransactionIsolation(a0: jint) throws -> Void
    func getTransactionIsolation() throws -> jint
    func getWarnings() throws -> java$sql$SQLWarning?
    func clearWarnings() throws -> Void
    func createStatement(a0: jint, _ a1: jint) throws -> java$sql$Statement?
    func prepareStatement(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> java$sql$PreparedStatement?
    func prepareCall(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> java$sql$CallableStatement?
    func getTypeMap() throws -> java$util$Map?
    func setTypeMap(a0: java$util$Map?) throws -> Void
    func setHoldability(a0: jint) throws -> Void
    func getHoldability() throws -> jint
    func setSavepoint() throws -> java$sql$Savepoint?
    func setSavepoint(a0: java$lang$String?) throws -> java$sql$Savepoint?
    func rollback(a0: java$sql$Savepoint?) throws -> Void
    func releaseSavepoint(a0: java$sql$Savepoint?) throws -> Void
    func createStatement(a0: jint, _ a1: jint, _ a2: jint) throws -> java$sql$Statement?
    func prepareStatement(a0: java$lang$String?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$sql$PreparedStatement?
    func prepareCall(a0: java$lang$String?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$sql$CallableStatement?
    func prepareStatement(a0: java$lang$String?, _ a1: jint) throws -> java$sql$PreparedStatement?
    func prepareStatement(a0: java$lang$String?, _ a1: [jint]?) throws -> java$sql$PreparedStatement?
    func prepareStatement(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> java$sql$PreparedStatement?
    func createClob() throws -> java$sql$Clob?
    func createBlob() throws -> java$sql$Blob?
    func createNClob() throws -> java$sql$NClob?
    func createSQLXML() throws -> java$sql$SQLXML?
    func isValid(a0: jint) throws -> jboolean
    func setClientInfo(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void
    func setClientInfo(a0: java$util$Properties?) throws -> Void
    func getClientInfo(a0: java$lang$String?) throws -> java$lang$String?
    func getClientInfo() throws -> java$util$Properties?
    func createArrayOf(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$sql$Array?
    func createStruct(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$sql$Struct?
    func setSchema(a0: java$lang$String?) throws -> Void
    func getSchema() throws -> java$lang$String?
    func abort(a0: java$util$concurrent$Executor?) throws -> Void
    func setNetworkTimeout(a0: java$util$concurrent$Executor?, _ a1: jint) throws -> Void
    func getNetworkTimeout() throws -> jint
}

public class java$sql$Connection$ : java$lang$Object$, java$sql$Connection, java$sql$Wrapper, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Connection_createStatement__java$sql$Statement = invoker("createStatement", returns: JObjectType("java/sql/Statement"))
    private static let java$sql$Connection_prepareStatement_java$lang$String__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_prepareCall_java$lang$String__java$sql$CallableStatement = invoker("prepareCall", returns: JObjectType("java/sql/CallableStatement"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_nativeSQL_java$lang$String__java$lang$String = invoker("nativeSQL", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_setAutoCommit_Z__V = invoker("setAutoCommit", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$sql$Connection_getAutoCommit__Z = invoker("getAutoCommit", returns: jboolean.jniType)
    private static let java$sql$Connection_commit__V = invoker("commit", returns: JVoid.jniType)
    private static let java$sql$Connection_rollback__V = invoker("rollback", returns: JVoid.jniType)
    private static let java$sql$Connection_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$sql$Connection_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    private static let java$sql$Connection_getMetaData__java$sql$DatabaseMetaData = invoker("getMetaData", returns: JObjectType("java/sql/DatabaseMetaData"))
    private static let java$sql$Connection_setReadOnly_Z__V = invoker("setReadOnly", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$sql$Connection_isReadOnly__Z = invoker("isReadOnly", returns: jboolean.jniType)
    private static let java$sql$Connection_setCatalog_java$lang$String__V = invoker("setCatalog", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_getCatalog__java$lang$String = invoker("getCatalog", returns: JObjectType("java/lang/String"))
    private static let java$sql$Connection_setTransactionIsolation_I__V = invoker("setTransactionIsolation", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Connection_getTransactionIsolation__I = invoker("getTransactionIsolation", returns: jint.jniType)
    private static let java$sql$Connection_getWarnings__java$sql$SQLWarning = invoker("getWarnings", returns: JObjectType("java/sql/SQLWarning"))
    private static let java$sql$Connection_clearWarnings__V = invoker("clearWarnings", returns: JVoid.jniType)
    private static let java$sql$Connection_createStatement_I_I__java$sql$Statement = invoker("createStatement", returns: JObjectType("java/sql/Statement"), arguments: (jint.jniType, jint.jniType))
    private static let java$sql$Connection_prepareStatement_java$lang$String_I_I__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$sql$Connection_prepareCall_java$lang$String_I_I__java$sql$CallableStatement = invoker("prepareCall", returns: JObjectType("java/sql/CallableStatement"), arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    private static let java$sql$Connection_getTypeMap__java$util$Map = invoker("getTypeMap", returns: JObjectType("java/util/Map"))
    private static let java$sql$Connection_setTypeMap_java$util$Map__V = invoker("setTypeMap", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$sql$Connection_setHoldability_I__V = invoker("setHoldability", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Connection_getHoldability__I = invoker("getHoldability", returns: jint.jniType)
    private static let java$sql$Connection_setSavepoint__java$sql$Savepoint = invoker("setSavepoint", returns: JObjectType("java/sql/Savepoint"))
    private static let java$sql$Connection_setSavepoint_java$lang$String__java$sql$Savepoint = invoker("setSavepoint", returns: JObjectType("java/sql/Savepoint"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_rollback_java$sql$Savepoint__V = invoker("rollback", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Savepoint")))
    private static let java$sql$Connection_releaseSavepoint_java$sql$Savepoint__V = invoker("releaseSavepoint", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Savepoint")))
    private static let java$sql$Connection_createStatement_I_I_I__java$sql$Statement = invoker("createStatement", returns: JObjectType("java/sql/Statement"), arguments: (jint.jniType, jint.jniType, jint.jniType))
    private static let java$sql$Connection_prepareStatement_java$lang$String_I_I_I__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType, jint.jniType))
    private static let java$sql$Connection_prepareCall_java$lang$String_I_I_I__java$sql$CallableStatement = invoker("prepareCall", returns: JObjectType("java/sql/CallableStatement"), arguments: (JObjectType("java/lang/String"), jint.jniType, jint.jniType, jint.jniType))
    private static let java$sql$Connection_prepareStatement_java$lang$String_I__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$Connection_prepareStatement_java$lang$String_AI__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String"), JArray(jint.jniType)))
    private static let java$sql$Connection_prepareStatement_java$lang$String_Ajava$lang$String__java$sql$PreparedStatement = invoker("prepareStatement", returns: JObjectType("java/sql/PreparedStatement"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    private static let java$sql$Connection_createClob__java$sql$Clob = invoker("createClob", returns: JObjectType("java/sql/Clob"))
    private static let java$sql$Connection_createBlob__java$sql$Blob = invoker("createBlob", returns: JObjectType("java/sql/Blob"))
    private static let java$sql$Connection_createNClob__java$sql$NClob = invoker("createNClob", returns: JObjectType("java/sql/NClob"))
    private static let java$sql$Connection_createSQLXML__java$sql$SQLXML = invoker("createSQLXML", returns: JObjectType("java/sql/SQLXML"))
    private static let java$sql$Connection_isValid_I__Z = invoker("isValid", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$Connection_setClientInfo_java$lang$String_java$lang$String__V = invoker("setClientInfo", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$Connection_setClientInfo_java$util$Properties__V = invoker("setClientInfo", returns: JVoid.jniType, arguments: (JObjectType("java/util/Properties")))
    private static let java$sql$Connection_getClientInfo_java$lang$String__java$lang$String = invoker("getClientInfo", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_getClientInfo__java$util$Properties = invoker("getClientInfo", returns: JObjectType("java/util/Properties"))
    private static let java$sql$Connection_createArrayOf_java$lang$String_Ajava$lang$Object__java$sql$Array = invoker("createArrayOf", returns: JObjectType("java/sql/Array"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    private static let java$sql$Connection_createStruct_java$lang$String_Ajava$lang$Object__java$sql$Struct = invoker("createStruct", returns: JObjectType("java/sql/Struct"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    private static let java$sql$Connection_setSchema_java$lang$String__V = invoker("setSchema", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Connection_getSchema__java$lang$String = invoker("getSchema", returns: JObjectType("java/lang/String"))
    private static let java$sql$Connection_abort_java$util$concurrent$Executor__V = invoker("abort", returns: JVoid.jniType, arguments: (JObjectType("java/util/concurrent/Executor")))
    private static let java$sql$Connection_setNetworkTimeout_java$util$concurrent$Executor_I__V = invoker("setNetworkTimeout", returns: JVoid.jniType, arguments: (JObjectType("java/util/concurrent/Executor"), jint.jniType))
    private static let java$sql$Connection_getNetworkTimeout__I = invoker("getNetworkTimeout", returns: jint.jniType)
}

public extension java$sql$Connection {
    func createStatement() throws -> java$sql$Statement? {
        return try java$sql$Statement$(jobj: java$sql$Connection$.java$sql$Connection_createStatement__java$sql$Statement(jobj)())
    }

    func prepareStatement(a0: java$lang$String?) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil))
    }

    func prepareCall(a0: java$lang$String?) throws -> java$sql$CallableStatement? {
        return try java$sql$CallableStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareCall_java$lang$String__java$sql$CallableStatement(jobj)(a0?.jobj ?? nil))
    }

    func nativeSQL(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Connection$.java$sql$Connection_nativeSQL_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func setAutoCommit(a0: jboolean) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setAutoCommit_Z__V(jobj)(a0)
    }

    func getAutoCommit() throws -> jboolean {
        return try java$sql$Connection$.java$sql$Connection_getAutoCommit__Z(jobj)()
    }

    func commit() throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_commit__V(jobj)()
    }

    func rollback() throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_rollback__V(jobj)()
    }

    func close() throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_close__V(jobj)()
    }

    func isClosed() throws -> jboolean {
        return try java$sql$Connection$.java$sql$Connection_isClosed__Z(jobj)()
    }

    func getMetaData() throws -> java$sql$DatabaseMetaData? {
        return try java$sql$DatabaseMetaData$(jobj: java$sql$Connection$.java$sql$Connection_getMetaData__java$sql$DatabaseMetaData(jobj)())
    }

    func setReadOnly(a0: jboolean) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setReadOnly_Z__V(jobj)(a0)
    }

    func isReadOnly() throws -> jboolean {
        return try java$sql$Connection$.java$sql$Connection_isReadOnly__Z(jobj)()
    }

    func setCatalog(a0: java$lang$String?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setCatalog_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func getCatalog() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Connection$.java$sql$Connection_getCatalog__java$lang$String(jobj)())
    }

    func setTransactionIsolation(a0: jint) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setTransactionIsolation_I__V(jobj)(a0)
    }

    func getTransactionIsolation() throws -> jint {
        return try java$sql$Connection$.java$sql$Connection_getTransactionIsolation__I(jobj)()
    }

    func getWarnings() throws -> java$sql$SQLWarning? {
        return try java$sql$SQLWarning$(jobj: java$sql$Connection$.java$sql$Connection_getWarnings__java$sql$SQLWarning(jobj)())
    }

    func clearWarnings() throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_clearWarnings__V(jobj)()
    }

    func createStatement(a0: jint, _ a1: jint) throws -> java$sql$Statement? {
        return try java$sql$Statement$(jobj: java$sql$Connection$.java$sql$Connection_createStatement_I_I__java$sql$Statement(jobj)(a0, a1))
    }

    func prepareStatement(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String_I_I__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    func prepareCall(a0: java$lang$String?, _ a1: jint, _ a2: jint) throws -> java$sql$CallableStatement? {
        return try java$sql$CallableStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareCall_java$lang$String_I_I__java$sql$CallableStatement(jobj)(a0?.jobj ?? nil, a1, a2))
    }

    func getTypeMap() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$sql$Connection$.java$sql$Connection_getTypeMap__java$util$Map(jobj)())
    }

    func setTypeMap(a0: java$util$Map?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setTypeMap_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    func setHoldability(a0: jint) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setHoldability_I__V(jobj)(a0)
    }

    func getHoldability() throws -> jint {
        return try java$sql$Connection$.java$sql$Connection_getHoldability__I(jobj)()
    }

    func setSavepoint() throws -> java$sql$Savepoint? {
        return try java$sql$Savepoint$(jobj: java$sql$Connection$.java$sql$Connection_setSavepoint__java$sql$Savepoint(jobj)())
    }

    func setSavepoint(a0: java$lang$String?) throws -> java$sql$Savepoint? {
        return try java$sql$Savepoint$(jobj: java$sql$Connection$.java$sql$Connection_setSavepoint_java$lang$String__java$sql$Savepoint(jobj)(a0?.jobj ?? nil))
    }

    func rollback(a0: java$sql$Savepoint?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_rollback_java$sql$Savepoint__V(jobj)(a0?.jobj ?? nil)
    }

    func releaseSavepoint(a0: java$sql$Savepoint?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_releaseSavepoint_java$sql$Savepoint__V(jobj)(a0?.jobj ?? nil)
    }

    func createStatement(a0: jint, _ a1: jint, _ a2: jint) throws -> java$sql$Statement? {
        return try java$sql$Statement$(jobj: java$sql$Connection$.java$sql$Connection_createStatement_I_I_I__java$sql$Statement(jobj)(a0, a1, a2))
    }

    func prepareStatement(a0: java$lang$String?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String_I_I_I__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil, a1, a2, a3))
    }

    func prepareCall(a0: java$lang$String?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$sql$CallableStatement? {
        return try java$sql$CallableStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareCall_java$lang$String_I_I_I__java$sql$CallableStatement(jobj)(a0?.jobj ?? nil, a1, a2, a3))
    }

    func prepareStatement(a0: java$lang$String?, _ a1: jint) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String_I__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil, a1))
    }

    func prepareStatement(a0: java$lang$String?, _ a1: [jint]?) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String_AI__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil))
    }

    func prepareStatement(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> java$sql$PreparedStatement? {
        return try java$sql$PreparedStatement$(jobj: java$sql$Connection$.java$sql$Connection_prepareStatement_java$lang$String_Ajava$lang$String__java$sql$PreparedStatement(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func createClob() throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$Connection$.java$sql$Connection_createClob__java$sql$Clob(jobj)())
    }

    func createBlob() throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$Connection$.java$sql$Connection_createBlob__java$sql$Blob(jobj)())
    }

    func createNClob() throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$Connection$.java$sql$Connection_createNClob__java$sql$NClob(jobj)())
    }

    func createSQLXML() throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$Connection$.java$sql$Connection_createSQLXML__java$sql$SQLXML(jobj)())
    }

    func isValid(a0: jint) throws -> jboolean {
        return try java$sql$Connection$.java$sql$Connection_isValid_I__Z(jobj)(a0)
    }

    func setClientInfo(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setClientInfo_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func setClientInfo(a0: java$util$Properties?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setClientInfo_java$util$Properties__V(jobj)(a0?.jobj ?? nil)
    }

    func getClientInfo(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Connection$.java$sql$Connection_getClientInfo_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getClientInfo() throws -> java$util$Properties? {
        return try java$util$Properties$(jobj: java$sql$Connection$.java$sql$Connection_getClientInfo__java$util$Properties(jobj)())
    }

    func createArrayOf(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$Connection$.java$sql$Connection_createArrayOf_java$lang$String_Ajava$lang$Object__java$sql$Array(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func createStruct(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$sql$Struct? {
        return try java$sql$Struct$(jobj: java$sql$Connection$.java$sql$Connection_createStruct_java$lang$String_Ajava$lang$Object__java$sql$Struct(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func setSchema(a0: java$lang$String?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setSchema_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func getSchema() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Connection$.java$sql$Connection_getSchema__java$lang$String(jobj)())
    }

    func abort(a0: java$util$concurrent$Executor?) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_abort_java$util$concurrent$Executor__V(jobj)(a0?.jobj ?? nil)
    }

    func setNetworkTimeout(a0: java$util$concurrent$Executor?, _ a1: jint) throws -> Void {
        return try java$sql$Connection$.java$sql$Connection_setNetworkTimeout_java$util$concurrent$Executor_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func getNetworkTimeout() throws -> jint {
        return try java$sql$Connection$.java$sql$Connection_getNetworkTimeout__I(jobj)()
    }

}

public class java$sql$DataTruncation : java$sql$SQLWarning$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$DataTruncation_init_I_Z_Z_I_I__V = constructor((jint.jniType, jboolean.jniType, jboolean.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jboolean, _ a2: jboolean, _ a3: jint, _ a4: jint) throws {
        let jobj = try java$sql$DataTruncation$.java$sql$DataTruncation_init_I_Z_Z_I_I__V(a0, a1, a2, a3, a4)
        self.init(jobj: jobj)
    }

    private static let java$sql$DataTruncation_init_I_Z_Z_I_I_java$lang$Throwable__V = constructor((jint.jniType, jboolean.jniType, jboolean.jniType, jint.jniType, jint.jniType, JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: jint, _ a1: jboolean, _ a2: jboolean, _ a3: jint, _ a4: jint, _ a5: java$lang$Throwable?) throws {
        let jobj = try java$sql$DataTruncation$.java$sql$DataTruncation_init_I_Z_Z_I_I_java$lang$Throwable__V(a0, a1, a2, a3, a4, a5?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$DataTruncation_getIndex__I = invoker("getIndex", returns: jint.jniType)
    public func getIndex() throws -> jint {
        return try java$sql$DataTruncation$.java$sql$DataTruncation_getIndex__I(jobj)()
    }

    private static let java$sql$DataTruncation_getParameter__Z = invoker("getParameter", returns: jboolean.jniType)
    public func getParameter() throws -> jboolean {
        return try java$sql$DataTruncation$.java$sql$DataTruncation_getParameter__Z(jobj)()
    }

    private static let java$sql$DataTruncation_getRead__Z = invoker("getRead", returns: jboolean.jniType)
    public func getRead() throws -> jboolean {
        return try java$sql$DataTruncation$.java$sql$DataTruncation_getRead__Z(jobj)()
    }

    private static let java$sql$DataTruncation_getDataSize__I = invoker("getDataSize", returns: jint.jniType)
    public func getDataSize() throws -> jint {
        return try java$sql$DataTruncation$.java$sql$DataTruncation_getDataSize__I(jobj)()
    }

    private static let java$sql$DataTruncation_getTransferSize__I = invoker("getTransferSize", returns: jint.jniType)
    public func getTransferSize() throws -> jint {
        return try java$sql$DataTruncation$.java$sql$DataTruncation_getTransferSize__I(jobj)()
    }

}

public typealias java$sql$DataTruncation$ = java$sql$DataTruncation

public protocol java$sql$DatabaseMetaData : java$sql$Wrapper {
    func allProceduresAreCallable() throws -> jboolean
    func allTablesAreSelectable() throws -> jboolean
    func getURL() throws -> java$lang$String?
    func getUserName() throws -> java$lang$String?
    func isReadOnly() throws -> jboolean
    func nullsAreSortedHigh() throws -> jboolean
    func nullsAreSortedLow() throws -> jboolean
    func nullsAreSortedAtStart() throws -> jboolean
    func nullsAreSortedAtEnd() throws -> jboolean
    func getDatabaseProductName() throws -> java$lang$String?
    func getDatabaseProductVersion() throws -> java$lang$String?
    func getDriverName() throws -> java$lang$String?
    func getDriverVersion() throws -> java$lang$String?
    func getDriverMajorVersion() throws -> jint
    func getDriverMinorVersion() throws -> jint
    func usesLocalFiles() throws -> jboolean
    func usesLocalFilePerTable() throws -> jboolean
    func supportsMixedCaseIdentifiers() throws -> jboolean
    func storesUpperCaseIdentifiers() throws -> jboolean
    func storesLowerCaseIdentifiers() throws -> jboolean
    func storesMixedCaseIdentifiers() throws -> jboolean
    func supportsMixedCaseQuotedIdentifiers() throws -> jboolean
    func storesUpperCaseQuotedIdentifiers() throws -> jboolean
    func storesLowerCaseQuotedIdentifiers() throws -> jboolean
    func storesMixedCaseQuotedIdentifiers() throws -> jboolean
    func getIdentifierQuoteString() throws -> java$lang$String?
    func getSQLKeywords() throws -> java$lang$String?
    func getNumericFunctions() throws -> java$lang$String?
    func getStringFunctions() throws -> java$lang$String?
    func getSystemFunctions() throws -> java$lang$String?
    func getTimeDateFunctions() throws -> java$lang$String?
    func getSearchStringEscape() throws -> java$lang$String?
    func getExtraNameCharacters() throws -> java$lang$String?
    func supportsAlterTableWithAddColumn() throws -> jboolean
    func supportsAlterTableWithDropColumn() throws -> jboolean
    func supportsColumnAliasing() throws -> jboolean
    func nullPlusNonNullIsNull() throws -> jboolean
    func supportsConvert() throws -> jboolean
    func supportsConvert(a0: jint, _ a1: jint) throws -> jboolean
    func supportsTableCorrelationNames() throws -> jboolean
    func supportsDifferentTableCorrelationNames() throws -> jboolean
    func supportsExpressionsInOrderBy() throws -> jboolean
    func supportsOrderByUnrelated() throws -> jboolean
    func supportsGroupBy() throws -> jboolean
    func supportsGroupByUnrelated() throws -> jboolean
    func supportsGroupByBeyondSelect() throws -> jboolean
    func supportsLikeEscapeClause() throws -> jboolean
    func supportsMultipleResultSets() throws -> jboolean
    func supportsMultipleTransactions() throws -> jboolean
    func supportsNonNullableColumns() throws -> jboolean
    func supportsMinimumSQLGrammar() throws -> jboolean
    func supportsCoreSQLGrammar() throws -> jboolean
    func supportsExtendedSQLGrammar() throws -> jboolean
    func supportsANSI92EntryLevelSQL() throws -> jboolean
    func supportsANSI92IntermediateSQL() throws -> jboolean
    func supportsANSI92FullSQL() throws -> jboolean
    func supportsIntegrityEnhancementFacility() throws -> jboolean
    func supportsOuterJoins() throws -> jboolean
    func supportsFullOuterJoins() throws -> jboolean
    func supportsLimitedOuterJoins() throws -> jboolean
    func getSchemaTerm() throws -> java$lang$String?
    func getProcedureTerm() throws -> java$lang$String?
    func getCatalogTerm() throws -> java$lang$String?
    func isCatalogAtStart() throws -> jboolean
    func getCatalogSeparator() throws -> java$lang$String?
    func supportsSchemasInDataManipulation() throws -> jboolean
    func supportsSchemasInProcedureCalls() throws -> jboolean
    func supportsSchemasInTableDefinitions() throws -> jboolean
    func supportsSchemasInIndexDefinitions() throws -> jboolean
    func supportsSchemasInPrivilegeDefinitions() throws -> jboolean
    func supportsCatalogsInDataManipulation() throws -> jboolean
    func supportsCatalogsInProcedureCalls() throws -> jboolean
    func supportsCatalogsInTableDefinitions() throws -> jboolean
    func supportsCatalogsInIndexDefinitions() throws -> jboolean
    func supportsCatalogsInPrivilegeDefinitions() throws -> jboolean
    func supportsPositionedDelete() throws -> jboolean
    func supportsPositionedUpdate() throws -> jboolean
    func supportsSelectForUpdate() throws -> jboolean
    func supportsStoredProcedures() throws -> jboolean
    func supportsSubqueriesInComparisons() throws -> jboolean
    func supportsSubqueriesInExists() throws -> jboolean
    func supportsSubqueriesInIns() throws -> jboolean
    func supportsSubqueriesInQuantifieds() throws -> jboolean
    func supportsCorrelatedSubqueries() throws -> jboolean
    func supportsUnion() throws -> jboolean
    func supportsUnionAll() throws -> jboolean
    func supportsOpenCursorsAcrossCommit() throws -> jboolean
    func supportsOpenCursorsAcrossRollback() throws -> jboolean
    func supportsOpenStatementsAcrossCommit() throws -> jboolean
    func supportsOpenStatementsAcrossRollback() throws -> jboolean
    func getMaxBinaryLiteralLength() throws -> jint
    func getMaxCharLiteralLength() throws -> jint
    func getMaxColumnNameLength() throws -> jint
    func getMaxColumnsInGroupBy() throws -> jint
    func getMaxColumnsInIndex() throws -> jint
    func getMaxColumnsInOrderBy() throws -> jint
    func getMaxColumnsInSelect() throws -> jint
    func getMaxColumnsInTable() throws -> jint
    func getMaxConnections() throws -> jint
    func getMaxCursorNameLength() throws -> jint
    func getMaxIndexLength() throws -> jint
    func getMaxSchemaNameLength() throws -> jint
    func getMaxProcedureNameLength() throws -> jint
    func getMaxCatalogNameLength() throws -> jint
    func getMaxRowSize() throws -> jint
    func doesMaxRowSizeIncludeBlobs() throws -> jboolean
    func getMaxStatementLength() throws -> jint
    func getMaxStatements() throws -> jint
    func getMaxTableNameLength() throws -> jint
    func getMaxTablesInSelect() throws -> jint
    func getMaxUserNameLength() throws -> jint
    func getDefaultTransactionIsolation() throws -> jint
    func supportsTransactions() throws -> jboolean
    func supportsTransactionIsolationLevel(a0: jint) throws -> jboolean
    func supportsDataDefinitionAndDataManipulationTransactions() throws -> jboolean
    func supportsDataManipulationTransactionsOnly() throws -> jboolean
    func dataDefinitionCausesTransactionCommit() throws -> jboolean
    func dataDefinitionIgnoredInTransactions() throws -> jboolean
    func getProcedures(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getProcedureColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func getTables(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: [java$lang$String?]?) throws -> java$sql$ResultSet?
    func getSchemas() throws -> java$sql$ResultSet?
    func getCatalogs() throws -> java$sql$ResultSet?
    func getTableTypes() throws -> java$sql$ResultSet?
    func getColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func getColumnPrivileges(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func getTablePrivileges(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getBestRowIdentifier(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jint, _ a4: jboolean) throws -> java$sql$ResultSet?
    func getVersionColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getPrimaryKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getImportedKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getExportedKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getCrossReference(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?, _ a4: java$lang$String?, _ a5: java$lang$String?) throws -> java$sql$ResultSet?
    func getTypeInfo() throws -> java$sql$ResultSet?
    func getIndexInfo(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jboolean, _ a4: jboolean) throws -> java$sql$ResultSet?
    func supportsResultSetType(a0: jint) throws -> jboolean
    func supportsResultSetConcurrency(a0: jint, _ a1: jint) throws -> jboolean
    func ownUpdatesAreVisible(a0: jint) throws -> jboolean
    func ownDeletesAreVisible(a0: jint) throws -> jboolean
    func ownInsertsAreVisible(a0: jint) throws -> jboolean
    func othersUpdatesAreVisible(a0: jint) throws -> jboolean
    func othersDeletesAreVisible(a0: jint) throws -> jboolean
    func othersInsertsAreVisible(a0: jint) throws -> jboolean
    func updatesAreDetected(a0: jint) throws -> jboolean
    func deletesAreDetected(a0: jint) throws -> jboolean
    func insertsAreDetected(a0: jint) throws -> jboolean
    func supportsBatchUpdates() throws -> jboolean
    func getUDTs(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: [jint]?) throws -> java$sql$ResultSet?
    func getConnection() throws -> java$sql$Connection?
    func supportsSavepoints() throws -> jboolean
    func supportsNamedParameters() throws -> jboolean
    func supportsMultipleOpenResults() throws -> jboolean
    func supportsGetGeneratedKeys() throws -> jboolean
    func getSuperTypes(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getSuperTables(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getAttributes(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func supportsResultSetHoldability(a0: jint) throws -> jboolean
    func getResultSetHoldability() throws -> jint
    func getDatabaseMajorVersion() throws -> jint
    func getDatabaseMinorVersion() throws -> jint
    func getJDBCMajorVersion() throws -> jint
    func getJDBCMinorVersion() throws -> jint
    func getSQLStateType() throws -> jint
    func locatorsUpdateCopy() throws -> jboolean
    func supportsStatementPooling() throws -> jboolean
    func getRowIdLifetime() throws -> java$sql$RowIdLifetime?
    func getSchemas(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$sql$ResultSet?
    func supportsStoredFunctionsUsingCallSyntax() throws -> jboolean
    func autoCommitFailureClosesAllResultSets() throws -> jboolean
    func getClientInfoProperties() throws -> java$sql$ResultSet?
    func getFunctions(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet?
    func getFunctionColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func getPseudoColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet?
    func generatedKeyAlwaysReturned() throws -> jboolean
    func getMaxLogicalLobSize() throws -> jlong
    func supportsRefCursors() throws -> jboolean
}

public class java$sql$DatabaseMetaData$ : java$lang$Object$, java$sql$DatabaseMetaData, java$sql$Wrapper {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$DatabaseMetaData_allProceduresAreCallable__Z = invoker("allProceduresAreCallable", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_allTablesAreSelectable__Z = invoker("allTablesAreSelectable", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getURL__java$lang$String = invoker("getURL", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getUserName__java$lang$String = invoker("getUserName", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_isReadOnly__Z = invoker("isReadOnly", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_nullsAreSortedHigh__Z = invoker("nullsAreSortedHigh", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_nullsAreSortedLow__Z = invoker("nullsAreSortedLow", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_nullsAreSortedAtStart__Z = invoker("nullsAreSortedAtStart", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_nullsAreSortedAtEnd__Z = invoker("nullsAreSortedAtEnd", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getDatabaseProductName__java$lang$String = invoker("getDatabaseProductName", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getDatabaseProductVersion__java$lang$String = invoker("getDatabaseProductVersion", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getDriverName__java$lang$String = invoker("getDriverName", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getDriverVersion__java$lang$String = invoker("getDriverVersion", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getDriverMajorVersion__I = invoker("getDriverMajorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getDriverMinorVersion__I = invoker("getDriverMinorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_usesLocalFiles__Z = invoker("usesLocalFiles", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_usesLocalFilePerTable__Z = invoker("usesLocalFilePerTable", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMixedCaseIdentifiers__Z = invoker("supportsMixedCaseIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesUpperCaseIdentifiers__Z = invoker("storesUpperCaseIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesLowerCaseIdentifiers__Z = invoker("storesLowerCaseIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesMixedCaseIdentifiers__Z = invoker("storesMixedCaseIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMixedCaseQuotedIdentifiers__Z = invoker("supportsMixedCaseQuotedIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesUpperCaseQuotedIdentifiers__Z = invoker("storesUpperCaseQuotedIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesLowerCaseQuotedIdentifiers__Z = invoker("storesLowerCaseQuotedIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_storesMixedCaseQuotedIdentifiers__Z = invoker("storesMixedCaseQuotedIdentifiers", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getIdentifierQuoteString__java$lang$String = invoker("getIdentifierQuoteString", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getSQLKeywords__java$lang$String = invoker("getSQLKeywords", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getNumericFunctions__java$lang$String = invoker("getNumericFunctions", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getStringFunctions__java$lang$String = invoker("getStringFunctions", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getSystemFunctions__java$lang$String = invoker("getSystemFunctions", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getTimeDateFunctions__java$lang$String = invoker("getTimeDateFunctions", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getSearchStringEscape__java$lang$String = invoker("getSearchStringEscape", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getExtraNameCharacters__java$lang$String = invoker("getExtraNameCharacters", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_supportsAlterTableWithAddColumn__Z = invoker("supportsAlterTableWithAddColumn", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsAlterTableWithDropColumn__Z = invoker("supportsAlterTableWithDropColumn", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsColumnAliasing__Z = invoker("supportsColumnAliasing", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_nullPlusNonNullIsNull__Z = invoker("nullPlusNonNullIsNull", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsConvert__Z = invoker("supportsConvert", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsConvert_I_I__Z = invoker("supportsConvert", returns: jboolean.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$DatabaseMetaData_supportsTableCorrelationNames__Z = invoker("supportsTableCorrelationNames", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsDifferentTableCorrelationNames__Z = invoker("supportsDifferentTableCorrelationNames", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsExpressionsInOrderBy__Z = invoker("supportsExpressionsInOrderBy", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOrderByUnrelated__Z = invoker("supportsOrderByUnrelated", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsGroupBy__Z = invoker("supportsGroupBy", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsGroupByUnrelated__Z = invoker("supportsGroupByUnrelated", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsGroupByBeyondSelect__Z = invoker("supportsGroupByBeyondSelect", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsLikeEscapeClause__Z = invoker("supportsLikeEscapeClause", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMultipleResultSets__Z = invoker("supportsMultipleResultSets", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMultipleTransactions__Z = invoker("supportsMultipleTransactions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsNonNullableColumns__Z = invoker("supportsNonNullableColumns", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMinimumSQLGrammar__Z = invoker("supportsMinimumSQLGrammar", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCoreSQLGrammar__Z = invoker("supportsCoreSQLGrammar", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsExtendedSQLGrammar__Z = invoker("supportsExtendedSQLGrammar", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsANSI92EntryLevelSQL__Z = invoker("supportsANSI92EntryLevelSQL", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsANSI92IntermediateSQL__Z = invoker("supportsANSI92IntermediateSQL", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsANSI92FullSQL__Z = invoker("supportsANSI92FullSQL", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsIntegrityEnhancementFacility__Z = invoker("supportsIntegrityEnhancementFacility", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOuterJoins__Z = invoker("supportsOuterJoins", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsFullOuterJoins__Z = invoker("supportsFullOuterJoins", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsLimitedOuterJoins__Z = invoker("supportsLimitedOuterJoins", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getSchemaTerm__java$lang$String = invoker("getSchemaTerm", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getProcedureTerm__java$lang$String = invoker("getProcedureTerm", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_getCatalogTerm__java$lang$String = invoker("getCatalogTerm", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_isCatalogAtStart__Z = invoker("isCatalogAtStart", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getCatalogSeparator__java$lang$String = invoker("getCatalogSeparator", returns: JObjectType("java/lang/String"))
    private static let java$sql$DatabaseMetaData_supportsSchemasInDataManipulation__Z = invoker("supportsSchemasInDataManipulation", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSchemasInProcedureCalls__Z = invoker("supportsSchemasInProcedureCalls", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSchemasInTableDefinitions__Z = invoker("supportsSchemasInTableDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSchemasInIndexDefinitions__Z = invoker("supportsSchemasInIndexDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSchemasInPrivilegeDefinitions__Z = invoker("supportsSchemasInPrivilegeDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCatalogsInDataManipulation__Z = invoker("supportsCatalogsInDataManipulation", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCatalogsInProcedureCalls__Z = invoker("supportsCatalogsInProcedureCalls", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCatalogsInTableDefinitions__Z = invoker("supportsCatalogsInTableDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCatalogsInIndexDefinitions__Z = invoker("supportsCatalogsInIndexDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCatalogsInPrivilegeDefinitions__Z = invoker("supportsCatalogsInPrivilegeDefinitions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsPositionedDelete__Z = invoker("supportsPositionedDelete", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsPositionedUpdate__Z = invoker("supportsPositionedUpdate", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSelectForUpdate__Z = invoker("supportsSelectForUpdate", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsStoredProcedures__Z = invoker("supportsStoredProcedures", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSubqueriesInComparisons__Z = invoker("supportsSubqueriesInComparisons", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSubqueriesInExists__Z = invoker("supportsSubqueriesInExists", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSubqueriesInIns__Z = invoker("supportsSubqueriesInIns", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsSubqueriesInQuantifieds__Z = invoker("supportsSubqueriesInQuantifieds", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsCorrelatedSubqueries__Z = invoker("supportsCorrelatedSubqueries", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsUnion__Z = invoker("supportsUnion", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsUnionAll__Z = invoker("supportsUnionAll", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOpenCursorsAcrossCommit__Z = invoker("supportsOpenCursorsAcrossCommit", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOpenCursorsAcrossRollback__Z = invoker("supportsOpenCursorsAcrossRollback", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOpenStatementsAcrossCommit__Z = invoker("supportsOpenStatementsAcrossCommit", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsOpenStatementsAcrossRollback__Z = invoker("supportsOpenStatementsAcrossRollback", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getMaxBinaryLiteralLength__I = invoker("getMaxBinaryLiteralLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxCharLiteralLength__I = invoker("getMaxCharLiteralLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnNameLength__I = invoker("getMaxColumnNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnsInGroupBy__I = invoker("getMaxColumnsInGroupBy", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnsInIndex__I = invoker("getMaxColumnsInIndex", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnsInOrderBy__I = invoker("getMaxColumnsInOrderBy", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnsInSelect__I = invoker("getMaxColumnsInSelect", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxColumnsInTable__I = invoker("getMaxColumnsInTable", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxConnections__I = invoker("getMaxConnections", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxCursorNameLength__I = invoker("getMaxCursorNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxIndexLength__I = invoker("getMaxIndexLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxSchemaNameLength__I = invoker("getMaxSchemaNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxProcedureNameLength__I = invoker("getMaxProcedureNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxCatalogNameLength__I = invoker("getMaxCatalogNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxRowSize__I = invoker("getMaxRowSize", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_doesMaxRowSizeIncludeBlobs__Z = invoker("doesMaxRowSizeIncludeBlobs", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getMaxStatementLength__I = invoker("getMaxStatementLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxStatements__I = invoker("getMaxStatements", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxTableNameLength__I = invoker("getMaxTableNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxTablesInSelect__I = invoker("getMaxTablesInSelect", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getMaxUserNameLength__I = invoker("getMaxUserNameLength", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getDefaultTransactionIsolation__I = invoker("getDefaultTransactionIsolation", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_supportsTransactions__Z = invoker("supportsTransactions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsTransactionIsolationLevel_I__Z = invoker("supportsTransactionIsolationLevel", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_supportsDataDefinitionAndDataManipulationTransactions__Z = invoker("supportsDataDefinitionAndDataManipulationTransactions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsDataManipulationTransactionsOnly__Z = invoker("supportsDataManipulationTransactionsOnly", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_dataDefinitionCausesTransactionCommit__Z = invoker("dataDefinitionCausesTransactionCommit", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_dataDefinitionIgnoredInTransactions__Z = invoker("dataDefinitionIgnoredInTransactions", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getProcedures_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getProcedures", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getProcedureColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getProcedureColumns", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getTables_java$lang$String_java$lang$String_java$lang$String_Ajava$lang$String__java$sql$ResultSet = invoker("getTables", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    private static let java$sql$DatabaseMetaData_getSchemas__java$sql$ResultSet = invoker("getSchemas", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$DatabaseMetaData_getCatalogs__java$sql$ResultSet = invoker("getCatalogs", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$DatabaseMetaData_getTableTypes__java$sql$ResultSet = invoker("getTableTypes", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$DatabaseMetaData_getColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getColumns", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getColumnPrivileges_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getColumnPrivileges", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getTablePrivileges_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getTablePrivileges", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getBestRowIdentifier_java$lang$String_java$lang$String_java$lang$String_I_Z__java$sql$ResultSet = invoker("getBestRowIdentifier", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, jboolean.jniType))
    private static let java$sql$DatabaseMetaData_getVersionColumns_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getVersionColumns", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getPrimaryKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getPrimaryKeys", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getImportedKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getImportedKeys", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getExportedKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getExportedKeys", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getCrossReference_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getCrossReference", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getTypeInfo__java$sql$ResultSet = invoker("getTypeInfo", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$DatabaseMetaData_getIndexInfo_java$lang$String_java$lang$String_java$lang$String_Z_Z__java$sql$ResultSet = invoker("getIndexInfo", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), jboolean.jniType, jboolean.jniType))
    private static let java$sql$DatabaseMetaData_supportsResultSetType_I__Z = invoker("supportsResultSetType", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_supportsResultSetConcurrency_I_I__Z = invoker("supportsResultSetConcurrency", returns: jboolean.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$DatabaseMetaData_ownUpdatesAreVisible_I__Z = invoker("ownUpdatesAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_ownDeletesAreVisible_I__Z = invoker("ownDeletesAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_ownInsertsAreVisible_I__Z = invoker("ownInsertsAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_othersUpdatesAreVisible_I__Z = invoker("othersUpdatesAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_othersDeletesAreVisible_I__Z = invoker("othersDeletesAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_othersInsertsAreVisible_I__Z = invoker("othersInsertsAreVisible", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_updatesAreDetected_I__Z = invoker("updatesAreDetected", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_deletesAreDetected_I__Z = invoker("deletesAreDetected", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_insertsAreDetected_I__Z = invoker("insertsAreDetected", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_supportsBatchUpdates__Z = invoker("supportsBatchUpdates", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getUDTs_java$lang$String_java$lang$String_java$lang$String_AI__java$sql$ResultSet = invoker("getUDTs", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JArray(jint.jniType)))
    private static let java$sql$DatabaseMetaData_getConnection__java$sql$Connection = invoker("getConnection", returns: JObjectType("java/sql/Connection"))
    private static let java$sql$DatabaseMetaData_supportsSavepoints__Z = invoker("supportsSavepoints", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsNamedParameters__Z = invoker("supportsNamedParameters", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsMultipleOpenResults__Z = invoker("supportsMultipleOpenResults", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsGetGeneratedKeys__Z = invoker("supportsGetGeneratedKeys", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getSuperTypes_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getSuperTypes", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getSuperTables_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getSuperTables", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getAttributes_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getAttributes", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_supportsResultSetHoldability_I__Z = invoker("supportsResultSetHoldability", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$DatabaseMetaData_getResultSetHoldability__I = invoker("getResultSetHoldability", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getDatabaseMajorVersion__I = invoker("getDatabaseMajorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getDatabaseMinorVersion__I = invoker("getDatabaseMinorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getJDBCMajorVersion__I = invoker("getJDBCMajorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getJDBCMinorVersion__I = invoker("getJDBCMinorVersion", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_getSQLStateType__I = invoker("getSQLStateType", returns: jint.jniType)
    private static let java$sql$DatabaseMetaData_locatorsUpdateCopy__Z = invoker("locatorsUpdateCopy", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_supportsStatementPooling__Z = invoker("supportsStatementPooling", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getRowIdLifetime__java$sql$RowIdLifetime = invoker("getRowIdLifetime", returns: JObjectType("java/sql/RowIdLifetime"))
    private static let java$sql$DatabaseMetaData_getSchemas_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getSchemas", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_supportsStoredFunctionsUsingCallSyntax__Z = invoker("supportsStoredFunctionsUsingCallSyntax", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_autoCommitFailureClosesAllResultSets__Z = invoker("autoCommitFailureClosesAllResultSets", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getClientInfoProperties__java$sql$ResultSet = invoker("getClientInfoProperties", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$DatabaseMetaData_getFunctions_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getFunctions", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getFunctionColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getFunctionColumns", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_getPseudoColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet = invoker("getPseudoColumns", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$DatabaseMetaData_generatedKeyAlwaysReturned__Z = invoker("generatedKeyAlwaysReturned", returns: jboolean.jniType)
    private static let java$sql$DatabaseMetaData_getMaxLogicalLobSize__J = invoker("getMaxLogicalLobSize", returns: jlong.jniType)
    private static let java$sql$DatabaseMetaData_supportsRefCursors__Z = invoker("supportsRefCursors", returns: jboolean.jniType)
}

public extension java$sql$DatabaseMetaData {
    func allProceduresAreCallable() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_allProceduresAreCallable__Z(jobj)()
    }

    func allTablesAreSelectable() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_allTablesAreSelectable__Z(jobj)()
    }

    func getURL() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getURL__java$lang$String(jobj)())
    }

    func getUserName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getUserName__java$lang$String(jobj)())
    }

    func isReadOnly() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_isReadOnly__Z(jobj)()
    }

    func nullsAreSortedHigh() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_nullsAreSortedHigh__Z(jobj)()
    }

    func nullsAreSortedLow() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_nullsAreSortedLow__Z(jobj)()
    }

    func nullsAreSortedAtStart() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_nullsAreSortedAtStart__Z(jobj)()
    }

    func nullsAreSortedAtEnd() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_nullsAreSortedAtEnd__Z(jobj)()
    }

    func getDatabaseProductName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDatabaseProductName__java$lang$String(jobj)())
    }

    func getDatabaseProductVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDatabaseProductVersion__java$lang$String(jobj)())
    }

    func getDriverName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDriverName__java$lang$String(jobj)())
    }

    func getDriverVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDriverVersion__java$lang$String(jobj)())
    }

    func getDriverMajorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDriverMajorVersion__I(jobj)()
    }

    func getDriverMinorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDriverMinorVersion__I(jobj)()
    }

    func usesLocalFiles() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_usesLocalFiles__Z(jobj)()
    }

    func usesLocalFilePerTable() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_usesLocalFilePerTable__Z(jobj)()
    }

    func supportsMixedCaseIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMixedCaseIdentifiers__Z(jobj)()
    }

    func storesUpperCaseIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesUpperCaseIdentifiers__Z(jobj)()
    }

    func storesLowerCaseIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesLowerCaseIdentifiers__Z(jobj)()
    }

    func storesMixedCaseIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesMixedCaseIdentifiers__Z(jobj)()
    }

    func supportsMixedCaseQuotedIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMixedCaseQuotedIdentifiers__Z(jobj)()
    }

    func storesUpperCaseQuotedIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesUpperCaseQuotedIdentifiers__Z(jobj)()
    }

    func storesLowerCaseQuotedIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesLowerCaseQuotedIdentifiers__Z(jobj)()
    }

    func storesMixedCaseQuotedIdentifiers() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_storesMixedCaseQuotedIdentifiers__Z(jobj)()
    }

    func getIdentifierQuoteString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getIdentifierQuoteString__java$lang$String(jobj)())
    }

    func getSQLKeywords() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSQLKeywords__java$lang$String(jobj)())
    }

    func getNumericFunctions() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getNumericFunctions__java$lang$String(jobj)())
    }

    func getStringFunctions() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getStringFunctions__java$lang$String(jobj)())
    }

    func getSystemFunctions() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSystemFunctions__java$lang$String(jobj)())
    }

    func getTimeDateFunctions() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getTimeDateFunctions__java$lang$String(jobj)())
    }

    func getSearchStringEscape() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSearchStringEscape__java$lang$String(jobj)())
    }

    func getExtraNameCharacters() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getExtraNameCharacters__java$lang$String(jobj)())
    }

    func supportsAlterTableWithAddColumn() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsAlterTableWithAddColumn__Z(jobj)()
    }

    func supportsAlterTableWithDropColumn() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsAlterTableWithDropColumn__Z(jobj)()
    }

    func supportsColumnAliasing() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsColumnAliasing__Z(jobj)()
    }

    func nullPlusNonNullIsNull() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_nullPlusNonNullIsNull__Z(jobj)()
    }

    func supportsConvert() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsConvert__Z(jobj)()
    }

    func supportsConvert(a0: jint, _ a1: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsConvert_I_I__Z(jobj)(a0, a1)
    }

    func supportsTableCorrelationNames() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsTableCorrelationNames__Z(jobj)()
    }

    func supportsDifferentTableCorrelationNames() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsDifferentTableCorrelationNames__Z(jobj)()
    }

    func supportsExpressionsInOrderBy() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsExpressionsInOrderBy__Z(jobj)()
    }

    func supportsOrderByUnrelated() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOrderByUnrelated__Z(jobj)()
    }

    func supportsGroupBy() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsGroupBy__Z(jobj)()
    }

    func supportsGroupByUnrelated() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsGroupByUnrelated__Z(jobj)()
    }

    func supportsGroupByBeyondSelect() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsGroupByBeyondSelect__Z(jobj)()
    }

    func supportsLikeEscapeClause() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsLikeEscapeClause__Z(jobj)()
    }

    func supportsMultipleResultSets() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMultipleResultSets__Z(jobj)()
    }

    func supportsMultipleTransactions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMultipleTransactions__Z(jobj)()
    }

    func supportsNonNullableColumns() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsNonNullableColumns__Z(jobj)()
    }

    func supportsMinimumSQLGrammar() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMinimumSQLGrammar__Z(jobj)()
    }

    func supportsCoreSQLGrammar() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCoreSQLGrammar__Z(jobj)()
    }

    func supportsExtendedSQLGrammar() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsExtendedSQLGrammar__Z(jobj)()
    }

    func supportsANSI92EntryLevelSQL() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsANSI92EntryLevelSQL__Z(jobj)()
    }

    func supportsANSI92IntermediateSQL() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsANSI92IntermediateSQL__Z(jobj)()
    }

    func supportsANSI92FullSQL() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsANSI92FullSQL__Z(jobj)()
    }

    func supportsIntegrityEnhancementFacility() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsIntegrityEnhancementFacility__Z(jobj)()
    }

    func supportsOuterJoins() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOuterJoins__Z(jobj)()
    }

    func supportsFullOuterJoins() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsFullOuterJoins__Z(jobj)()
    }

    func supportsLimitedOuterJoins() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsLimitedOuterJoins__Z(jobj)()
    }

    func getSchemaTerm() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSchemaTerm__java$lang$String(jobj)())
    }

    func getProcedureTerm() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getProcedureTerm__java$lang$String(jobj)())
    }

    func getCatalogTerm() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getCatalogTerm__java$lang$String(jobj)())
    }

    func isCatalogAtStart() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_isCatalogAtStart__Z(jobj)()
    }

    func getCatalogSeparator() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getCatalogSeparator__java$lang$String(jobj)())
    }

    func supportsSchemasInDataManipulation() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSchemasInDataManipulation__Z(jobj)()
    }

    func supportsSchemasInProcedureCalls() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSchemasInProcedureCalls__Z(jobj)()
    }

    func supportsSchemasInTableDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSchemasInTableDefinitions__Z(jobj)()
    }

    func supportsSchemasInIndexDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSchemasInIndexDefinitions__Z(jobj)()
    }

    func supportsSchemasInPrivilegeDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSchemasInPrivilegeDefinitions__Z(jobj)()
    }

    func supportsCatalogsInDataManipulation() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCatalogsInDataManipulation__Z(jobj)()
    }

    func supportsCatalogsInProcedureCalls() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCatalogsInProcedureCalls__Z(jobj)()
    }

    func supportsCatalogsInTableDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCatalogsInTableDefinitions__Z(jobj)()
    }

    func supportsCatalogsInIndexDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCatalogsInIndexDefinitions__Z(jobj)()
    }

    func supportsCatalogsInPrivilegeDefinitions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCatalogsInPrivilegeDefinitions__Z(jobj)()
    }

    func supportsPositionedDelete() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsPositionedDelete__Z(jobj)()
    }

    func supportsPositionedUpdate() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsPositionedUpdate__Z(jobj)()
    }

    func supportsSelectForUpdate() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSelectForUpdate__Z(jobj)()
    }

    func supportsStoredProcedures() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsStoredProcedures__Z(jobj)()
    }

    func supportsSubqueriesInComparisons() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSubqueriesInComparisons__Z(jobj)()
    }

    func supportsSubqueriesInExists() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSubqueriesInExists__Z(jobj)()
    }

    func supportsSubqueriesInIns() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSubqueriesInIns__Z(jobj)()
    }

    func supportsSubqueriesInQuantifieds() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSubqueriesInQuantifieds__Z(jobj)()
    }

    func supportsCorrelatedSubqueries() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsCorrelatedSubqueries__Z(jobj)()
    }

    func supportsUnion() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsUnion__Z(jobj)()
    }

    func supportsUnionAll() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsUnionAll__Z(jobj)()
    }

    func supportsOpenCursorsAcrossCommit() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOpenCursorsAcrossCommit__Z(jobj)()
    }

    func supportsOpenCursorsAcrossRollback() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOpenCursorsAcrossRollback__Z(jobj)()
    }

    func supportsOpenStatementsAcrossCommit() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOpenStatementsAcrossCommit__Z(jobj)()
    }

    func supportsOpenStatementsAcrossRollback() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsOpenStatementsAcrossRollback__Z(jobj)()
    }

    func getMaxBinaryLiteralLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxBinaryLiteralLength__I(jobj)()
    }

    func getMaxCharLiteralLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxCharLiteralLength__I(jobj)()
    }

    func getMaxColumnNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnNameLength__I(jobj)()
    }

    func getMaxColumnsInGroupBy() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnsInGroupBy__I(jobj)()
    }

    func getMaxColumnsInIndex() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnsInIndex__I(jobj)()
    }

    func getMaxColumnsInOrderBy() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnsInOrderBy__I(jobj)()
    }

    func getMaxColumnsInSelect() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnsInSelect__I(jobj)()
    }

    func getMaxColumnsInTable() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxColumnsInTable__I(jobj)()
    }

    func getMaxConnections() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxConnections__I(jobj)()
    }

    func getMaxCursorNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxCursorNameLength__I(jobj)()
    }

    func getMaxIndexLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxIndexLength__I(jobj)()
    }

    func getMaxSchemaNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxSchemaNameLength__I(jobj)()
    }

    func getMaxProcedureNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxProcedureNameLength__I(jobj)()
    }

    func getMaxCatalogNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxCatalogNameLength__I(jobj)()
    }

    func getMaxRowSize() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxRowSize__I(jobj)()
    }

    func doesMaxRowSizeIncludeBlobs() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_doesMaxRowSizeIncludeBlobs__Z(jobj)()
    }

    func getMaxStatementLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxStatementLength__I(jobj)()
    }

    func getMaxStatements() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxStatements__I(jobj)()
    }

    func getMaxTableNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxTableNameLength__I(jobj)()
    }

    func getMaxTablesInSelect() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxTablesInSelect__I(jobj)()
    }

    func getMaxUserNameLength() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxUserNameLength__I(jobj)()
    }

    func getDefaultTransactionIsolation() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDefaultTransactionIsolation__I(jobj)()
    }

    func supportsTransactions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsTransactions__Z(jobj)()
    }

    func supportsTransactionIsolationLevel(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsTransactionIsolationLevel_I__Z(jobj)(a0)
    }

    func supportsDataDefinitionAndDataManipulationTransactions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsDataDefinitionAndDataManipulationTransactions__Z(jobj)()
    }

    func supportsDataManipulationTransactionsOnly() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsDataManipulationTransactionsOnly__Z(jobj)()
    }

    func dataDefinitionCausesTransactionCommit() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_dataDefinitionCausesTransactionCommit__Z(jobj)()
    }

    func dataDefinitionIgnoredInTransactions() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_dataDefinitionIgnoredInTransactions__Z(jobj)()
    }

    func getProcedures(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getProcedures_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getProcedureColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getProcedureColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func getTables(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: [java$lang$String?]?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getTables_java$lang$String_java$lang$String_java$lang$String_Ajava$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func getSchemas() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSchemas__java$sql$ResultSet(jobj)())
    }

    func getCatalogs() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getCatalogs__java$sql$ResultSet(jobj)())
    }

    func getTableTypes() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getTableTypes__java$sql$ResultSet(jobj)())
    }

    func getColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func getColumnPrivileges(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getColumnPrivileges_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func getTablePrivileges(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getTablePrivileges_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getBestRowIdentifier(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jint, _ a4: jboolean) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getBestRowIdentifier_java$lang$String_java$lang$String_java$lang$String_I_Z__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3, a4))
    }

    func getVersionColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getVersionColumns_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getPrimaryKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getPrimaryKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getImportedKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getImportedKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getExportedKeys(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getExportedKeys_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getCrossReference(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?, _ a4: java$lang$String?, _ a5: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getCrossReference_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil, a4?.jobj ?? nil, a5?.jobj ?? nil))
    }

    func getTypeInfo() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getTypeInfo__java$sql$ResultSet(jobj)())
    }

    func getIndexInfo(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: jboolean, _ a4: jboolean) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getIndexInfo_java$lang$String_java$lang$String_java$lang$String_Z_Z__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3, a4))
    }

    func supportsResultSetType(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsResultSetType_I__Z(jobj)(a0)
    }

    func supportsResultSetConcurrency(a0: jint, _ a1: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsResultSetConcurrency_I_I__Z(jobj)(a0, a1)
    }

    func ownUpdatesAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_ownUpdatesAreVisible_I__Z(jobj)(a0)
    }

    func ownDeletesAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_ownDeletesAreVisible_I__Z(jobj)(a0)
    }

    func ownInsertsAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_ownInsertsAreVisible_I__Z(jobj)(a0)
    }

    func othersUpdatesAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_othersUpdatesAreVisible_I__Z(jobj)(a0)
    }

    func othersDeletesAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_othersDeletesAreVisible_I__Z(jobj)(a0)
    }

    func othersInsertsAreVisible(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_othersInsertsAreVisible_I__Z(jobj)(a0)
    }

    func updatesAreDetected(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_updatesAreDetected_I__Z(jobj)(a0)
    }

    func deletesAreDetected(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_deletesAreDetected_I__Z(jobj)(a0)
    }

    func insertsAreDetected(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_insertsAreDetected_I__Z(jobj)(a0)
    }

    func supportsBatchUpdates() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsBatchUpdates__Z(jobj)()
    }

    func getUDTs(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: [jint]?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getUDTs_java$lang$String_java$lang$String_java$lang$String_AI__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.arrayToJArray() ?? nil))
    }

    func getConnection() throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getConnection__java$sql$Connection(jobj)())
    }

    func supportsSavepoints() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsSavepoints__Z(jobj)()
    }

    func supportsNamedParameters() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsNamedParameters__Z(jobj)()
    }

    func supportsMultipleOpenResults() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsMultipleOpenResults__Z(jobj)()
    }

    func supportsGetGeneratedKeys() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsGetGeneratedKeys__Z(jobj)()
    }

    func getSuperTypes(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSuperTypes_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getSuperTables(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSuperTables_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getAttributes(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getAttributes_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func supportsResultSetHoldability(a0: jint) throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsResultSetHoldability_I__Z(jobj)(a0)
    }

    func getResultSetHoldability() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getResultSetHoldability__I(jobj)()
    }

    func getDatabaseMajorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDatabaseMajorVersion__I(jobj)()
    }

    func getDatabaseMinorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getDatabaseMinorVersion__I(jobj)()
    }

    func getJDBCMajorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getJDBCMajorVersion__I(jobj)()
    }

    func getJDBCMinorVersion() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getJDBCMinorVersion__I(jobj)()
    }

    func getSQLStateType() throws -> jint {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSQLStateType__I(jobj)()
    }

    func locatorsUpdateCopy() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_locatorsUpdateCopy__Z(jobj)()
    }

    func supportsStatementPooling() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsStatementPooling__Z(jobj)()
    }

    func getRowIdLifetime() throws -> java$sql$RowIdLifetime? {
        return try java$sql$RowIdLifetime$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getRowIdLifetime__java$sql$RowIdLifetime(jobj)())
    }

    func getSchemas(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getSchemas_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func supportsStoredFunctionsUsingCallSyntax() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsStoredFunctionsUsingCallSyntax__Z(jobj)()
    }

    func autoCommitFailureClosesAllResultSets() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_autoCommitFailureClosesAllResultSets__Z(jobj)()
    }

    func getClientInfoProperties() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getClientInfoProperties__java$sql$ResultSet(jobj)())
    }

    func getFunctions(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getFunctions_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    func getFunctionColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getFunctionColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func getPseudoColumns(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?, _ a3: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getPseudoColumns_java$lang$String_java$lang$String_java$lang$String_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    func generatedKeyAlwaysReturned() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_generatedKeyAlwaysReturned__Z(jobj)()
    }

    func getMaxLogicalLobSize() throws -> jlong {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_getMaxLogicalLobSize__J(jobj)()
    }

    func supportsRefCursors() throws -> jboolean {
        return try java$sql$DatabaseMetaData$.java$sql$DatabaseMetaData_supportsRefCursors__Z(jobj)()
    }

}

public class java$sql$Date : java$util$Date$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Date_init_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$sql$Date$.java$sql$Date_init_I_I_I__V(a0, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$sql$Date_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$sql$Date$.java$sql$Date_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$sql$Date_setTime_J__V = invoker("setTime", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Date_valueOf_java$lang$String__java$sql$Date = svoker("valueOf", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$Date$.java$sql$Date_valueOf_java$lang$String__java$sql$Date(a0?.jobj ?? nil))
    }

    private static let java$sql$Date_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$sql$Date_getHours__I = invoker("getHours", returns: jint.jniType)
    private static let java$sql$Date_getMinutes__I = invoker("getMinutes", returns: jint.jniType)
    private static let java$sql$Date_getSeconds__I = invoker("getSeconds", returns: jint.jniType)
    private static let java$sql$Date_setHours_I__V = invoker("setHours", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Date_setMinutes_I__V = invoker("setMinutes", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Date_setSeconds_I__V = invoker("setSeconds", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Date_valueOf_java$time$LocalDate__java$sql$Date = svoker("valueOf", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/time/LocalDate")))
    public static func valueOf(a0: java$time$LocalDate?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$Date$.java$sql$Date_valueOf_java$time$LocalDate__java$sql$Date(a0?.jobj ?? nil))
    }

    private static let java$sql$Date_toLocalDate__java$time$LocalDate = invoker("toLocalDate", returns: JObjectType("java/time/LocalDate"))
    public func toLocalDate() throws -> java$time$LocalDate? {
        return try java$time$LocalDate$(jobj: java$sql$Date$.java$sql$Date_toLocalDate__java$time$LocalDate(jobj)())
    }

    private static let java$sql$Date_toInstant__java$time$Instant = invoker("toInstant", returns: JObjectType("java/time/Instant"))
}

public typealias java$sql$Date$ = java$sql$Date

public protocol java$sql$Driver : JavaObject {
    func connect(a0: java$lang$String?, _ a1: java$util$Properties?) throws -> java$sql$Connection?
    func acceptsURL(a0: java$lang$String?) throws -> jboolean
    func getPropertyInfo(a0: java$lang$String?, _ a1: java$util$Properties?) throws -> [java$sql$DriverPropertyInfo?]?
    func getMajorVersion() throws -> jint
    func getMinorVersion() throws -> jint
    func jdbcCompliant() throws -> jboolean
    func getParentLogger() throws -> java$util$logging$Logger?
}

public class java$sql$Driver$ : java$lang$Object$, java$sql$Driver {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Driver_connect_java$lang$String_java$util$Properties__java$sql$Connection = invoker("connect", returns: JObjectType("java/sql/Connection"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Properties")))
    private static let java$sql$Driver_acceptsURL_java$lang$String__Z = invoker("acceptsURL", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Driver_getPropertyInfo_java$lang$String_java$util$Properties__Ajava$sql$DriverPropertyInfo = invoker("getPropertyInfo", returns: JArray(JObjectType("java/sql/DriverPropertyInfo")), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Properties")))
    private static let java$sql$Driver_getMajorVersion__I = invoker("getMajorVersion", returns: jint.jniType)
    private static let java$sql$Driver_getMinorVersion__I = invoker("getMinorVersion", returns: jint.jniType)
    private static let java$sql$Driver_jdbcCompliant__Z = invoker("jdbcCompliant", returns: jboolean.jniType)
    private static let java$sql$Driver_getParentLogger__java$util$logging$Logger = invoker("getParentLogger", returns: JObjectType("java/util/logging/Logger"))
}

public extension java$sql$Driver {
    func connect(a0: java$lang$String?, _ a1: java$util$Properties?) throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$Driver$.java$sql$Driver_connect_java$lang$String_java$util$Properties__java$sql$Connection(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func acceptsURL(a0: java$lang$String?) throws -> jboolean {
        return try java$sql$Driver$.java$sql$Driver_acceptsURL_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    func getPropertyInfo(a0: java$lang$String?, _ a1: java$util$Properties?) throws -> [java$sql$DriverPropertyInfo?]? {
        return try java$sql$Driver$.java$sql$Driver_getPropertyInfo_java$lang$String_java$util$Properties__Ajava$sql$DriverPropertyInfo(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil).jarrayToArray(java$sql$DriverPropertyInfo$.self)?.map({ $0 as java$sql$DriverPropertyInfo? })
    }

    func getMajorVersion() throws -> jint {
        return try java$sql$Driver$.java$sql$Driver_getMajorVersion__I(jobj)()
    }

    func getMinorVersion() throws -> jint {
        return try java$sql$Driver$.java$sql$Driver_getMinorVersion__I(jobj)()
    }

    func jdbcCompliant() throws -> jboolean {
        return try java$sql$Driver$.java$sql$Driver_jdbcCompliant__Z(jobj)()
    }

    func getParentLogger() throws -> java$util$logging$Logger? {
        return try java$util$logging$Logger$(jobj: java$sql$Driver$.java$sql$Driver_getParentLogger__java$util$logging$Logger(jobj)())
    }

}

public class java$sql$DriverManager : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$DriverManager_getLogWriter__java$io$PrintWriter = svoker("getLogWriter", returns: JObjectType("java/io/PrintWriter"))
    public static func getLogWriter() throws -> java$io$PrintWriter? {
        return try java$io$PrintWriter$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getLogWriter__java$io$PrintWriter())
    }

    private static let java$sql$DriverManager_setLogWriter_java$io$PrintWriter__V = svoker("setLogWriter", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintWriter")))
    public static func setLogWriter(a0: java$io$PrintWriter?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_setLogWriter_java$io$PrintWriter__V(a0?.jobj ?? nil)
    }

    private static let java$sql$DriverManager_getConnection_java$lang$String_java$util$Properties__java$sql$Connection = svoker("getConnection", returns: JObjectType("java/sql/Connection"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Properties")))
    public static func getConnection(a0: java$lang$String?, _ a1: java$util$Properties?) throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getConnection_java$lang$String_java$util$Properties__java$sql$Connection(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$sql$DriverManager_getConnection_java$lang$String_java$lang$String_java$lang$String__java$sql$Connection = svoker("getConnection", returns: JObjectType("java/sql/Connection"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public static func getConnection(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getConnection_java$lang$String_java$lang$String_java$lang$String__java$sql$Connection(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$sql$DriverManager_getConnection_java$lang$String__java$sql$Connection = svoker("getConnection", returns: JObjectType("java/sql/Connection"), arguments: (JObjectType("java/lang/String")))
    public static func getConnection(a0: java$lang$String?) throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getConnection_java$lang$String__java$sql$Connection(a0?.jobj ?? nil))
    }

    private static let java$sql$DriverManager_getDriver_java$lang$String__java$sql$Driver = svoker("getDriver", returns: JObjectType("java/sql/Driver"), arguments: (JObjectType("java/lang/String")))
    public static func getDriver(a0: java$lang$String?) throws -> java$sql$Driver? {
        return try java$sql$Driver$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getDriver_java$lang$String__java$sql$Driver(a0?.jobj ?? nil))
    }

    private static let java$sql$DriverManager_registerDriver_java$sql$Driver__V = svoker("registerDriver", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Driver")))
    public static func registerDriver(a0: java$sql$Driver?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_registerDriver_java$sql$Driver__V(a0?.jobj ?? nil)
    }

    private static let java$sql$DriverManager_registerDriver_java$sql$Driver_java$sql$DriverAction__V = svoker("registerDriver", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Driver"), JObjectType("java/sql/DriverAction")))
    public static func registerDriver(a0: java$sql$Driver?, _ a1: java$sql$DriverAction?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_registerDriver_java$sql$Driver_java$sql$DriverAction__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$sql$DriverManager_deregisterDriver_java$sql$Driver__V = svoker("deregisterDriver", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Driver")))
    public static func deregisterDriver(a0: java$sql$Driver?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_deregisterDriver_java$sql$Driver__V(a0?.jobj ?? nil)
    }

    private static let java$sql$DriverManager_getDrivers__java$util$Enumeration = svoker("getDrivers", returns: JObjectType("java/util/Enumeration"))
    public static func getDrivers() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getDrivers__java$util$Enumeration())
    }

    private static let java$sql$DriverManager_setLoginTimeout_I__V = svoker("setLoginTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    public static func setLoginTimeout(a0: jint) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_setLoginTimeout_I__V(a0)
    }

    private static let java$sql$DriverManager_getLoginTimeout__I = svoker("getLoginTimeout", returns: jint.jniType)
    public static func getLoginTimeout() throws -> jint {
        return try java$sql$DriverManager$.java$sql$DriverManager_getLoginTimeout__I()
    }

    private static let java$sql$DriverManager_setLogStream_java$io$PrintStream__V = svoker("setLogStream", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintStream")))
    public static func setLogStream(a0: java$io$PrintStream?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_setLogStream_java$io$PrintStream__V(a0?.jobj ?? nil)
    }

    private static let java$sql$DriverManager_getLogStream__java$io$PrintStream = svoker("getLogStream", returns: JObjectType("java/io/PrintStream"))
    public static func getLogStream() throws -> java$io$PrintStream? {
        return try java$io$PrintStream$(jobj: java$sql$DriverManager$.java$sql$DriverManager_getLogStream__java$io$PrintStream())
    }

    private static let java$sql$DriverManager_println_java$lang$String__V = svoker("println", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public static func println(a0: java$lang$String?) throws -> Void {
        return try java$sql$DriverManager$.java$sql$DriverManager_println_java$lang$String__V(a0?.jobj ?? nil)
    }

}

public typealias java$sql$DriverManager$ = java$sql$DriverManager

public class java$sql$DriverPropertyInfo : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$DriverPropertyInfo_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$sql$DriverPropertyInfo$.java$sql$DriverPropertyInfo_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$sql$DriverPropertyInfo$ = java$sql$DriverPropertyInfo

public protocol java$sql$NClob : java$sql$Clob {
}

public class java$sql$NClob$ : java$lang$Object$, java$sql$NClob, java$sql$Clob {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$sql$NClob {
}

public protocol java$sql$ParameterMetaData : java$sql$Wrapper {
    func getParameterCount() throws -> jint
    func isNullable(a0: jint) throws -> jint
    func isSigned(a0: jint) throws -> jboolean
    func getPrecision(a0: jint) throws -> jint
    func getScale(a0: jint) throws -> jint
    func getParameterType(a0: jint) throws -> jint
    func getParameterTypeName(a0: jint) throws -> java$lang$String?
    func getParameterClassName(a0: jint) throws -> java$lang$String?
    func getParameterMode(a0: jint) throws -> jint
}

public class java$sql$ParameterMetaData$ : java$lang$Object$, java$sql$ParameterMetaData, java$sql$Wrapper {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$ParameterMetaData_getParameterCount__I = invoker("getParameterCount", returns: jint.jniType)
    private static let java$sql$ParameterMetaData_isNullable_I__I = invoker("isNullable", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_isSigned_I__Z = invoker("isSigned", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getPrecision_I__I = invoker("getPrecision", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getScale_I__I = invoker("getScale", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getParameterType_I__I = invoker("getParameterType", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getParameterTypeName_I__java$lang$String = invoker("getParameterTypeName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getParameterClassName_I__java$lang$String = invoker("getParameterClassName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ParameterMetaData_getParameterMode_I__I = invoker("getParameterMode", returns: jint.jniType, arguments: (jint.jniType))
}

public extension java$sql$ParameterMetaData {
    func getParameterCount() throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getParameterCount__I(jobj)()
    }

    func isNullable(a0: jint) throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_isNullable_I__I(jobj)(a0)
    }

    func isSigned(a0: jint) throws -> jboolean {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_isSigned_I__Z(jobj)(a0)
    }

    func getPrecision(a0: jint) throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getPrecision_I__I(jobj)(a0)
    }

    func getScale(a0: jint) throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getScale_I__I(jobj)(a0)
    }

    func getParameterType(a0: jint) throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getParameterType_I__I(jobj)(a0)
    }

    func getParameterTypeName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getParameterTypeName_I__java$lang$String(jobj)(a0))
    }

    func getParameterClassName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getParameterClassName_I__java$lang$String(jobj)(a0))
    }

    func getParameterMode(a0: jint) throws -> jint {
        return try java$sql$ParameterMetaData$.java$sql$ParameterMetaData_getParameterMode_I__I(jobj)(a0)
    }

}

public protocol java$sql$PreparedStatement : java$sql$Statement {
    func executeQuery() throws -> java$sql$ResultSet?
    func executeUpdate() throws -> jint
    func setNull(a0: jint, _ a1: jint) throws -> Void
    func setBoolean(a0: jint, _ a1: jboolean) throws -> Void
    func setByte(a0: jint, _ a1: jbyte) throws -> Void
    func setShort(a0: jint, _ a1: jshort) throws -> Void
    func setInt(a0: jint, _ a1: jint) throws -> Void
    func setLong(a0: jint, _ a1: jlong) throws -> Void
    func setFloat(a0: jint, _ a1: jfloat) throws -> Void
    func setDouble(a0: jint, _ a1: jdouble) throws -> Void
    func setBigDecimal(a0: jint, _ a1: java$math$BigDecimal?) throws -> Void
    func setString(a0: jint, _ a1: java$lang$String?) throws -> Void
    func setBytes(a0: jint, _ a1: [jbyte]?) throws -> Void
    func setDate(a0: jint, _ a1: java$sql$Date?) throws -> Void
    func setTime(a0: jint, _ a1: java$sql$Time?) throws -> Void
    func setTimestamp(a0: jint, _ a1: java$sql$Timestamp?) throws -> Void
    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func setUnicodeStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func clearParameters() throws -> Void
    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint) throws -> Void
    func setObject(a0: jint, _ a1: java$lang$Object?) throws -> Void
    func execute() throws -> jboolean
    func addBatch() throws -> Void
    func setCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jint) throws -> Void
    func setRef(a0: jint, _ a1: java$sql$Ref?) throws -> Void
    func setBlob(a0: jint, _ a1: java$sql$Blob?) throws -> Void
    func setClob(a0: jint, _ a1: java$sql$Clob?) throws -> Void
    func setArray(a0: jint, _ a1: java$sql$Array?) throws -> Void
    func getMetaData() throws -> java$sql$ResultSetMetaData?
    func setDate(a0: jint, _ a1: java$sql$Date?, _ a2: java$util$Calendar?) throws -> Void
    func setTime(a0: jint, _ a1: java$sql$Time?, _ a2: java$util$Calendar?) throws -> Void
    func setTimestamp(a0: jint, _ a1: java$sql$Timestamp?, _ a2: java$util$Calendar?) throws -> Void
    func setNull(a0: jint, _ a1: jint, _ a2: java$lang$String?) throws -> Void
    func setURL(a0: jint, _ a1: java$net$URL?) throws -> Void
    func getParameterMetaData() throws -> java$sql$ParameterMetaData?
    func setRowId(a0: jint, _ a1: java$sql$RowId?) throws -> Void
    func setNString(a0: jint, _ a1: java$lang$String?) throws -> Void
    func setNCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setNClob(a0: jint, _ a1: java$sql$NClob?) throws -> Void
    func setClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setBlob(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setNClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setSQLXML(a0: jint, _ a1: java$sql$SQLXML?) throws -> Void
    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint) throws -> Void
    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func setCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func setCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func setNCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func setClob(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func setBlob(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func setNClob(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void
    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void
    func executeLargeUpdate() throws -> jlong
}

public class java$sql$PreparedStatement$ : java$lang$Object$, java$sql$PreparedStatement, java$sql$Statement {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$PreparedStatement_executeQuery__java$sql$ResultSet = invoker("executeQuery", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$PreparedStatement_executeUpdate__I = invoker("executeUpdate", returns: jint.jniType)
    private static let java$sql$PreparedStatement_setNull_I_I__V = invoker("setNull", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$PreparedStatement_setBoolean_I_Z__V = invoker("setBoolean", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    private static let java$sql$PreparedStatement_setByte_I_B__V = invoker("setByte", returns: JVoid.jniType, arguments: (jint.jniType, jbyte.jniType))
    private static let java$sql$PreparedStatement_setShort_I_S__V = invoker("setShort", returns: JVoid.jniType, arguments: (jint.jniType, jshort.jniType))
    private static let java$sql$PreparedStatement_setInt_I_I__V = invoker("setInt", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$PreparedStatement_setLong_I_J__V = invoker("setLong", returns: JVoid.jniType, arguments: (jint.jniType, jlong.jniType))
    private static let java$sql$PreparedStatement_setFloat_I_F__V = invoker("setFloat", returns: JVoid.jniType, arguments: (jint.jniType, jfloat.jniType))
    private static let java$sql$PreparedStatement_setDouble_I_D__V = invoker("setDouble", returns: JVoid.jniType, arguments: (jint.jniType, jdouble.jniType))
    private static let java$sql$PreparedStatement_setBigDecimal_I_java$math$BigDecimal__V = invoker("setBigDecimal", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/math/BigDecimal")))
    private static let java$sql$PreparedStatement_setString_I_java$lang$String__V = invoker("setString", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$PreparedStatement_setBytes_I_AB__V = invoker("setBytes", returns: JVoid.jniType, arguments: (jint.jniType, JArray(jbyte.jniType)))
    private static let java$sql$PreparedStatement_setDate_I_java$sql$Date__V = invoker("setDate", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Date")))
    private static let java$sql$PreparedStatement_setTime_I_java$sql$Time__V = invoker("setTime", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Time")))
    private static let java$sql$PreparedStatement_setTimestamp_I_java$sql$Timestamp__V = invoker("setTimestamp", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Timestamp")))
    private static let java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream_I__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$PreparedStatement_setUnicodeStream_I_java$io$InputStream_I__V = invoker("setUnicodeStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream_I__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$PreparedStatement_clearParameters__V = invoker("clearParameters", returns: JVoid.jniType)
    private static let java$sql$PreparedStatement_setObject_I_java$lang$Object_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), jint.jniType))
    private static let java$sql$PreparedStatement_setObject_I_java$lang$Object__V = invoker("setObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$sql$PreparedStatement_execute__Z = invoker("execute", returns: jboolean.jniType)
    private static let java$sql$PreparedStatement_addBatch__V = invoker("addBatch", returns: JVoid.jniType)
    private static let java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader_I__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jint.jniType))
    private static let java$sql$PreparedStatement_setRef_I_java$sql$Ref__V = invoker("setRef", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Ref")))
    private static let java$sql$PreparedStatement_setBlob_I_java$sql$Blob__V = invoker("setBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Blob")))
    private static let java$sql$PreparedStatement_setClob_I_java$sql$Clob__V = invoker("setClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Clob")))
    private static let java$sql$PreparedStatement_setArray_I_java$sql$Array__V = invoker("setArray", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Array")))
    private static let java$sql$PreparedStatement_getMetaData__java$sql$ResultSetMetaData = invoker("getMetaData", returns: JObjectType("java/sql/ResultSetMetaData"))
    private static let java$sql$PreparedStatement_setDate_I_java$sql$Date_java$util$Calendar__V = invoker("setDate", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Date"), JObjectType("java/util/Calendar")))
    private static let java$sql$PreparedStatement_setTime_I_java$sql$Time_java$util$Calendar__V = invoker("setTime", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Time"), JObjectType("java/util/Calendar")))
    private static let java$sql$PreparedStatement_setTimestamp_I_java$sql$Timestamp_java$util$Calendar__V = invoker("setTimestamp", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Timestamp"), JObjectType("java/util/Calendar")))
    private static let java$sql$PreparedStatement_setNull_I_I_java$lang$String__V = invoker("setNull", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$PreparedStatement_setURL_I_java$net$URL__V = invoker("setURL", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/net/URL")))
    private static let java$sql$PreparedStatement_getParameterMetaData__java$sql$ParameterMetaData = invoker("getParameterMetaData", returns: JObjectType("java/sql/ParameterMetaData"))
    private static let java$sql$PreparedStatement_setRowId_I_java$sql$RowId__V = invoker("setRowId", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/RowId")))
    private static let java$sql$PreparedStatement_setNString_I_java$lang$String__V = invoker("setNString", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$PreparedStatement_setNCharacterStream_I_java$io$Reader_J__V = invoker("setNCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$PreparedStatement_setNClob_I_java$sql$NClob__V = invoker("setNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/NClob")))
    private static let java$sql$PreparedStatement_setClob_I_java$io$Reader_J__V = invoker("setClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$PreparedStatement_setBlob_I_java$io$InputStream_J__V = invoker("setBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$PreparedStatement_setNClob_I_java$io$Reader_J__V = invoker("setNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$PreparedStatement_setSQLXML_I_java$sql$SQLXML__V = invoker("setSQLXML", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/SQLXML")))
    private static let java$sql$PreparedStatement_setObject_I_java$lang$Object_I_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), jint.jniType, jint.jniType))
    private static let java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream_J__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream_J__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader_J__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream__V = invoker("setAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream__V = invoker("setBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader__V = invoker("setCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$PreparedStatement_setNCharacterStream_I_java$io$Reader__V = invoker("setNCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$PreparedStatement_setClob_I_java$io$Reader__V = invoker("setClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$PreparedStatement_setBlob_I_java$io$InputStream__V = invoker("setBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$PreparedStatement_setNClob_I_java$io$Reader__V = invoker("setNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$PreparedStatement_setObject_I_java$lang$Object_java$sql$SQLType_I__V = invoker("setObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$PreparedStatement_setObject_I_java$lang$Object_java$sql$SQLType__V = invoker("setObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType")))
    private static let java$sql$PreparedStatement_executeLargeUpdate__J = invoker("executeLargeUpdate", returns: jlong.jniType)
}

public extension java$sql$PreparedStatement {
    func executeQuery() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$PreparedStatement$.java$sql$PreparedStatement_executeQuery__java$sql$ResultSet(jobj)())
    }

    func executeUpdate() throws -> jint {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_executeUpdate__I(jobj)()
    }

    func setNull(a0: jint, _ a1: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNull_I_I__V(jobj)(a0, a1)
    }

    func setBoolean(a0: jint, _ a1: jboolean) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBoolean_I_Z__V(jobj)(a0, a1)
    }

    func setByte(a0: jint, _ a1: jbyte) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setByte_I_B__V(jobj)(a0, a1)
    }

    func setShort(a0: jint, _ a1: jshort) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setShort_I_S__V(jobj)(a0, a1)
    }

    func setInt(a0: jint, _ a1: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setInt_I_I__V(jobj)(a0, a1)
    }

    func setLong(a0: jint, _ a1: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setLong_I_J__V(jobj)(a0, a1)
    }

    func setFloat(a0: jint, _ a1: jfloat) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setFloat_I_F__V(jobj)(a0, a1)
    }

    func setDouble(a0: jint, _ a1: jdouble) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setDouble_I_D__V(jobj)(a0, a1)
    }

    func setBigDecimal(a0: jint, _ a1: java$math$BigDecimal?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBigDecimal_I_java$math$BigDecimal__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setString(a0: jint, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setString_I_java$lang$String__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setBytes(a0: jint, _ a1: [jbyte]?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBytes_I_AB__V(jobj)(a0, a1?.arrayToJArray() ?? nil)
    }

    func setDate(a0: jint, _ a1: java$sql$Date?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setDate_I_java$sql$Date__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setTime(a0: jint, _ a1: java$sql$Time?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setTime_I_java$sql$Time__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setTimestamp(a0: jint, _ a1: java$sql$Timestamp?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setTimestamp_I_java$sql$Timestamp__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setUnicodeStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setUnicodeStream_I_java$io$InputStream_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func clearParameters() throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_clearParameters__V(jobj)()
    }

    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setObject_I_java$lang$Object_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setObject(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setObject_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func execute() throws -> jboolean {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_execute__Z(jobj)()
    }

    func addBatch() throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_addBatch__V(jobj)()
    }

    func setCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setRef(a0: jint, _ a1: java$sql$Ref?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setRef_I_java$sql$Ref__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setBlob(a0: jint, _ a1: java$sql$Blob?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBlob_I_java$sql$Blob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setClob(a0: jint, _ a1: java$sql$Clob?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setClob_I_java$sql$Clob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setArray(a0: jint, _ a1: java$sql$Array?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setArray_I_java$sql$Array__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func getMetaData() throws -> java$sql$ResultSetMetaData? {
        return try java$sql$ResultSetMetaData$(jobj: java$sql$PreparedStatement$.java$sql$PreparedStatement_getMetaData__java$sql$ResultSetMetaData(jobj)())
    }

    func setDate(a0: jint, _ a1: java$sql$Date?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setDate_I_java$sql$Date_java$util$Calendar__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setTime(a0: jint, _ a1: java$sql$Time?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setTime_I_java$sql$Time_java$util$Calendar__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setTimestamp(a0: jint, _ a1: java$sql$Timestamp?, _ a2: java$util$Calendar?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setTimestamp_I_java$sql$Timestamp_java$util$Calendar__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func setNull(a0: jint, _ a1: jint, _ a2: java$lang$String?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNull_I_I_java$lang$String__V(jobj)(a0, a1, a2?.jobj ?? nil)
    }

    func setURL(a0: jint, _ a1: java$net$URL?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setURL_I_java$net$URL__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func getParameterMetaData() throws -> java$sql$ParameterMetaData? {
        return try java$sql$ParameterMetaData$(jobj: java$sql$PreparedStatement$.java$sql$PreparedStatement_getParameterMetaData__java$sql$ParameterMetaData(jobj)())
    }

    func setRowId(a0: jint, _ a1: java$sql$RowId?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setRowId_I_java$sql$RowId__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setNString(a0: jint, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNString_I_java$lang$String__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setNCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNCharacterStream_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setNClob(a0: jint, _ a1: java$sql$NClob?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNClob_I_java$sql$NClob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setClob_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setBlob(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBlob_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setNClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNClob_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setSQLXML(a0: jint, _ a1: java$sql$SQLXML?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setSQLXML_I_java$sql$SQLXML__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setObject_I_java$lang$Object_I_I__V(jobj)(a0, a1?.jobj ?? nil, a2, a3)
    }

    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func setAsciiStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setAsciiStream_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setBinaryStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBinaryStream_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setCharacterStream_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setNCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNCharacterStream_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setClob(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setClob_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setBlob(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setBlob_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setNClob(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setNClob_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setObject_I_java$lang$Object_java$sql$SQLType_I__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
    }

    func setObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_setObject_I_java$lang$Object_java$sql$SQLType__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func executeLargeUpdate() throws -> jlong {
        return try java$sql$PreparedStatement$.java$sql$PreparedStatement_executeLargeUpdate__J(jobj)()
    }

}

public final class java$sql$PseudoColumnUsage : java$lang$Enum$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$PseudoColumnUsage_values__Ajava$sql$PseudoColumnUsage = svoker("values", returns: JArray(JObjectType("java/sql/PseudoColumnUsage")))
    public static func values() throws -> [java$sql$PseudoColumnUsage?]? {
        return try java$sql$PseudoColumnUsage$.java$sql$PseudoColumnUsage_values__Ajava$sql$PseudoColumnUsage().jarrayToArray(java$sql$PseudoColumnUsage$.self)?.map({ $0 as java$sql$PseudoColumnUsage? })
    }

    private static let java$sql$PseudoColumnUsage_valueOf_java$lang$String__java$sql$PseudoColumnUsage = svoker("valueOf", returns: JObjectType("java/sql/PseudoColumnUsage"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$PseudoColumnUsage? {
        return try java$sql$PseudoColumnUsage$(jobj: java$sql$PseudoColumnUsage$.java$sql$PseudoColumnUsage_valueOf_java$lang$String__java$sql$PseudoColumnUsage(a0?.jobj ?? nil))
    }

}

public typealias java$sql$PseudoColumnUsage$ = java$sql$PseudoColumnUsage

public protocol java$sql$Ref : JavaObject {
    func getBaseTypeName() throws -> java$lang$String?
    func getObject(a0: java$util$Map?) throws -> java$lang$Object?
    func getObject() throws -> java$lang$Object?
    func setObject(a0: java$lang$Object?) throws -> Void
}

public class java$sql$Ref$ : java$lang$Object$, java$sql$Ref {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Ref_getBaseTypeName__java$lang$String = invoker("getBaseTypeName", returns: JObjectType("java/lang/String"))
    private static let java$sql$Ref_getObject_java$util$Map__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Map")))
    private static let java$sql$Ref_getObject__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"))
    private static let java$sql$Ref_setObject_java$lang$Object__V = invoker("setObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
}

public extension java$sql$Ref {
    func getBaseTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Ref$.java$sql$Ref_getBaseTypeName__java$lang$String(jobj)())
    }

    func getObject(a0: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Ref$.java$sql$Ref_getObject_java$util$Map__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getObject() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Ref$.java$sql$Ref_getObject__java$lang$Object(jobj)())
    }

    func setObject(a0: java$lang$Object?) throws -> Void {
        return try java$sql$Ref$.java$sql$Ref_setObject_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

}

public protocol java$sql$ResultSet : java$sql$Wrapper, java$lang$AutoCloseable {
    func next() throws -> jboolean
    func close() throws -> Void
    func wasNull() throws -> jboolean
    func getString(a0: jint) throws -> java$lang$String?
    func getBoolean(a0: jint) throws -> jboolean
    func getByte(a0: jint) throws -> jbyte
    func getShort(a0: jint) throws -> jshort
    func getInt(a0: jint) throws -> jint
    func getLong(a0: jint) throws -> jlong
    func getFloat(a0: jint) throws -> jfloat
    func getDouble(a0: jint) throws -> jdouble
    func getBigDecimal(a0: jint, _ a1: jint) throws -> java$math$BigDecimal?
    func getBytes(a0: jint) throws -> [jbyte]?
    func getDate(a0: jint) throws -> java$sql$Date?
    func getTime(a0: jint) throws -> java$sql$Time?
    func getTimestamp(a0: jint) throws -> java$sql$Timestamp?
    func getAsciiStream(a0: jint) throws -> java$io$InputStream?
    func getUnicodeStream(a0: jint) throws -> java$io$InputStream?
    func getBinaryStream(a0: jint) throws -> java$io$InputStream?
    func getString(a0: java$lang$String?) throws -> java$lang$String?
    func getBoolean(a0: java$lang$String?) throws -> jboolean
    func getByte(a0: java$lang$String?) throws -> jbyte
    func getShort(a0: java$lang$String?) throws -> jshort
    func getInt(a0: java$lang$String?) throws -> jint
    func getLong(a0: java$lang$String?) throws -> jlong
    func getFloat(a0: java$lang$String?) throws -> jfloat
    func getDouble(a0: java$lang$String?) throws -> jdouble
    func getBigDecimal(a0: java$lang$String?, _ a1: jint) throws -> java$math$BigDecimal?
    func getBytes(a0: java$lang$String?) throws -> [jbyte]?
    func getDate(a0: java$lang$String?) throws -> java$sql$Date?
    func getTime(a0: java$lang$String?) throws -> java$sql$Time?
    func getTimestamp(a0: java$lang$String?) throws -> java$sql$Timestamp?
    func getAsciiStream(a0: java$lang$String?) throws -> java$io$InputStream?
    func getUnicodeStream(a0: java$lang$String?) throws -> java$io$InputStream?
    func getBinaryStream(a0: java$lang$String?) throws -> java$io$InputStream?
    func getWarnings() throws -> java$sql$SQLWarning?
    func clearWarnings() throws -> Void
    func getCursorName() throws -> java$lang$String?
    func getMetaData() throws -> java$sql$ResultSetMetaData?
    func getObject(a0: jint) throws -> java$lang$Object?
    func getObject(a0: java$lang$String?) throws -> java$lang$Object?
    func findColumn(a0: java$lang$String?) throws -> jint
    func getCharacterStream(a0: jint) throws -> java$io$Reader?
    func getCharacterStream(a0: java$lang$String?) throws -> java$io$Reader?
    func getBigDecimal(a0: jint) throws -> java$math$BigDecimal?
    func getBigDecimal(a0: java$lang$String?) throws -> java$math$BigDecimal?
    func isBeforeFirst() throws -> jboolean
    func isAfterLast() throws -> jboolean
    func isFirst() throws -> jboolean
    func isLast() throws -> jboolean
    func beforeFirst() throws -> Void
    func afterLast() throws -> Void
    func first() throws -> jboolean
    func last() throws -> jboolean
    func getRow() throws -> jint
    func absolute(a0: jint) throws -> jboolean
    func relative(a0: jint) throws -> jboolean
    func previous() throws -> jboolean
    func setFetchDirection(a0: jint) throws -> Void
    func getFetchDirection() throws -> jint
    func setFetchSize(a0: jint) throws -> Void
    func getFetchSize() throws -> jint
    func getType() throws -> jint
    func getConcurrency() throws -> jint
    func rowUpdated() throws -> jboolean
    func rowInserted() throws -> jboolean
    func rowDeleted() throws -> jboolean
    func updateNull(a0: jint) throws -> Void
    func updateBoolean(a0: jint, _ a1: jboolean) throws -> Void
    func updateByte(a0: jint, _ a1: jbyte) throws -> Void
    func updateShort(a0: jint, _ a1: jshort) throws -> Void
    func updateInt(a0: jint, _ a1: jint) throws -> Void
    func updateLong(a0: jint, _ a1: jlong) throws -> Void
    func updateFloat(a0: jint, _ a1: jfloat) throws -> Void
    func updateDouble(a0: jint, _ a1: jdouble) throws -> Void
    func updateBigDecimal(a0: jint, _ a1: java$math$BigDecimal?) throws -> Void
    func updateString(a0: jint, _ a1: java$lang$String?) throws -> Void
    func updateBytes(a0: jint, _ a1: [jbyte]?) throws -> Void
    func updateDate(a0: jint, _ a1: java$sql$Date?) throws -> Void
    func updateTime(a0: jint, _ a1: java$sql$Time?) throws -> Void
    func updateTimestamp(a0: jint, _ a1: java$sql$Timestamp?) throws -> Void
    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jint) throws -> Void
    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint) throws -> Void
    func updateObject(a0: jint, _ a1: java$lang$Object?) throws -> Void
    func updateNull(a0: java$lang$String?) throws -> Void
    func updateBoolean(a0: java$lang$String?, _ a1: jboolean) throws -> Void
    func updateByte(a0: java$lang$String?, _ a1: jbyte) throws -> Void
    func updateShort(a0: java$lang$String?, _ a1: jshort) throws -> Void
    func updateInt(a0: java$lang$String?, _ a1: jint) throws -> Void
    func updateLong(a0: java$lang$String?, _ a1: jlong) throws -> Void
    func updateFloat(a0: java$lang$String?, _ a1: jfloat) throws -> Void
    func updateDouble(a0: java$lang$String?, _ a1: jdouble) throws -> Void
    func updateBigDecimal(a0: java$lang$String?, _ a1: java$math$BigDecimal?) throws -> Void
    func updateString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void
    func updateBytes(a0: java$lang$String?, _ a1: [jbyte]?) throws -> Void
    func updateDate(a0: java$lang$String?, _ a1: java$sql$Date?) throws -> Void
    func updateTime(a0: java$lang$String?, _ a1: java$sql$Time?) throws -> Void
    func updateTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?) throws -> Void
    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void
    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jint) throws -> Void
    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void
    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void
    func insertRow() throws -> Void
    func updateRow() throws -> Void
    func deleteRow() throws -> Void
    func refreshRow() throws -> Void
    func cancelRowUpdates() throws -> Void
    func moveToInsertRow() throws -> Void
    func moveToCurrentRow() throws -> Void
    func getStatement() throws -> java$sql$Statement?
    func getObject(a0: jint, _ a1: java$util$Map?) throws -> java$lang$Object?
    func getRef(a0: jint) throws -> java$sql$Ref?
    func getBlob(a0: jint) throws -> java$sql$Blob?
    func getClob(a0: jint) throws -> java$sql$Clob?
    func getArray(a0: jint) throws -> java$sql$Array?
    func getObject(a0: java$lang$String?, _ a1: java$util$Map?) throws -> java$lang$Object?
    func getRef(a0: java$lang$String?) throws -> java$sql$Ref?
    func getBlob(a0: java$lang$String?) throws -> java$sql$Blob?
    func getClob(a0: java$lang$String?) throws -> java$sql$Clob?
    func getArray(a0: java$lang$String?) throws -> java$sql$Array?
    func getDate(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Date?
    func getDate(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Date?
    func getTime(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Time?
    func getTime(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Time?
    func getTimestamp(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp?
    func getTimestamp(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp?
    func getURL(a0: jint) throws -> java$net$URL?
    func getURL(a0: java$lang$String?) throws -> java$net$URL?
    func updateRef(a0: jint, _ a1: java$sql$Ref?) throws -> Void
    func updateRef(a0: java$lang$String?, _ a1: java$sql$Ref?) throws -> Void
    func updateBlob(a0: jint, _ a1: java$sql$Blob?) throws -> Void
    func updateBlob(a0: java$lang$String?, _ a1: java$sql$Blob?) throws -> Void
    func updateClob(a0: jint, _ a1: java$sql$Clob?) throws -> Void
    func updateClob(a0: java$lang$String?, _ a1: java$sql$Clob?) throws -> Void
    func updateArray(a0: jint, _ a1: java$sql$Array?) throws -> Void
    func updateArray(a0: java$lang$String?, _ a1: java$sql$Array?) throws -> Void
    func getRowId(a0: jint) throws -> java$sql$RowId?
    func getRowId(a0: java$lang$String?) throws -> java$sql$RowId?
    func updateRowId(a0: jint, _ a1: java$sql$RowId?) throws -> Void
    func updateRowId(a0: java$lang$String?, _ a1: java$sql$RowId?) throws -> Void
    func getHoldability() throws -> jint
    func isClosed() throws -> jboolean
    func updateNString(a0: jint, _ a1: java$lang$String?) throws -> Void
    func updateNString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void
    func updateNClob(a0: jint, _ a1: java$sql$NClob?) throws -> Void
    func updateNClob(a0: java$lang$String?, _ a1: java$sql$NClob?) throws -> Void
    func getNClob(a0: jint) throws -> java$sql$NClob?
    func getNClob(a0: java$lang$String?) throws -> java$sql$NClob?
    func getSQLXML(a0: jint) throws -> java$sql$SQLXML?
    func getSQLXML(a0: java$lang$String?) throws -> java$sql$SQLXML?
    func updateSQLXML(a0: jint, _ a1: java$sql$SQLXML?) throws -> Void
    func updateSQLXML(a0: java$lang$String?, _ a1: java$sql$SQLXML?) throws -> Void
    func getNString(a0: jint) throws -> java$lang$String?
    func getNString(a0: java$lang$String?) throws -> java$lang$String?
    func getNCharacterStream(a0: jint) throws -> java$io$Reader?
    func getNCharacterStream(a0: java$lang$String?) throws -> java$io$Reader?
    func updateNCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateBlob(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateBlob(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void
    func updateClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateNClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateNClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void
    func updateNCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func updateNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func updateBlob(a0: jint, _ a1: java$io$InputStream?) throws -> Void
    func updateBlob(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void
    func updateClob(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func updateClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func updateNClob(a0: jint, _ a1: java$io$Reader?) throws -> Void
    func updateNClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void
    func getObject(a0: jint, _ a1: java$lang$Class?) throws -> java$lang$Object?
    func getObject(a0: java$lang$String?, _ a1: java$lang$Class?) throws -> java$lang$Object?
    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void
    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void
    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void
    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void
}

public class java$sql$ResultSet$ : java$lang$Object$, java$sql$ResultSet, java$sql$Wrapper, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$ResultSet_next__Z = invoker("next", returns: jboolean.jniType)
    private static let java$sql$ResultSet_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$sql$ResultSet_wasNull__Z = invoker("wasNull", returns: jboolean.jniType)
    private static let java$sql$ResultSet_getString_I__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getBoolean_I__Z = invoker("getBoolean", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getByte_I__B = invoker("getByte", returns: jbyte.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getShort_I__S = invoker("getShort", returns: jshort.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getInt_I__I = invoker("getInt", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getLong_I__J = invoker("getLong", returns: jlong.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getFloat_I__F = invoker("getFloat", returns: jfloat.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getDouble_I__D = invoker("getDouble", returns: jdouble.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getBigDecimal_I_I__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType, jint.jniType))
    private static let java$sql$ResultSet_getBytes_I__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getDate_I__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getTime_I__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getTimestamp_I__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getAsciiStream_I__java$io$InputStream = invoker("getAsciiStream", returns: JObjectType("java/io/InputStream"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getUnicodeStream_I__java$io$InputStream = invoker("getUnicodeStream", returns: JObjectType("java/io/InputStream"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getBinaryStream_I__java$io$InputStream = invoker("getBinaryStream", returns: JObjectType("java/io/InputStream"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getString_java$lang$String__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getBoolean_java$lang$String__Z = invoker("getBoolean", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getByte_java$lang$String__B = invoker("getByte", returns: jbyte.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getShort_java$lang$String__S = invoker("getShort", returns: jshort.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getInt_java$lang$String__I = invoker("getInt", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getLong_java$lang$String__J = invoker("getLong", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getFloat_java$lang$String__F = invoker("getFloat", returns: jfloat.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getDouble_java$lang$String__D = invoker("getDouble", returns: jdouble.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getBigDecimal_java$lang$String_I__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$ResultSet_getBytes_java$lang$String__AB = invoker("getBytes", returns: JArray(jbyte.jniType), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getDate_java$lang$String__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getTime_java$lang$String__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getTimestamp_java$lang$String__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getAsciiStream_java$lang$String__java$io$InputStream = invoker("getAsciiStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getUnicodeStream_java$lang$String__java$io$InputStream = invoker("getUnicodeStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getBinaryStream_java$lang$String__java$io$InputStream = invoker("getBinaryStream", returns: JObjectType("java/io/InputStream"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getWarnings__java$sql$SQLWarning = invoker("getWarnings", returns: JObjectType("java/sql/SQLWarning"))
    private static let java$sql$ResultSet_clearWarnings__V = invoker("clearWarnings", returns: JVoid.jniType)
    private static let java$sql$ResultSet_getCursorName__java$lang$String = invoker("getCursorName", returns: JObjectType("java/lang/String"))
    private static let java$sql$ResultSet_getMetaData__java$sql$ResultSetMetaData = invoker("getMetaData", returns: JObjectType("java/sql/ResultSetMetaData"))
    private static let java$sql$ResultSet_getObject_I__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getObject_java$lang$String__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_findColumn_java$lang$String__I = invoker("findColumn", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getCharacterStream_I__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getCharacterStream_java$lang$String__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getBigDecimal_I__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getBigDecimal_java$lang$String__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_isBeforeFirst__Z = invoker("isBeforeFirst", returns: jboolean.jniType)
    private static let java$sql$ResultSet_isAfterLast__Z = invoker("isAfterLast", returns: jboolean.jniType)
    private static let java$sql$ResultSet_isFirst__Z = invoker("isFirst", returns: jboolean.jniType)
    private static let java$sql$ResultSet_isLast__Z = invoker("isLast", returns: jboolean.jniType)
    private static let java$sql$ResultSet_beforeFirst__V = invoker("beforeFirst", returns: JVoid.jniType)
    private static let java$sql$ResultSet_afterLast__V = invoker("afterLast", returns: JVoid.jniType)
    private static let java$sql$ResultSet_first__Z = invoker("first", returns: jboolean.jniType)
    private static let java$sql$ResultSet_last__Z = invoker("last", returns: jboolean.jniType)
    private static let java$sql$ResultSet_getRow__I = invoker("getRow", returns: jint.jniType)
    private static let java$sql$ResultSet_absolute_I__Z = invoker("absolute", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_relative_I__Z = invoker("relative", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_previous__Z = invoker("previous", returns: jboolean.jniType)
    private static let java$sql$ResultSet_setFetchDirection_I__V = invoker("setFetchDirection", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getFetchDirection__I = invoker("getFetchDirection", returns: jint.jniType)
    private static let java$sql$ResultSet_setFetchSize_I__V = invoker("setFetchSize", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_getFetchSize__I = invoker("getFetchSize", returns: jint.jniType)
    private static let java$sql$ResultSet_getType__I = invoker("getType", returns: jint.jniType)
    private static let java$sql$ResultSet_getConcurrency__I = invoker("getConcurrency", returns: jint.jniType)
    private static let java$sql$ResultSet_rowUpdated__Z = invoker("rowUpdated", returns: jboolean.jniType)
    private static let java$sql$ResultSet_rowInserted__Z = invoker("rowInserted", returns: jboolean.jniType)
    private static let java$sql$ResultSet_rowDeleted__Z = invoker("rowDeleted", returns: jboolean.jniType)
    private static let java$sql$ResultSet_updateNull_I__V = invoker("updateNull", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSet_updateBoolean_I_Z__V = invoker("updateBoolean", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    private static let java$sql$ResultSet_updateByte_I_B__V = invoker("updateByte", returns: JVoid.jniType, arguments: (jint.jniType, jbyte.jniType))
    private static let java$sql$ResultSet_updateShort_I_S__V = invoker("updateShort", returns: JVoid.jniType, arguments: (jint.jniType, jshort.jniType))
    private static let java$sql$ResultSet_updateInt_I_I__V = invoker("updateInt", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$sql$ResultSet_updateLong_I_J__V = invoker("updateLong", returns: JVoid.jniType, arguments: (jint.jniType, jlong.jniType))
    private static let java$sql$ResultSet_updateFloat_I_F__V = invoker("updateFloat", returns: JVoid.jniType, arguments: (jint.jniType, jfloat.jniType))
    private static let java$sql$ResultSet_updateDouble_I_D__V = invoker("updateDouble", returns: JVoid.jniType, arguments: (jint.jniType, jdouble.jniType))
    private static let java$sql$ResultSet_updateBigDecimal_I_java$math$BigDecimal__V = invoker("updateBigDecimal", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/math/BigDecimal")))
    private static let java$sql$ResultSet_updateString_I_java$lang$String__V = invoker("updateString", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateBytes_I_AB__V = invoker("updateBytes", returns: JVoid.jniType, arguments: (jint.jniType, JArray(jbyte.jniType)))
    private static let java$sql$ResultSet_updateDate_I_java$sql$Date__V = invoker("updateDate", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Date")))
    private static let java$sql$ResultSet_updateTime_I_java$sql$Time__V = invoker("updateTime", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Time")))
    private static let java$sql$ResultSet_updateTimestamp_I_java$sql$Timestamp__V = invoker("updateTimestamp", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Timestamp")))
    private static let java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream_I__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream_I__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$ResultSet_updateCharacterStream_I_java$io$Reader_I__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_I_java$lang$Object_I__V = invoker("updateObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_I_java$lang$Object__V = invoker("updateObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$sql$ResultSet_updateNull_java$lang$String__V = invoker("updateNull", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateBoolean_java$lang$String_Z__V = invoker("updateBoolean", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jboolean.jniType))
    private static let java$sql$ResultSet_updateByte_java$lang$String_B__V = invoker("updateByte", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jbyte.jniType))
    private static let java$sql$ResultSet_updateShort_java$lang$String_S__V = invoker("updateShort", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jshort.jniType))
    private static let java$sql$ResultSet_updateInt_java$lang$String_I__V = invoker("updateInt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$ResultSet_updateLong_java$lang$String_J__V = invoker("updateLong", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jlong.jniType))
    private static let java$sql$ResultSet_updateFloat_java$lang$String_F__V = invoker("updateFloat", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jfloat.jniType))
    private static let java$sql$ResultSet_updateDouble_java$lang$String_D__V = invoker("updateDouble", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jdouble.jniType))
    private static let java$sql$ResultSet_updateBigDecimal_java$lang$String_java$math$BigDecimal__V = invoker("updateBigDecimal", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/math/BigDecimal")))
    private static let java$sql$ResultSet_updateString_java$lang$String_java$lang$String__V = invoker("updateString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateBytes_java$lang$String_AB__V = invoker("updateBytes", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JArray(jbyte.jniType)))
    private static let java$sql$ResultSet_updateDate_java$lang$String_java$sql$Date__V = invoker("updateDate", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Date")))
    private static let java$sql$ResultSet_updateTime_java$lang$String_java$sql$Time__V = invoker("updateTime", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Time")))
    private static let java$sql$ResultSet_updateTimestamp_java$lang$String_java$sql$Timestamp__V = invoker("updateTimestamp", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Timestamp")))
    private static let java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream_I__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream_I__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jint.jniType))
    private static let java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader_I__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_I__V = invoker("updateObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object__V = invoker("updateObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    private static let java$sql$ResultSet_insertRow__V = invoker("insertRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_updateRow__V = invoker("updateRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_deleteRow__V = invoker("deleteRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_refreshRow__V = invoker("refreshRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_cancelRowUpdates__V = invoker("cancelRowUpdates", returns: JVoid.jniType)
    private static let java$sql$ResultSet_moveToInsertRow__V = invoker("moveToInsertRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_moveToCurrentRow__V = invoker("moveToCurrentRow", returns: JVoid.jniType)
    private static let java$sql$ResultSet_getStatement__java$sql$Statement = invoker("getStatement", returns: JObjectType("java/sql/Statement"))
    private static let java$sql$ResultSet_getObject_I_java$util$Map__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/util/Map")))
    private static let java$sql$ResultSet_getRef_I__java$sql$Ref = invoker("getRef", returns: JObjectType("java/sql/Ref"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getBlob_I__java$sql$Blob = invoker("getBlob", returns: JObjectType("java/sql/Blob"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getClob_I__java$sql$Clob = invoker("getClob", returns: JObjectType("java/sql/Clob"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getArray_I__java$sql$Array = invoker("getArray", returns: JObjectType("java/sql/Array"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getObject_java$lang$String_java$util$Map__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Map")))
    private static let java$sql$ResultSet_getRef_java$lang$String__java$sql$Ref = invoker("getRef", returns: JObjectType("java/sql/Ref"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getBlob_java$lang$String__java$sql$Blob = invoker("getBlob", returns: JObjectType("java/sql/Blob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getClob_java$lang$String__java$sql$Clob = invoker("getClob", returns: JObjectType("java/sql/Clob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getArray_java$lang$String__java$sql$Array = invoker("getArray", returns: JObjectType("java/sql/Array"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getDate_I_java$util$Calendar__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getDate_java$lang$String_java$util$Calendar__java$sql$Date = invoker("getDate", returns: JObjectType("java/sql/Date"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getTime_I_java$util$Calendar__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getTime_java$lang$String_java$util$Calendar__java$sql$Time = invoker("getTime", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getTimestamp_I_java$util$Calendar__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (jint.jniType, JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getTimestamp_java$lang$String_java$util$Calendar__java$sql$Timestamp = invoker("getTimestamp", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Calendar")))
    private static let java$sql$ResultSet_getURL_I__java$net$URL = invoker("getURL", returns: JObjectType("java/net/URL"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getURL_java$lang$String__java$net$URL = invoker("getURL", returns: JObjectType("java/net/URL"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateRef_I_java$sql$Ref__V = invoker("updateRef", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Ref")))
    private static let java$sql$ResultSet_updateRef_java$lang$String_java$sql$Ref__V = invoker("updateRef", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Ref")))
    private static let java$sql$ResultSet_updateBlob_I_java$sql$Blob__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Blob")))
    private static let java$sql$ResultSet_updateBlob_java$lang$String_java$sql$Blob__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Blob")))
    private static let java$sql$ResultSet_updateClob_I_java$sql$Clob__V = invoker("updateClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Clob")))
    private static let java$sql$ResultSet_updateClob_java$lang$String_java$sql$Clob__V = invoker("updateClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Clob")))
    private static let java$sql$ResultSet_updateArray_I_java$sql$Array__V = invoker("updateArray", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/Array")))
    private static let java$sql$ResultSet_updateArray_java$lang$String_java$sql$Array__V = invoker("updateArray", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/Array")))
    private static let java$sql$ResultSet_getRowId_I__java$sql$RowId = invoker("getRowId", returns: JObjectType("java/sql/RowId"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getRowId_java$lang$String__java$sql$RowId = invoker("getRowId", returns: JObjectType("java/sql/RowId"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateRowId_I_java$sql$RowId__V = invoker("updateRowId", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/RowId")))
    private static let java$sql$ResultSet_updateRowId_java$lang$String_java$sql$RowId__V = invoker("updateRowId", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/RowId")))
    private static let java$sql$ResultSet_getHoldability__I = invoker("getHoldability", returns: jint.jniType)
    private static let java$sql$ResultSet_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    private static let java$sql$ResultSet_updateNString_I_java$lang$String__V = invoker("updateNString", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateNString_java$lang$String_java$lang$String__V = invoker("updateNString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateNClob_I_java$sql$NClob__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/NClob")))
    private static let java$sql$ResultSet_updateNClob_java$lang$String_java$sql$NClob__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/NClob")))
    private static let java$sql$ResultSet_getNClob_I__java$sql$NClob = invoker("getNClob", returns: JObjectType("java/sql/NClob"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getNClob_java$lang$String__java$sql$NClob = invoker("getNClob", returns: JObjectType("java/sql/NClob"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getSQLXML_I__java$sql$SQLXML = invoker("getSQLXML", returns: JObjectType("java/sql/SQLXML"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getSQLXML_java$lang$String__java$sql$SQLXML = invoker("getSQLXML", returns: JObjectType("java/sql/SQLXML"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateSQLXML_I_java$sql$SQLXML__V = invoker("updateSQLXML", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/sql/SQLXML")))
    private static let java$sql$ResultSet_updateSQLXML_java$lang$String_java$sql$SQLXML__V = invoker("updateSQLXML", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/sql/SQLXML")))
    private static let java$sql$ResultSet_getNString_I__java$lang$String = invoker("getNString", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getNString_java$lang$String__java$lang$String = invoker("getNString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_getNCharacterStream_I__java$io$Reader = invoker("getNCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (jint.jniType))
    private static let java$sql$ResultSet_getNCharacterStream_java$lang$String__java$io$Reader = invoker("getNCharacterStream", returns: JObjectType("java/io/Reader"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$ResultSet_updateNCharacterStream_I_java$io$Reader_J__V = invoker("updateNCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateNCharacterStream_java$lang$String_java$io$Reader_J__V = invoker("updateNCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream_J__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream_J__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateCharacterStream_I_java$io$Reader_J__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream_J__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream_J__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader_J__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateBlob_I_java$io$InputStream_J__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateBlob_java$lang$String_java$io$InputStream_J__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream"), jlong.jniType))
    private static let java$sql$ResultSet_updateClob_I_java$io$Reader_J__V = invoker("updateClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateClob_java$lang$String_java$io$Reader_J__V = invoker("updateClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateNClob_I_java$io$Reader_J__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateNClob_java$lang$String_java$io$Reader_J__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader"), jlong.jniType))
    private static let java$sql$ResultSet_updateNCharacterStream_I_java$io$Reader__V = invoker("updateNCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateNCharacterStream_java$lang$String_java$io$Reader__V = invoker("updateNCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateCharacterStream_I_java$io$Reader__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream__V = invoker("updateAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream__V = invoker("updateBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader__V = invoker("updateCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateBlob_I_java$io$InputStream__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateBlob_java$lang$String_java$io$InputStream__V = invoker("updateBlob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/InputStream")))
    private static let java$sql$ResultSet_updateClob_I_java$io$Reader__V = invoker("updateClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateClob_java$lang$String_java$io$Reader__V = invoker("updateClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateNClob_I_java$io$Reader__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_updateNClob_java$lang$String_java$io$Reader__V = invoker("updateNClob", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/io/Reader")))
    private static let java$sql$ResultSet_getObject_I_java$lang$Class__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Class")))
    private static let java$sql$ResultSet_getObject_java$lang$String_java$lang$Class__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Class")))
    private static let java$sql$ResultSet_updateObject_I_java$lang$Object_java$sql$SQLType_I__V = invoker("updateObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_java$sql$SQLType_I__V = invoker("updateObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType"), jint.jniType))
    private static let java$sql$ResultSet_updateObject_I_java$lang$Object_java$sql$SQLType__V = invoker("updateObject", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType")))
    private static let java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_java$sql$SQLType__V = invoker("updateObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType")))
}

public extension java$sql$ResultSet {
    func next() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_next__Z(jobj)()
    }

    func close() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_close__V(jobj)()
    }

    func wasNull() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_wasNull__Z(jobj)()
    }

    func getString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getString_I__java$lang$String(jobj)(a0))
    }

    func getBoolean(a0: jint) throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_getBoolean_I__Z(jobj)(a0)
    }

    func getByte(a0: jint) throws -> jbyte {
        return try java$sql$ResultSet$.java$sql$ResultSet_getByte_I__B(jobj)(a0)
    }

    func getShort(a0: jint) throws -> jshort {
        return try java$sql$ResultSet$.java$sql$ResultSet_getShort_I__S(jobj)(a0)
    }

    func getInt(a0: jint) throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getInt_I__I(jobj)(a0)
    }

    func getLong(a0: jint) throws -> jlong {
        return try java$sql$ResultSet$.java$sql$ResultSet_getLong_I__J(jobj)(a0)
    }

    func getFloat(a0: jint) throws -> jfloat {
        return try java$sql$ResultSet$.java$sql$ResultSet_getFloat_I__F(jobj)(a0)
    }

    func getDouble(a0: jint) throws -> jdouble {
        return try java$sql$ResultSet$.java$sql$ResultSet_getDouble_I__D(jobj)(a0)
    }

    func getBigDecimal(a0: jint, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBigDecimal_I_I__java$math$BigDecimal(jobj)(a0, a1))
    }

    func getBytes(a0: jint) throws -> [jbyte]? {
        return try java$sql$ResultSet$.java$sql$ResultSet_getBytes_I__AB(jobj)(a0).jarrayToArray()
    }

    func getDate(a0: jint) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getDate_I__java$sql$Date(jobj)(a0))
    }

    func getTime(a0: jint) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTime_I__java$sql$Time(jobj)(a0))
    }

    func getTimestamp(a0: jint) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTimestamp_I__java$sql$Timestamp(jobj)(a0))
    }

    func getAsciiStream(a0: jint) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getAsciiStream_I__java$io$InputStream(jobj)(a0))
    }

    func getUnicodeStream(a0: jint) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getUnicodeStream_I__java$io$InputStream(jobj)(a0))
    }

    func getBinaryStream(a0: jint) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBinaryStream_I__java$io$InputStream(jobj)(a0))
    }

    func getString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getBoolean(a0: java$lang$String?) throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_getBoolean_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    func getByte(a0: java$lang$String?) throws -> jbyte {
        return try java$sql$ResultSet$.java$sql$ResultSet_getByte_java$lang$String__B(jobj)(a0?.jobj ?? nil)
    }

    func getShort(a0: java$lang$String?) throws -> jshort {
        return try java$sql$ResultSet$.java$sql$ResultSet_getShort_java$lang$String__S(jobj)(a0?.jobj ?? nil)
    }

    func getInt(a0: java$lang$String?) throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getInt_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    func getLong(a0: java$lang$String?) throws -> jlong {
        return try java$sql$ResultSet$.java$sql$ResultSet_getLong_java$lang$String__J(jobj)(a0?.jobj ?? nil)
    }

    func getFloat(a0: java$lang$String?) throws -> jfloat {
        return try java$sql$ResultSet$.java$sql$ResultSet_getFloat_java$lang$String__F(jobj)(a0?.jobj ?? nil)
    }

    func getDouble(a0: java$lang$String?) throws -> jdouble {
        return try java$sql$ResultSet$.java$sql$ResultSet_getDouble_java$lang$String__D(jobj)(a0?.jobj ?? nil)
    }

    func getBigDecimal(a0: java$lang$String?, _ a1: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBigDecimal_java$lang$String_I__java$math$BigDecimal(jobj)(a0?.jobj ?? nil, a1))
    }

    func getBytes(a0: java$lang$String?) throws -> [jbyte]? {
        return try java$sql$ResultSet$.java$sql$ResultSet_getBytes_java$lang$String__AB(jobj)(a0?.jobj ?? nil).jarrayToArray()
    }

    func getDate(a0: java$lang$String?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getDate_java$lang$String__java$sql$Date(jobj)(a0?.jobj ?? nil))
    }

    func getTime(a0: java$lang$String?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTime_java$lang$String__java$sql$Time(jobj)(a0?.jobj ?? nil))
    }

    func getTimestamp(a0: java$lang$String?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTimestamp_java$lang$String__java$sql$Timestamp(jobj)(a0?.jobj ?? nil))
    }

    func getAsciiStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getAsciiStream_java$lang$String__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    func getUnicodeStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getUnicodeStream_java$lang$String__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    func getBinaryStream(a0: java$lang$String?) throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBinaryStream_java$lang$String__java$io$InputStream(jobj)(a0?.jobj ?? nil))
    }

    func getWarnings() throws -> java$sql$SQLWarning? {
        return try java$sql$SQLWarning$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getWarnings__java$sql$SQLWarning(jobj)())
    }

    func clearWarnings() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_clearWarnings__V(jobj)()
    }

    func getCursorName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getCursorName__java$lang$String(jobj)())
    }

    func getMetaData() throws -> java$sql$ResultSetMetaData? {
        return try java$sql$ResultSetMetaData$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getMetaData__java$sql$ResultSetMetaData(jobj)())
    }

    func getObject(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_I__java$lang$Object(jobj)(a0))
    }

    func getObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func findColumn(a0: java$lang$String?) throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_findColumn_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    func getCharacterStream(a0: jint) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getCharacterStream_I__java$io$Reader(jobj)(a0))
    }

    func getCharacterStream(a0: java$lang$String?) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getCharacterStream_java$lang$String__java$io$Reader(jobj)(a0?.jobj ?? nil))
    }

    func getBigDecimal(a0: jint) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBigDecimal_I__java$math$BigDecimal(jobj)(a0))
    }

    func getBigDecimal(a0: java$lang$String?) throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBigDecimal_java$lang$String__java$math$BigDecimal(jobj)(a0?.jobj ?? nil))
    }

    func isBeforeFirst() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_isBeforeFirst__Z(jobj)()
    }

    func isAfterLast() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_isAfterLast__Z(jobj)()
    }

    func isFirst() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_isFirst__Z(jobj)()
    }

    func isLast() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_isLast__Z(jobj)()
    }

    func beforeFirst() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_beforeFirst__V(jobj)()
    }

    func afterLast() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_afterLast__V(jobj)()
    }

    func first() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_first__Z(jobj)()
    }

    func last() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_last__Z(jobj)()
    }

    func getRow() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getRow__I(jobj)()
    }

    func absolute(a0: jint) throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_absolute_I__Z(jobj)(a0)
    }

    func relative(a0: jint) throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_relative_I__Z(jobj)(a0)
    }

    func previous() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_previous__Z(jobj)()
    }

    func setFetchDirection(a0: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_setFetchDirection_I__V(jobj)(a0)
    }

    func getFetchDirection() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getFetchDirection__I(jobj)()
    }

    func setFetchSize(a0: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_setFetchSize_I__V(jobj)(a0)
    }

    func getFetchSize() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getFetchSize__I(jobj)()
    }

    func getType() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getType__I(jobj)()
    }

    func getConcurrency() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getConcurrency__I(jobj)()
    }

    func rowUpdated() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_rowUpdated__Z(jobj)()
    }

    func rowInserted() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_rowInserted__Z(jobj)()
    }

    func rowDeleted() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_rowDeleted__Z(jobj)()
    }

    func updateNull(a0: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNull_I__V(jobj)(a0)
    }

    func updateBoolean(a0: jint, _ a1: jboolean) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBoolean_I_Z__V(jobj)(a0, a1)
    }

    func updateByte(a0: jint, _ a1: jbyte) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateByte_I_B__V(jobj)(a0, a1)
    }

    func updateShort(a0: jint, _ a1: jshort) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateShort_I_S__V(jobj)(a0, a1)
    }

    func updateInt(a0: jint, _ a1: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateInt_I_I__V(jobj)(a0, a1)
    }

    func updateLong(a0: jint, _ a1: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateLong_I_J__V(jobj)(a0, a1)
    }

    func updateFloat(a0: jint, _ a1: jfloat) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateFloat_I_F__V(jobj)(a0, a1)
    }

    func updateDouble(a0: jint, _ a1: jdouble) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateDouble_I_D__V(jobj)(a0, a1)
    }

    func updateBigDecimal(a0: jint, _ a1: java$math$BigDecimal?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBigDecimal_I_java$math$BigDecimal__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateString(a0: jint, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateString_I_java$lang$String__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateBytes(a0: jint, _ a1: [jbyte]?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBytes_I_AB__V(jobj)(a0, a1?.arrayToJArray() ?? nil)
    }

    func updateDate(a0: jint, _ a1: java$sql$Date?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateDate_I_java$sql$Date__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateTime(a0: jint, _ a1: java$sql$Time?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateTime_I_java$sql$Time__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateTimestamp(a0: jint, _ a1: java$sql$Timestamp?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateTimestamp_I_java$sql$Timestamp__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_I_java$io$Reader_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_I_java$lang$Object_I__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateObject(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateNull(a0: java$lang$String?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNull_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func updateBoolean(a0: java$lang$String?, _ a1: jboolean) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBoolean_java$lang$String_Z__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateByte(a0: java$lang$String?, _ a1: jbyte) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateByte_java$lang$String_B__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateShort(a0: java$lang$String?, _ a1: jshort) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateShort_java$lang$String_S__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateInt(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateInt_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateLong(a0: java$lang$String?, _ a1: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateLong_java$lang$String_J__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateFloat(a0: java$lang$String?, _ a1: jfloat) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateFloat_java$lang$String_F__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateDouble(a0: java$lang$String?, _ a1: jdouble) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateDouble_java$lang$String_D__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func updateBigDecimal(a0: java$lang$String?, _ a1: java$math$BigDecimal?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBigDecimal_java$lang$String_java$math$BigDecimal__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateString_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateBytes(a0: java$lang$String?, _ a1: [jbyte]?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBytes_java$lang$String_AB__V(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
    }

    func updateDate(a0: java$lang$String?, _ a1: java$sql$Date?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateDate_java$lang$String_java$sql$Date__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateTime(a0: java$lang$String?, _ a1: java$sql$Time?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateTime_java$lang$String_java$sql$Time__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateTimestamp(a0: java$lang$String?, _ a1: java$sql$Timestamp?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateTimestamp_java$lang$String_java$sql$Timestamp__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func insertRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_insertRow__V(jobj)()
    }

    func updateRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateRow__V(jobj)()
    }

    func deleteRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_deleteRow__V(jobj)()
    }

    func refreshRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_refreshRow__V(jobj)()
    }

    func cancelRowUpdates() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_cancelRowUpdates__V(jobj)()
    }

    func moveToInsertRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_moveToInsertRow__V(jobj)()
    }

    func moveToCurrentRow() throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_moveToCurrentRow__V(jobj)()
    }

    func getStatement() throws -> java$sql$Statement? {
        return try java$sql$Statement$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getStatement__java$sql$Statement(jobj)())
    }

    func getObject(a0: jint, _ a1: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_I_java$util$Map__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    func getRef(a0: jint) throws -> java$sql$Ref? {
        return try java$sql$Ref$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getRef_I__java$sql$Ref(jobj)(a0))
    }

    func getBlob(a0: jint) throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBlob_I__java$sql$Blob(jobj)(a0))
    }

    func getClob(a0: jint) throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getClob_I__java$sql$Clob(jobj)(a0))
    }

    func getArray(a0: jint) throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getArray_I__java$sql$Array(jobj)(a0))
    }

    func getObject(a0: java$lang$String?, _ a1: java$util$Map?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_java$lang$String_java$util$Map__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getRef(a0: java$lang$String?) throws -> java$sql$Ref? {
        return try java$sql$Ref$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getRef_java$lang$String__java$sql$Ref(jobj)(a0?.jobj ?? nil))
    }

    func getBlob(a0: java$lang$String?) throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getBlob_java$lang$String__java$sql$Blob(jobj)(a0?.jobj ?? nil))
    }

    func getClob(a0: java$lang$String?) throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getClob_java$lang$String__java$sql$Clob(jobj)(a0?.jobj ?? nil))
    }

    func getArray(a0: java$lang$String?) throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getArray_java$lang$String__java$sql$Array(jobj)(a0?.jobj ?? nil))
    }

    func getDate(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getDate_I_java$util$Calendar__java$sql$Date(jobj)(a0, a1?.jobj ?? nil))
    }

    func getDate(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getDate_java$lang$String_java$util$Calendar__java$sql$Date(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getTime(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTime_I_java$util$Calendar__java$sql$Time(jobj)(a0, a1?.jobj ?? nil))
    }

    func getTime(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTime_java$lang$String_java$util$Calendar__java$sql$Time(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getTimestamp(a0: jint, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTimestamp_I_java$util$Calendar__java$sql$Timestamp(jobj)(a0, a1?.jobj ?? nil))
    }

    func getTimestamp(a0: java$lang$String?, _ a1: java$util$Calendar?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getTimestamp_java$lang$String_java$util$Calendar__java$sql$Timestamp(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func getURL(a0: jint) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getURL_I__java$net$URL(jobj)(a0))
    }

    func getURL(a0: java$lang$String?) throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getURL_java$lang$String__java$net$URL(jobj)(a0?.jobj ?? nil))
    }

    func updateRef(a0: jint, _ a1: java$sql$Ref?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateRef_I_java$sql$Ref__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateRef(a0: java$lang$String?, _ a1: java$sql$Ref?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateRef_java$lang$String_java$sql$Ref__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateBlob(a0: jint, _ a1: java$sql$Blob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_I_java$sql$Blob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateBlob(a0: java$lang$String?, _ a1: java$sql$Blob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_java$lang$String_java$sql$Blob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateClob(a0: jint, _ a1: java$sql$Clob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_I_java$sql$Clob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateClob(a0: java$lang$String?, _ a1: java$sql$Clob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_java$lang$String_java$sql$Clob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateArray(a0: jint, _ a1: java$sql$Array?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateArray_I_java$sql$Array__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateArray(a0: java$lang$String?, _ a1: java$sql$Array?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateArray_java$lang$String_java$sql$Array__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getRowId(a0: jint) throws -> java$sql$RowId? {
        return try java$sql$RowId$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getRowId_I__java$sql$RowId(jobj)(a0))
    }

    func getRowId(a0: java$lang$String?) throws -> java$sql$RowId? {
        return try java$sql$RowId$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getRowId_java$lang$String__java$sql$RowId(jobj)(a0?.jobj ?? nil))
    }

    func updateRowId(a0: jint, _ a1: java$sql$RowId?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateRowId_I_java$sql$RowId__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateRowId(a0: java$lang$String?, _ a1: java$sql$RowId?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateRowId_java$lang$String_java$sql$RowId__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getHoldability() throws -> jint {
        return try java$sql$ResultSet$.java$sql$ResultSet_getHoldability__I(jobj)()
    }

    func isClosed() throws -> jboolean {
        return try java$sql$ResultSet$.java$sql$ResultSet_isClosed__Z(jobj)()
    }

    func updateNString(a0: jint, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNString_I_java$lang$String__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateNString(a0: java$lang$String?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNString_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateNClob(a0: jint, _ a1: java$sql$NClob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_I_java$sql$NClob__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateNClob(a0: java$lang$String?, _ a1: java$sql$NClob?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_java$lang$String_java$sql$NClob__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getNClob(a0: jint) throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNClob_I__java$sql$NClob(jobj)(a0))
    }

    func getNClob(a0: java$lang$String?) throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNClob_java$lang$String__java$sql$NClob(jobj)(a0?.jobj ?? nil))
    }

    func getSQLXML(a0: jint) throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getSQLXML_I__java$sql$SQLXML(jobj)(a0))
    }

    func getSQLXML(a0: java$lang$String?) throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getSQLXML_java$lang$String__java$sql$SQLXML(jobj)(a0?.jobj ?? nil))
    }

    func updateSQLXML(a0: jint, _ a1: java$sql$SQLXML?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateSQLXML_I_java$sql$SQLXML__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateSQLXML(a0: java$lang$String?, _ a1: java$sql$SQLXML?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateSQLXML_java$lang$String_java$sql$SQLXML__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getNString(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNString_I__java$lang$String(jobj)(a0))
    }

    func getNString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getNCharacterStream(a0: jint) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNCharacterStream_I__java$io$Reader(jobj)(a0))
    }

    func getNCharacterStream(a0: java$lang$String?) throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getNCharacterStream_java$lang$String__java$io$Reader(jobj)(a0?.jobj ?? nil))
    }

    func updateNCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNCharacterStream_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNCharacterStream_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateBlob(a0: jint, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_I_java$io$InputStream_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateBlob(a0: java$lang$String?, _ a1: java$io$InputStream?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_java$lang$String_java$io$InputStream_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateNClob(a0: jint, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_I_java$io$Reader_J__V(jobj)(a0, a1?.jobj ?? nil, a2)
    }

    func updateNClob(a0: java$lang$String?, _ a1: java$io$Reader?, _ a2: jlong) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_java$lang$String_java$io$Reader_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func updateNCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNCharacterStream_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateNCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNCharacterStream_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateAsciiStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateBinaryStream(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateCharacterStream(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateAsciiStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateAsciiStream_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateBinaryStream(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBinaryStream_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateCharacterStream(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateCharacterStream_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateBlob(a0: jint, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_I_java$io$InputStream__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateBlob(a0: java$lang$String?, _ a1: java$io$InputStream?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateBlob_java$lang$String_java$io$InputStream__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateClob(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateClob_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func updateNClob(a0: jint, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_I_java$io$Reader__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func updateNClob(a0: java$lang$String?, _ a1: java$io$Reader?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateNClob_java$lang$String_java$io$Reader__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func getObject(a0: jint, _ a1: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_I_java$lang$Class__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    func getObject(a0: java$lang$String?, _ a1: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$ResultSet$.java$sql$ResultSet_getObject_java$lang$String_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_I_java$lang$Object_java$sql$SQLType_I__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
    }

    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?, _ a3: jint) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_java$sql$SQLType_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3)
    }

    func updateObject(a0: jint, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_I_java$lang$Object_java$sql$SQLType__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func updateObject(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: java$sql$SQLType?) throws -> Void {
        return try java$sql$ResultSet$.java$sql$ResultSet_updateObject_java$lang$String_java$lang$Object_java$sql$SQLType__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

}

public protocol java$sql$ResultSetMetaData : java$sql$Wrapper {
    func getColumnCount() throws -> jint
    func isAutoIncrement(a0: jint) throws -> jboolean
    func isCaseSensitive(a0: jint) throws -> jboolean
    func isSearchable(a0: jint) throws -> jboolean
    func isCurrency(a0: jint) throws -> jboolean
    func isNullable(a0: jint) throws -> jint
    func isSigned(a0: jint) throws -> jboolean
    func getColumnDisplaySize(a0: jint) throws -> jint
    func getColumnLabel(a0: jint) throws -> java$lang$String?
    func getColumnName(a0: jint) throws -> java$lang$String?
    func getSchemaName(a0: jint) throws -> java$lang$String?
    func getPrecision(a0: jint) throws -> jint
    func getScale(a0: jint) throws -> jint
    func getTableName(a0: jint) throws -> java$lang$String?
    func getCatalogName(a0: jint) throws -> java$lang$String?
    func getColumnType(a0: jint) throws -> jint
    func getColumnTypeName(a0: jint) throws -> java$lang$String?
    func isReadOnly(a0: jint) throws -> jboolean
    func isWritable(a0: jint) throws -> jboolean
    func isDefinitelyWritable(a0: jint) throws -> jboolean
    func getColumnClassName(a0: jint) throws -> java$lang$String?
}

public class java$sql$ResultSetMetaData$ : java$lang$Object$, java$sql$ResultSetMetaData, java$sql$Wrapper {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$ResultSetMetaData_getColumnCount__I = invoker("getColumnCount", returns: jint.jniType)
    private static let java$sql$ResultSetMetaData_isAutoIncrement_I__Z = invoker("isAutoIncrement", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isCaseSensitive_I__Z = invoker("isCaseSensitive", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isSearchable_I__Z = invoker("isSearchable", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isCurrency_I__Z = invoker("isCurrency", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isNullable_I__I = invoker("isNullable", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isSigned_I__Z = invoker("isSigned", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnDisplaySize_I__I = invoker("getColumnDisplaySize", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnLabel_I__java$lang$String = invoker("getColumnLabel", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnName_I__java$lang$String = invoker("getColumnName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getSchemaName_I__java$lang$String = invoker("getSchemaName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getPrecision_I__I = invoker("getPrecision", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getScale_I__I = invoker("getScale", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getTableName_I__java$lang$String = invoker("getTableName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getCatalogName_I__java$lang$String = invoker("getCatalogName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnType_I__I = invoker("getColumnType", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnTypeName_I__java$lang$String = invoker("getColumnTypeName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isReadOnly_I__Z = invoker("isReadOnly", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isWritable_I__Z = invoker("isWritable", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_isDefinitelyWritable_I__Z = invoker("isDefinitelyWritable", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$ResultSetMetaData_getColumnClassName_I__java$lang$String = invoker("getColumnClassName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType))
}

public extension java$sql$ResultSetMetaData {
    func getColumnCount() throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnCount__I(jobj)()
    }

    func isAutoIncrement(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isAutoIncrement_I__Z(jobj)(a0)
    }

    func isCaseSensitive(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isCaseSensitive_I__Z(jobj)(a0)
    }

    func isSearchable(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isSearchable_I__Z(jobj)(a0)
    }

    func isCurrency(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isCurrency_I__Z(jobj)(a0)
    }

    func isNullable(a0: jint) throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isNullable_I__I(jobj)(a0)
    }

    func isSigned(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isSigned_I__Z(jobj)(a0)
    }

    func getColumnDisplaySize(a0: jint) throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnDisplaySize_I__I(jobj)(a0)
    }

    func getColumnLabel(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnLabel_I__java$lang$String(jobj)(a0))
    }

    func getColumnName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnName_I__java$lang$String(jobj)(a0))
    }

    func getSchemaName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getSchemaName_I__java$lang$String(jobj)(a0))
    }

    func getPrecision(a0: jint) throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getPrecision_I__I(jobj)(a0)
    }

    func getScale(a0: jint) throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getScale_I__I(jobj)(a0)
    }

    func getTableName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getTableName_I__java$lang$String(jobj)(a0))
    }

    func getCatalogName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getCatalogName_I__java$lang$String(jobj)(a0))
    }

    func getColumnType(a0: jint) throws -> jint {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnType_I__I(jobj)(a0)
    }

    func getColumnTypeName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnTypeName_I__java$lang$String(jobj)(a0))
    }

    func isReadOnly(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isReadOnly_I__Z(jobj)(a0)
    }

    func isWritable(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isWritable_I__Z(jobj)(a0)
    }

    func isDefinitelyWritable(a0: jint) throws -> jboolean {
        return try java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_isDefinitelyWritable_I__Z(jobj)(a0)
    }

    func getColumnClassName(a0: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$ResultSetMetaData$.java$sql$ResultSetMetaData_getColumnClassName_I__java$lang$String(jobj)(a0))
    }

}

public protocol java$sql$RowId : JavaObject {
    func equals(a0: java$lang$Object?) throws -> jboolean
    func getBytes() throws -> [jbyte]?
    func toString() throws -> java$lang$String?
    func hashCode() throws -> jint
}

public class java$sql$RowId$ : java$lang$Object$, java$sql$RowId {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$RowId_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$sql$RowId_getBytes__AB = invoker("getBytes", returns: JArray(jbyte.jniType))
    private static let java$sql$RowId_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$sql$RowId_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public extension java$sql$RowId {
    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$sql$RowId$.java$sql$RowId_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func getBytes() throws -> [jbyte]? {
        return try java$sql$RowId$.java$sql$RowId_getBytes__AB(jobj)().jarrayToArray()
    }

    func toString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$RowId$.java$sql$RowId_toString__java$lang$String(jobj)())
    }

    func hashCode() throws -> jint {
        return try java$sql$RowId$.java$sql$RowId_hashCode__I(jobj)()
    }

}

public final class java$sql$RowIdLifetime : java$lang$Enum$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$RowIdLifetime_values__Ajava$sql$RowIdLifetime = svoker("values", returns: JArray(JObjectType("java/sql/RowIdLifetime")))
    public static func values() throws -> [java$sql$RowIdLifetime?]? {
        return try java$sql$RowIdLifetime$.java$sql$RowIdLifetime_values__Ajava$sql$RowIdLifetime().jarrayToArray(java$sql$RowIdLifetime$.self)?.map({ $0 as java$sql$RowIdLifetime? })
    }

    private static let java$sql$RowIdLifetime_valueOf_java$lang$String__java$sql$RowIdLifetime = svoker("valueOf", returns: JObjectType("java/sql/RowIdLifetime"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$RowIdLifetime? {
        return try java$sql$RowIdLifetime$(jobj: java$sql$RowIdLifetime$.java$sql$RowIdLifetime_valueOf_java$lang$String__java$sql$RowIdLifetime(a0?.jobj ?? nil))
    }

}

public typealias java$sql$RowIdLifetime$ = java$sql$RowIdLifetime

public protocol java$sql$SQLData : JavaObject {
    func getSQLTypeName() throws -> java$lang$String?
    func readSQL(a0: java$sql$SQLInput?, _ a1: java$lang$String?) throws -> Void
    func writeSQL(a0: java$sql$SQLOutput?) throws -> Void
}

public class java$sql$SQLData$ : java$lang$Object$, java$sql$SQLData {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLData_getSQLTypeName__java$lang$String = invoker("getSQLTypeName", returns: JObjectType("java/lang/String"))
    private static let java$sql$SQLData_readSQL_java$sql$SQLInput_java$lang$String__V = invoker("readSQL", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLInput"), JObjectType("java/lang/String")))
    private static let java$sql$SQLData_writeSQL_java$sql$SQLOutput__V = invoker("writeSQL", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLOutput")))
}

public extension java$sql$SQLData {
    func getSQLTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$SQLData$.java$sql$SQLData_getSQLTypeName__java$lang$String(jobj)())
    }

    func readSQL(a0: java$sql$SQLInput?, _ a1: java$lang$String?) throws -> Void {
        return try java$sql$SQLData$.java$sql$SQLData_readSQL_java$sql$SQLInput_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func writeSQL(a0: java$sql$SQLOutput?) throws -> Void {
        return try java$sql$SQLData$.java$sql$SQLData_writeSQL_java$sql$SQLOutput__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$sql$SQLException : java$lang$Exception$, java$lang$Iterable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLException_init_java$lang$String_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String_java$lang$String_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$String_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_init_java$lang$String_java$lang$String_I_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint, _ a3: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLException$.java$sql$SQLException_init_java$lang$String_java$lang$String_I_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLException_getSQLState__java$lang$String = invoker("getSQLState", returns: JObjectType("java/lang/String"))
    public func getSQLState() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$SQLException$.java$sql$SQLException_getSQLState__java$lang$String(jobj)())
    }

    private static let java$sql$SQLException_getErrorCode__I = invoker("getErrorCode", returns: jint.jniType)
    public func getErrorCode() throws -> jint {
        return try java$sql$SQLException$.java$sql$SQLException_getErrorCode__I(jobj)()
    }

    private static let java$sql$SQLException_getNextException__java$sql$SQLException = invoker("getNextException", returns: JObjectType("java/sql/SQLException"))
    public func getNextException() throws -> java$sql$SQLException? {
        return try java$sql$SQLException$(jobj: java$sql$SQLException$.java$sql$SQLException_getNextException__java$sql$SQLException(jobj)())
    }

    private static let java$sql$SQLException_setNextException_java$sql$SQLException__V = invoker("setNextException", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLException")))
    public func setNextException(a0: java$sql$SQLException?) throws -> Void {
        return try java$sql$SQLException$.java$sql$SQLException_setNextException_java$sql$SQLException__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$sql$SQLException_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    public func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$sql$SQLException$.java$sql$SQLException_iterator__java$util$Iterator(jobj)())
    }

}

public typealias java$sql$SQLException$ = java$sql$SQLException

public protocol java$sql$SQLInput : JavaObject {
    func readString() throws -> java$lang$String?
    func readBoolean() throws -> jboolean
    func readByte() throws -> jbyte
    func readShort() throws -> jshort
    func readInt() throws -> jint
    func readLong() throws -> jlong
    func readFloat() throws -> jfloat
    func readDouble() throws -> jdouble
    func readBigDecimal() throws -> java$math$BigDecimal?
    func readBytes() throws -> [jbyte]?
    func readDate() throws -> java$sql$Date?
    func readTime() throws -> java$sql$Time?
    func readTimestamp() throws -> java$sql$Timestamp?
    func readCharacterStream() throws -> java$io$Reader?
    func readAsciiStream() throws -> java$io$InputStream?
    func readBinaryStream() throws -> java$io$InputStream?
    func readObject() throws -> java$lang$Object?
    func readRef() throws -> java$sql$Ref?
    func readBlob() throws -> java$sql$Blob?
    func readClob() throws -> java$sql$Clob?
    func readArray() throws -> java$sql$Array?
    func wasNull() throws -> jboolean
    func readURL() throws -> java$net$URL?
    func readNClob() throws -> java$sql$NClob?
    func readNString() throws -> java$lang$String?
    func readSQLXML() throws -> java$sql$SQLXML?
    func readRowId() throws -> java$sql$RowId?
    func readObject(a0: java$lang$Class?) throws -> java$lang$Object?
}

public class java$sql$SQLInput$ : java$lang$Object$, java$sql$SQLInput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLInput_readString__java$lang$String = invoker("readString", returns: JObjectType("java/lang/String"))
    private static let java$sql$SQLInput_readBoolean__Z = invoker("readBoolean", returns: jboolean.jniType)
    private static let java$sql$SQLInput_readByte__B = invoker("readByte", returns: jbyte.jniType)
    private static let java$sql$SQLInput_readShort__S = invoker("readShort", returns: jshort.jniType)
    private static let java$sql$SQLInput_readInt__I = invoker("readInt", returns: jint.jniType)
    private static let java$sql$SQLInput_readLong__J = invoker("readLong", returns: jlong.jniType)
    private static let java$sql$SQLInput_readFloat__F = invoker("readFloat", returns: jfloat.jniType)
    private static let java$sql$SQLInput_readDouble__D = invoker("readDouble", returns: jdouble.jniType)
    private static let java$sql$SQLInput_readBigDecimal__java$math$BigDecimal = invoker("readBigDecimal", returns: JObjectType("java/math/BigDecimal"))
    private static let java$sql$SQLInput_readBytes__AB = invoker("readBytes", returns: JArray(jbyte.jniType))
    private static let java$sql$SQLInput_readDate__java$sql$Date = invoker("readDate", returns: JObjectType("java/sql/Date"))
    private static let java$sql$SQLInput_readTime__java$sql$Time = invoker("readTime", returns: JObjectType("java/sql/Time"))
    private static let java$sql$SQLInput_readTimestamp__java$sql$Timestamp = invoker("readTimestamp", returns: JObjectType("java/sql/Timestamp"))
    private static let java$sql$SQLInput_readCharacterStream__java$io$Reader = invoker("readCharacterStream", returns: JObjectType("java/io/Reader"))
    private static let java$sql$SQLInput_readAsciiStream__java$io$InputStream = invoker("readAsciiStream", returns: JObjectType("java/io/InputStream"))
    private static let java$sql$SQLInput_readBinaryStream__java$io$InputStream = invoker("readBinaryStream", returns: JObjectType("java/io/InputStream"))
    private static let java$sql$SQLInput_readObject__java$lang$Object = invoker("readObject", returns: JObjectType("java/lang/Object"))
    private static let java$sql$SQLInput_readRef__java$sql$Ref = invoker("readRef", returns: JObjectType("java/sql/Ref"))
    private static let java$sql$SQLInput_readBlob__java$sql$Blob = invoker("readBlob", returns: JObjectType("java/sql/Blob"))
    private static let java$sql$SQLInput_readClob__java$sql$Clob = invoker("readClob", returns: JObjectType("java/sql/Clob"))
    private static let java$sql$SQLInput_readArray__java$sql$Array = invoker("readArray", returns: JObjectType("java/sql/Array"))
    private static let java$sql$SQLInput_wasNull__Z = invoker("wasNull", returns: jboolean.jniType)
    private static let java$sql$SQLInput_readURL__java$net$URL = invoker("readURL", returns: JObjectType("java/net/URL"))
    private static let java$sql$SQLInput_readNClob__java$sql$NClob = invoker("readNClob", returns: JObjectType("java/sql/NClob"))
    private static let java$sql$SQLInput_readNString__java$lang$String = invoker("readNString", returns: JObjectType("java/lang/String"))
    private static let java$sql$SQLInput_readSQLXML__java$sql$SQLXML = invoker("readSQLXML", returns: JObjectType("java/sql/SQLXML"))
    private static let java$sql$SQLInput_readRowId__java$sql$RowId = invoker("readRowId", returns: JObjectType("java/sql/RowId"))
    private static let java$sql$SQLInput_readObject_java$lang$Class__java$lang$Object = invoker("readObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class")))
}

public extension java$sql$SQLInput {
    func readString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readString__java$lang$String(jobj)())
    }

    func readBoolean() throws -> jboolean {
        return try java$sql$SQLInput$.java$sql$SQLInput_readBoolean__Z(jobj)()
    }

    func readByte() throws -> jbyte {
        return try java$sql$SQLInput$.java$sql$SQLInput_readByte__B(jobj)()
    }

    func readShort() throws -> jshort {
        return try java$sql$SQLInput$.java$sql$SQLInput_readShort__S(jobj)()
    }

    func readInt() throws -> jint {
        return try java$sql$SQLInput$.java$sql$SQLInput_readInt__I(jobj)()
    }

    func readLong() throws -> jlong {
        return try java$sql$SQLInput$.java$sql$SQLInput_readLong__J(jobj)()
    }

    func readFloat() throws -> jfloat {
        return try java$sql$SQLInput$.java$sql$SQLInput_readFloat__F(jobj)()
    }

    func readDouble() throws -> jdouble {
        return try java$sql$SQLInput$.java$sql$SQLInput_readDouble__D(jobj)()
    }

    func readBigDecimal() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readBigDecimal__java$math$BigDecimal(jobj)())
    }

    func readBytes() throws -> [jbyte]? {
        return try java$sql$SQLInput$.java$sql$SQLInput_readBytes__AB(jobj)().jarrayToArray()
    }

    func readDate() throws -> java$sql$Date? {
        return try java$sql$Date$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readDate__java$sql$Date(jobj)())
    }

    func readTime() throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readTime__java$sql$Time(jobj)())
    }

    func readTimestamp() throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readTimestamp__java$sql$Timestamp(jobj)())
    }

    func readCharacterStream() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readCharacterStream__java$io$Reader(jobj)())
    }

    func readAsciiStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readAsciiStream__java$io$InputStream(jobj)())
    }

    func readBinaryStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readBinaryStream__java$io$InputStream(jobj)())
    }

    func readObject() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readObject__java$lang$Object(jobj)())
    }

    func readRef() throws -> java$sql$Ref? {
        return try java$sql$Ref$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readRef__java$sql$Ref(jobj)())
    }

    func readBlob() throws -> java$sql$Blob? {
        return try java$sql$Blob$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readBlob__java$sql$Blob(jobj)())
    }

    func readClob() throws -> java$sql$Clob? {
        return try java$sql$Clob$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readClob__java$sql$Clob(jobj)())
    }

    func readArray() throws -> java$sql$Array? {
        return try java$sql$Array$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readArray__java$sql$Array(jobj)())
    }

    func wasNull() throws -> jboolean {
        return try java$sql$SQLInput$.java$sql$SQLInput_wasNull__Z(jobj)()
    }

    func readURL() throws -> java$net$URL? {
        return try java$net$URL$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readURL__java$net$URL(jobj)())
    }

    func readNClob() throws -> java$sql$NClob? {
        return try java$sql$NClob$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readNClob__java$sql$NClob(jobj)())
    }

    func readNString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readNString__java$lang$String(jobj)())
    }

    func readSQLXML() throws -> java$sql$SQLXML? {
        return try java$sql$SQLXML$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readSQLXML__java$sql$SQLXML(jobj)())
    }

    func readRowId() throws -> java$sql$RowId? {
        return try java$sql$RowId$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readRowId__java$sql$RowId(jobj)())
    }

    func readObject(a0: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$SQLInput$.java$sql$SQLInput_readObject_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

}

public protocol java$sql$SQLOutput : JavaObject {
    func writeString(a0: java$lang$String?) throws -> Void
    func writeBoolean(a0: jboolean) throws -> Void
    func writeByte(a0: jbyte) throws -> Void
    func writeShort(a0: jshort) throws -> Void
    func writeInt(a0: jint) throws -> Void
    func writeLong(a0: jlong) throws -> Void
    func writeFloat(a0: jfloat) throws -> Void
    func writeDouble(a0: jdouble) throws -> Void
    func writeBigDecimal(a0: java$math$BigDecimal?) throws -> Void
    func writeBytes(a0: [jbyte]?) throws -> Void
    func writeDate(a0: java$sql$Date?) throws -> Void
    func writeTime(a0: java$sql$Time?) throws -> Void
    func writeTimestamp(a0: java$sql$Timestamp?) throws -> Void
    func writeCharacterStream(a0: java$io$Reader?) throws -> Void
    func writeAsciiStream(a0: java$io$InputStream?) throws -> Void
    func writeBinaryStream(a0: java$io$InputStream?) throws -> Void
    func writeObject(a0: java$sql$SQLData?) throws -> Void
    func writeRef(a0: java$sql$Ref?) throws -> Void
    func writeBlob(a0: java$sql$Blob?) throws -> Void
    func writeClob(a0: java$sql$Clob?) throws -> Void
    func writeStruct(a0: java$sql$Struct?) throws -> Void
    func writeArray(a0: java$sql$Array?) throws -> Void
    func writeURL(a0: java$net$URL?) throws -> Void
    func writeNString(a0: java$lang$String?) throws -> Void
    func writeNClob(a0: java$sql$NClob?) throws -> Void
    func writeRowId(a0: java$sql$RowId?) throws -> Void
    func writeSQLXML(a0: java$sql$SQLXML?) throws -> Void
    func writeObject(a0: java$lang$Object?, _ a1: java$sql$SQLType?) throws -> Void
}

public class java$sql$SQLOutput$ : java$lang$Object$, java$sql$SQLOutput {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLOutput_writeString_java$lang$String__V = invoker("writeString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$SQLOutput_writeBoolean_Z__V = invoker("writeBoolean", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$sql$SQLOutput_writeByte_B__V = invoker("writeByte", returns: JVoid.jniType, arguments: (jbyte.jniType))
    private static let java$sql$SQLOutput_writeShort_S__V = invoker("writeShort", returns: JVoid.jniType, arguments: (jshort.jniType))
    private static let java$sql$SQLOutput_writeInt_I__V = invoker("writeInt", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$SQLOutput_writeLong_J__V = invoker("writeLong", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$SQLOutput_writeFloat_F__V = invoker("writeFloat", returns: JVoid.jniType, arguments: (jfloat.jniType))
    private static let java$sql$SQLOutput_writeDouble_D__V = invoker("writeDouble", returns: JVoid.jniType, arguments: (jdouble.jniType))
    private static let java$sql$SQLOutput_writeBigDecimal_java$math$BigDecimal__V = invoker("writeBigDecimal", returns: JVoid.jniType, arguments: (JObjectType("java/math/BigDecimal")))
    private static let java$sql$SQLOutput_writeBytes_AB__V = invoker("writeBytes", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    private static let java$sql$SQLOutput_writeDate_java$sql$Date__V = invoker("writeDate", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Date")))
    private static let java$sql$SQLOutput_writeTime_java$sql$Time__V = invoker("writeTime", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Time")))
    private static let java$sql$SQLOutput_writeTimestamp_java$sql$Timestamp__V = invoker("writeTimestamp", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Timestamp")))
    private static let java$sql$SQLOutput_writeCharacterStream_java$io$Reader__V = invoker("writeCharacterStream", returns: JVoid.jniType, arguments: (JObjectType("java/io/Reader")))
    private static let java$sql$SQLOutput_writeAsciiStream_java$io$InputStream__V = invoker("writeAsciiStream", returns: JVoid.jniType, arguments: (JObjectType("java/io/InputStream")))
    private static let java$sql$SQLOutput_writeBinaryStream_java$io$InputStream__V = invoker("writeBinaryStream", returns: JVoid.jniType, arguments: (JObjectType("java/io/InputStream")))
    private static let java$sql$SQLOutput_writeObject_java$sql$SQLData__V = invoker("writeObject", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLData")))
    private static let java$sql$SQLOutput_writeRef_java$sql$Ref__V = invoker("writeRef", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Ref")))
    private static let java$sql$SQLOutput_writeBlob_java$sql$Blob__V = invoker("writeBlob", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Blob")))
    private static let java$sql$SQLOutput_writeClob_java$sql$Clob__V = invoker("writeClob", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Clob")))
    private static let java$sql$SQLOutput_writeStruct_java$sql$Struct__V = invoker("writeStruct", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Struct")))
    private static let java$sql$SQLOutput_writeArray_java$sql$Array__V = invoker("writeArray", returns: JVoid.jniType, arguments: (JObjectType("java/sql/Array")))
    private static let java$sql$SQLOutput_writeURL_java$net$URL__V = invoker("writeURL", returns: JVoid.jniType, arguments: (JObjectType("java/net/URL")))
    private static let java$sql$SQLOutput_writeNString_java$lang$String__V = invoker("writeNString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$SQLOutput_writeNClob_java$sql$NClob__V = invoker("writeNClob", returns: JVoid.jniType, arguments: (JObjectType("java/sql/NClob")))
    private static let java$sql$SQLOutput_writeRowId_java$sql$RowId__V = invoker("writeRowId", returns: JVoid.jniType, arguments: (JObjectType("java/sql/RowId")))
    private static let java$sql$SQLOutput_writeSQLXML_java$sql$SQLXML__V = invoker("writeSQLXML", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLXML")))
    private static let java$sql$SQLOutput_writeObject_java$lang$Object_java$sql$SQLType__V = invoker("writeObject", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/sql/SQLType")))
}

public extension java$sql$SQLOutput {
    func writeString(a0: java$lang$String?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeString_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func writeBoolean(a0: jboolean) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeBoolean_Z__V(jobj)(a0)
    }

    func writeByte(a0: jbyte) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeByte_B__V(jobj)(a0)
    }

    func writeShort(a0: jshort) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeShort_S__V(jobj)(a0)
    }

    func writeInt(a0: jint) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeInt_I__V(jobj)(a0)
    }

    func writeLong(a0: jlong) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeLong_J__V(jobj)(a0)
    }

    func writeFloat(a0: jfloat) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeFloat_F__V(jobj)(a0)
    }

    func writeDouble(a0: jdouble) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeDouble_D__V(jobj)(a0)
    }

    func writeBigDecimal(a0: java$math$BigDecimal?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeBigDecimal_java$math$BigDecimal__V(jobj)(a0?.jobj ?? nil)
    }

    func writeBytes(a0: [jbyte]?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeBytes_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    func writeDate(a0: java$sql$Date?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeDate_java$sql$Date__V(jobj)(a0?.jobj ?? nil)
    }

    func writeTime(a0: java$sql$Time?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeTime_java$sql$Time__V(jobj)(a0?.jobj ?? nil)
    }

    func writeTimestamp(a0: java$sql$Timestamp?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeTimestamp_java$sql$Timestamp__V(jobj)(a0?.jobj ?? nil)
    }

    func writeCharacterStream(a0: java$io$Reader?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeCharacterStream_java$io$Reader__V(jobj)(a0?.jobj ?? nil)
    }

    func writeAsciiStream(a0: java$io$InputStream?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeAsciiStream_java$io$InputStream__V(jobj)(a0?.jobj ?? nil)
    }

    func writeBinaryStream(a0: java$io$InputStream?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeBinaryStream_java$io$InputStream__V(jobj)(a0?.jobj ?? nil)
    }

    func writeObject(a0: java$sql$SQLData?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeObject_java$sql$SQLData__V(jobj)(a0?.jobj ?? nil)
    }

    func writeRef(a0: java$sql$Ref?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeRef_java$sql$Ref__V(jobj)(a0?.jobj ?? nil)
    }

    func writeBlob(a0: java$sql$Blob?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeBlob_java$sql$Blob__V(jobj)(a0?.jobj ?? nil)
    }

    func writeClob(a0: java$sql$Clob?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeClob_java$sql$Clob__V(jobj)(a0?.jobj ?? nil)
    }

    func writeStruct(a0: java$sql$Struct?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeStruct_java$sql$Struct__V(jobj)(a0?.jobj ?? nil)
    }

    func writeArray(a0: java$sql$Array?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeArray_java$sql$Array__V(jobj)(a0?.jobj ?? nil)
    }

    func writeURL(a0: java$net$URL?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeURL_java$net$URL__V(jobj)(a0?.jobj ?? nil)
    }

    func writeNString(a0: java$lang$String?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeNString_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func writeNClob(a0: java$sql$NClob?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeNClob_java$sql$NClob__V(jobj)(a0?.jobj ?? nil)
    }

    func writeRowId(a0: java$sql$RowId?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeRowId_java$sql$RowId__V(jobj)(a0?.jobj ?? nil)
    }

    func writeSQLXML(a0: java$sql$SQLXML?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeSQLXML_java$sql$SQLXML__V(jobj)(a0?.jobj ?? nil)
    }

    func writeObject(a0: java$lang$Object?, _ a1: java$sql$SQLType?) throws -> Void {
        return try java$sql$SQLOutput$.java$sql$SQLOutput_writeObject_java$lang$Object_java$sql$SQLType__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public class java$sql$SQLWarning : java$sql$SQLException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLWarning_init_java$lang$String_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String_java$lang$String_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init__V()
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$String_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_init_java$lang$String_java$lang$String_I_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint, _ a3: java$lang$Throwable?) throws {
        let jobj = try java$sql$SQLWarning$.java$sql$SQLWarning_init_java$lang$String_java$lang$String_I_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$sql$SQLWarning_getNextWarning__java$sql$SQLWarning = invoker("getNextWarning", returns: JObjectType("java/sql/SQLWarning"))
    public func getNextWarning() throws -> java$sql$SQLWarning? {
        return try java$sql$SQLWarning$(jobj: java$sql$SQLWarning$.java$sql$SQLWarning_getNextWarning__java$sql$SQLWarning(jobj)())
    }

    private static let java$sql$SQLWarning_setNextWarning_java$sql$SQLWarning__V = invoker("setNextWarning", returns: JVoid.jniType, arguments: (JObjectType("java/sql/SQLWarning")))
    public func setNextWarning(a0: java$sql$SQLWarning?) throws -> Void {
        return try java$sql$SQLWarning$.java$sql$SQLWarning_setNextWarning_java$sql$SQLWarning__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$sql$SQLWarning$ = java$sql$SQLWarning

public protocol java$sql$SQLXML : JavaObject {
    func free() throws -> Void
    func getBinaryStream() throws -> java$io$InputStream?
    func setBinaryStream() throws -> java$io$OutputStream?
    func getCharacterStream() throws -> java$io$Reader?
    func setCharacterStream() throws -> java$io$Writer?
    func getString() throws -> java$lang$String?
    func setString(a0: java$lang$String?) throws -> Void
    func getSource(a0: java$lang$Class?) throws -> javax$xml$transform$Source?
    func setResult(a0: java$lang$Class?) throws -> javax$xml$transform$Result?
}

public class java$sql$SQLXML$ : java$lang$Object$, java$sql$SQLXML {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$SQLXML_free__V = invoker("free", returns: JVoid.jniType)
    private static let java$sql$SQLXML_getBinaryStream__java$io$InputStream = invoker("getBinaryStream", returns: JObjectType("java/io/InputStream"))
    private static let java$sql$SQLXML_setBinaryStream__java$io$OutputStream = invoker("setBinaryStream", returns: JObjectType("java/io/OutputStream"))
    private static let java$sql$SQLXML_getCharacterStream__java$io$Reader = invoker("getCharacterStream", returns: JObjectType("java/io/Reader"))
    private static let java$sql$SQLXML_setCharacterStream__java$io$Writer = invoker("setCharacterStream", returns: JObjectType("java/io/Writer"))
    private static let java$sql$SQLXML_getString__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"))
    private static let java$sql$SQLXML_setString_java$lang$String__V = invoker("setString", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$SQLXML_getSource_java$lang$Class__javax$xml$transform$Source = invoker("getSource", returns: JObjectType("javax/xml/transform/Source"), arguments: (JObjectType("java/lang/Class")))
    private static let java$sql$SQLXML_setResult_java$lang$Class__javax$xml$transform$Result = invoker("setResult", returns: JObjectType("javax/xml/transform/Result"), arguments: (JObjectType("java/lang/Class")))
}

public extension java$sql$SQLXML {
    func free() throws -> Void {
        return try java$sql$SQLXML$.java$sql$SQLXML_free__V(jobj)()
    }

    func getBinaryStream() throws -> java$io$InputStream? {
        return try java$io$InputStream$(jobj: java$sql$SQLXML$.java$sql$SQLXML_getBinaryStream__java$io$InputStream(jobj)())
    }

    func setBinaryStream() throws -> java$io$OutputStream? {
        return try java$io$OutputStream$(jobj: java$sql$SQLXML$.java$sql$SQLXML_setBinaryStream__java$io$OutputStream(jobj)())
    }

    func getCharacterStream() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: java$sql$SQLXML$.java$sql$SQLXML_getCharacterStream__java$io$Reader(jobj)())
    }

    func setCharacterStream() throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: java$sql$SQLXML$.java$sql$SQLXML_setCharacterStream__java$io$Writer(jobj)())
    }

    func getString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$SQLXML$.java$sql$SQLXML_getString__java$lang$String(jobj)())
    }

    func setString(a0: java$lang$String?) throws -> Void {
        return try java$sql$SQLXML$.java$sql$SQLXML_setString_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func getSource(a0: java$lang$Class?) throws -> javax$xml$transform$Source? {
        return try javax$xml$transform$Source$(jobj: java$sql$SQLXML$.java$sql$SQLXML_getSource_java$lang$Class__javax$xml$transform$Source(jobj)(a0?.jobj ?? nil))
    }

    func setResult(a0: java$lang$Class?) throws -> javax$xml$transform$Result? {
        return try javax$xml$transform$Result$(jobj: java$sql$SQLXML$.java$sql$SQLXML_setResult_java$lang$Class__javax$xml$transform$Result(jobj)(a0?.jobj ?? nil))
    }

}

public protocol java$sql$Savepoint : JavaObject {
    func getSavepointId() throws -> jint
    func getSavepointName() throws -> java$lang$String?
}

public class java$sql$Savepoint$ : java$lang$Object$, java$sql$Savepoint {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Savepoint_getSavepointId__I = invoker("getSavepointId", returns: jint.jniType)
    private static let java$sql$Savepoint_getSavepointName__java$lang$String = invoker("getSavepointName", returns: JObjectType("java/lang/String"))
}

public extension java$sql$Savepoint {
    func getSavepointId() throws -> jint {
        return try java$sql$Savepoint$.java$sql$Savepoint_getSavepointId__I(jobj)()
    }

    func getSavepointName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Savepoint$.java$sql$Savepoint_getSavepointName__java$lang$String(jobj)())
    }

}

public protocol java$sql$Statement : java$sql$Wrapper, java$lang$AutoCloseable {
    func executeQuery(a0: java$lang$String?) throws -> java$sql$ResultSet?
    func executeUpdate(a0: java$lang$String?) throws -> jint
    func close() throws -> Void
    func getMaxFieldSize() throws -> jint
    func setMaxFieldSize(a0: jint) throws -> Void
    func getMaxRows() throws -> jint
    func setMaxRows(a0: jint) throws -> Void
    func setEscapeProcessing(a0: jboolean) throws -> Void
    func getQueryTimeout() throws -> jint
    func setQueryTimeout(a0: jint) throws -> Void
    func cancel() throws -> Void
    func getWarnings() throws -> java$sql$SQLWarning?
    func clearWarnings() throws -> Void
    func setCursorName(a0: java$lang$String?) throws -> Void
    func execute(a0: java$lang$String?) throws -> jboolean
    func getResultSet() throws -> java$sql$ResultSet?
    func getUpdateCount() throws -> jint
    func getMoreResults() throws -> jboolean
    func setFetchDirection(a0: jint) throws -> Void
    func getFetchDirection() throws -> jint
    func setFetchSize(a0: jint) throws -> Void
    func getFetchSize() throws -> jint
    func getResultSetConcurrency() throws -> jint
    func getResultSetType() throws -> jint
    func addBatch(a0: java$lang$String?) throws -> Void
    func clearBatch() throws -> Void
    func executeBatch() throws -> [jint]?
    func getConnection() throws -> java$sql$Connection?
    func getMoreResults(a0: jint) throws -> jboolean
    func getGeneratedKeys() throws -> java$sql$ResultSet?
    func executeUpdate(a0: java$lang$String?, _ a1: jint) throws -> jint
    func executeUpdate(a0: java$lang$String?, _ a1: [jint]?) throws -> jint
    func executeUpdate(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jint
    func execute(a0: java$lang$String?, _ a1: jint) throws -> jboolean
    func execute(a0: java$lang$String?, _ a1: [jint]?) throws -> jboolean
    func execute(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jboolean
    func getResultSetHoldability() throws -> jint
    func isClosed() throws -> jboolean
    func setPoolable(a0: jboolean) throws -> Void
    func isPoolable() throws -> jboolean
    func closeOnCompletion() throws -> Void
    func isCloseOnCompletion() throws -> jboolean
    func getLargeUpdateCount() throws -> jlong
    func setLargeMaxRows(a0: jlong) throws -> Void
    func getLargeMaxRows() throws -> jlong
    func executeLargeBatch() throws -> [jlong]?
    func executeLargeUpdate(a0: java$lang$String?) throws -> jlong
    func executeLargeUpdate(a0: java$lang$String?, _ a1: jint) throws -> jlong
    func executeLargeUpdate(a0: java$lang$String?, _ a1: [jint]?) throws -> jlong
    func executeLargeUpdate(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jlong
}

public class java$sql$Statement$ : java$lang$Object$, java$sql$Statement, java$sql$Wrapper, java$lang$AutoCloseable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Statement_executeQuery_java$lang$String__java$sql$ResultSet = invoker("executeQuery", returns: JObjectType("java/sql/ResultSet"), arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_executeUpdate_java$lang$String__I = invoker("executeUpdate", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_close__V = invoker("close", returns: JVoid.jniType)
    private static let java$sql$Statement_getMaxFieldSize__I = invoker("getMaxFieldSize", returns: jint.jniType)
    private static let java$sql$Statement_setMaxFieldSize_I__V = invoker("setMaxFieldSize", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_getMaxRows__I = invoker("getMaxRows", returns: jint.jniType)
    private static let java$sql$Statement_setMaxRows_I__V = invoker("setMaxRows", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_setEscapeProcessing_Z__V = invoker("setEscapeProcessing", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$sql$Statement_getQueryTimeout__I = invoker("getQueryTimeout", returns: jint.jniType)
    private static let java$sql$Statement_setQueryTimeout_I__V = invoker("setQueryTimeout", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_cancel__V = invoker("cancel", returns: JVoid.jniType)
    private static let java$sql$Statement_getWarnings__java$sql$SQLWarning = invoker("getWarnings", returns: JObjectType("java/sql/SQLWarning"))
    private static let java$sql$Statement_clearWarnings__V = invoker("clearWarnings", returns: JVoid.jniType)
    private static let java$sql$Statement_setCursorName_java$lang$String__V = invoker("setCursorName", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_execute_java$lang$String__Z = invoker("execute", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_getResultSet__java$sql$ResultSet = invoker("getResultSet", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$Statement_getUpdateCount__I = invoker("getUpdateCount", returns: jint.jniType)
    private static let java$sql$Statement_getMoreResults__Z = invoker("getMoreResults", returns: jboolean.jniType)
    private static let java$sql$Statement_setFetchDirection_I__V = invoker("setFetchDirection", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_getFetchDirection__I = invoker("getFetchDirection", returns: jint.jniType)
    private static let java$sql$Statement_setFetchSize_I__V = invoker("setFetchSize", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_getFetchSize__I = invoker("getFetchSize", returns: jint.jniType)
    private static let java$sql$Statement_getResultSetConcurrency__I = invoker("getResultSetConcurrency", returns: jint.jniType)
    private static let java$sql$Statement_getResultSetType__I = invoker("getResultSetType", returns: jint.jniType)
    private static let java$sql$Statement_addBatch_java$lang$String__V = invoker("addBatch", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_clearBatch__V = invoker("clearBatch", returns: JVoid.jniType)
    private static let java$sql$Statement_executeBatch__AI = invoker("executeBatch", returns: JArray(jint.jniType))
    private static let java$sql$Statement_getConnection__java$sql$Connection = invoker("getConnection", returns: JObjectType("java/sql/Connection"))
    private static let java$sql$Statement_getMoreResults_I__Z = invoker("getMoreResults", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$sql$Statement_getGeneratedKeys__java$sql$ResultSet = invoker("getGeneratedKeys", returns: JObjectType("java/sql/ResultSet"))
    private static let java$sql$Statement_executeUpdate_java$lang$String_I__I = invoker("executeUpdate", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$Statement_executeUpdate_java$lang$String_AI__I = invoker("executeUpdate", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), JArray(jint.jniType)))
    private static let java$sql$Statement_executeUpdate_java$lang$String_Ajava$lang$String__I = invoker("executeUpdate", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    private static let java$sql$Statement_execute_java$lang$String_I__Z = invoker("execute", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$Statement_execute_java$lang$String_AI__Z = invoker("execute", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), JArray(jint.jniType)))
    private static let java$sql$Statement_execute_java$lang$String_Ajava$lang$String__Z = invoker("execute", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    private static let java$sql$Statement_getResultSetHoldability__I = invoker("getResultSetHoldability", returns: jint.jniType)
    private static let java$sql$Statement_isClosed__Z = invoker("isClosed", returns: jboolean.jniType)
    private static let java$sql$Statement_setPoolable_Z__V = invoker("setPoolable", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$sql$Statement_isPoolable__Z = invoker("isPoolable", returns: jboolean.jniType)
    private static let java$sql$Statement_closeOnCompletion__V = invoker("closeOnCompletion", returns: JVoid.jniType)
    private static let java$sql$Statement_isCloseOnCompletion__Z = invoker("isCloseOnCompletion", returns: jboolean.jniType)
    private static let java$sql$Statement_getLargeUpdateCount__J = invoker("getLargeUpdateCount", returns: jlong.jniType)
    private static let java$sql$Statement_setLargeMaxRows_J__V = invoker("setLargeMaxRows", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Statement_getLargeMaxRows__J = invoker("getLargeMaxRows", returns: jlong.jniType)
    private static let java$sql$Statement_executeLargeBatch__AJ = invoker("executeLargeBatch", returns: JArray(jlong.jniType))
    private static let java$sql$Statement_executeLargeUpdate_java$lang$String__J = invoker("executeLargeUpdate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    private static let java$sql$Statement_executeLargeUpdate_java$lang$String_I__J = invoker("executeLargeUpdate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let java$sql$Statement_executeLargeUpdate_java$lang$String_AI__J = invoker("executeLargeUpdate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), JArray(jint.jniType)))
    private static let java$sql$Statement_executeLargeUpdate_java$lang$String_Ajava$lang$String__J = invoker("executeLargeUpdate", returns: jlong.jniType, arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
}

public extension java$sql$Statement {
    func executeQuery(a0: java$lang$String?) throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Statement$.java$sql$Statement_executeQuery_java$lang$String__java$sql$ResultSet(jobj)(a0?.jobj ?? nil))
    }

    func executeUpdate(a0: java$lang$String?) throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_executeUpdate_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    func close() throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_close__V(jobj)()
    }

    func getMaxFieldSize() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getMaxFieldSize__I(jobj)()
    }

    func setMaxFieldSize(a0: jint) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setMaxFieldSize_I__V(jobj)(a0)
    }

    func getMaxRows() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getMaxRows__I(jobj)()
    }

    func setMaxRows(a0: jint) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setMaxRows_I__V(jobj)(a0)
    }

    func setEscapeProcessing(a0: jboolean) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setEscapeProcessing_Z__V(jobj)(a0)
    }

    func getQueryTimeout() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getQueryTimeout__I(jobj)()
    }

    func setQueryTimeout(a0: jint) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setQueryTimeout_I__V(jobj)(a0)
    }

    func cancel() throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_cancel__V(jobj)()
    }

    func getWarnings() throws -> java$sql$SQLWarning? {
        return try java$sql$SQLWarning$(jobj: java$sql$Statement$.java$sql$Statement_getWarnings__java$sql$SQLWarning(jobj)())
    }

    func clearWarnings() throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_clearWarnings__V(jobj)()
    }

    func setCursorName(a0: java$lang$String?) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setCursorName_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func execute(a0: java$lang$String?) throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_execute_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    func getResultSet() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Statement$.java$sql$Statement_getResultSet__java$sql$ResultSet(jobj)())
    }

    func getUpdateCount() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getUpdateCount__I(jobj)()
    }

    func getMoreResults() throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_getMoreResults__Z(jobj)()
    }

    func setFetchDirection(a0: jint) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setFetchDirection_I__V(jobj)(a0)
    }

    func getFetchDirection() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getFetchDirection__I(jobj)()
    }

    func setFetchSize(a0: jint) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setFetchSize_I__V(jobj)(a0)
    }

    func getFetchSize() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getFetchSize__I(jobj)()
    }

    func getResultSetConcurrency() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getResultSetConcurrency__I(jobj)()
    }

    func getResultSetType() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getResultSetType__I(jobj)()
    }

    func addBatch(a0: java$lang$String?) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_addBatch_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    func clearBatch() throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_clearBatch__V(jobj)()
    }

    func executeBatch() throws -> [jint]? {
        return try java$sql$Statement$.java$sql$Statement_executeBatch__AI(jobj)().jarrayToArray()
    }

    func getConnection() throws -> java$sql$Connection? {
        return try java$sql$Connection$(jobj: java$sql$Statement$.java$sql$Statement_getConnection__java$sql$Connection(jobj)())
    }

    func getMoreResults(a0: jint) throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_getMoreResults_I__Z(jobj)(a0)
    }

    func getGeneratedKeys() throws -> java$sql$ResultSet? {
        return try java$sql$ResultSet$(jobj: java$sql$Statement$.java$sql$Statement_getGeneratedKeys__java$sql$ResultSet(jobj)())
    }

    func executeUpdate(a0: java$lang$String?, _ a1: jint) throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_executeUpdate_java$lang$String_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    func executeUpdate(a0: java$lang$String?, _ a1: [jint]?) throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_executeUpdate_java$lang$String_AI__I(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
    }

    func executeUpdate(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_executeUpdate_java$lang$String_Ajava$lang$String__I(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    func execute(a0: java$lang$String?, _ a1: jint) throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_execute_java$lang$String_I__Z(jobj)(a0?.jobj ?? nil, a1)
    }

    func execute(a0: java$lang$String?, _ a1: [jint]?) throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_execute_java$lang$String_AI__Z(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
    }

    func execute(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_execute_java$lang$String_Ajava$lang$String__Z(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    func getResultSetHoldability() throws -> jint {
        return try java$sql$Statement$.java$sql$Statement_getResultSetHoldability__I(jobj)()
    }

    func isClosed() throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_isClosed__Z(jobj)()
    }

    func setPoolable(a0: jboolean) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setPoolable_Z__V(jobj)(a0)
    }

    func isPoolable() throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_isPoolable__Z(jobj)()
    }

    func closeOnCompletion() throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_closeOnCompletion__V(jobj)()
    }

    func isCloseOnCompletion() throws -> jboolean {
        return try java$sql$Statement$.java$sql$Statement_isCloseOnCompletion__Z(jobj)()
    }

    func getLargeUpdateCount() throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_getLargeUpdateCount__J(jobj)()
    }

    func setLargeMaxRows(a0: jlong) throws -> Void {
        return try java$sql$Statement$.java$sql$Statement_setLargeMaxRows_J__V(jobj)(a0)
    }

    func getLargeMaxRows() throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_getLargeMaxRows__J(jobj)()
    }

    func executeLargeBatch() throws -> [jlong]? {
        return try java$sql$Statement$.java$sql$Statement_executeLargeBatch__AJ(jobj)().jarrayToArray()
    }

    func executeLargeUpdate(a0: java$lang$String?) throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_executeLargeUpdate_java$lang$String__J(jobj)(a0?.jobj ?? nil)
    }

    func executeLargeUpdate(a0: java$lang$String?, _ a1: jint) throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_executeLargeUpdate_java$lang$String_I__J(jobj)(a0?.jobj ?? nil, a1)
    }

    func executeLargeUpdate(a0: java$lang$String?, _ a1: [jint]?) throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_executeLargeUpdate_java$lang$String_AI__J(jobj)(a0?.jobj ?? nil, a1?.arrayToJArray() ?? nil)
    }

    func executeLargeUpdate(a0: java$lang$String?, _ a1: [java$lang$String?]?) throws -> jlong {
        return try java$sql$Statement$.java$sql$Statement_executeLargeUpdate_java$lang$String_Ajava$lang$String__J(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

}

public protocol java$sql$Struct : JavaObject {
    func getSQLTypeName() throws -> java$lang$String?
    func getAttributes() throws -> [java$lang$Object?]?
    func getAttributes(a0: java$util$Map?) throws -> [java$lang$Object?]?
}

public class java$sql$Struct$ : java$lang$Object$, java$sql$Struct {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Struct_getSQLTypeName__java$lang$String = invoker("getSQLTypeName", returns: JObjectType("java/lang/String"))
    private static let java$sql$Struct_getAttributes__Ajava$lang$Object = invoker("getAttributes", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$sql$Struct_getAttributes_java$util$Map__Ajava$lang$Object = invoker("getAttributes", returns: JArray(JObjectType("java/lang/Object")), arguments: (JObjectType("java/util/Map")))
}

public extension java$sql$Struct {
    func getSQLTypeName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$sql$Struct$.java$sql$Struct_getSQLTypeName__java$lang$String(jobj)())
    }

    func getAttributes() throws -> [java$lang$Object?]? {
        return try java$sql$Struct$.java$sql$Struct_getAttributes__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func getAttributes(a0: java$util$Map?) throws -> [java$lang$Object?]? {
        return try java$sql$Struct$.java$sql$Struct_getAttributes_java$util$Map__Ajava$lang$Object(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

}

public class java$sql$Time : java$util$Date$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Time_init_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$sql$Time$.java$sql$Time_init_I_I_I__V(a0, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$sql$Time_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$sql$Time$.java$sql$Time_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$sql$Time_setTime_J__V = invoker("setTime", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Time_valueOf_java$lang$String__java$sql$Time = svoker("valueOf", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$Time$.java$sql$Time_valueOf_java$lang$String__java$sql$Time(a0?.jobj ?? nil))
    }

    private static let java$sql$Time_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$sql$Time_getYear__I = invoker("getYear", returns: jint.jniType)
    private static let java$sql$Time_getMonth__I = invoker("getMonth", returns: jint.jniType)
    private static let java$sql$Time_getDay__I = invoker("getDay", returns: jint.jniType)
    private static let java$sql$Time_getDate__I = invoker("getDate", returns: jint.jniType)
    private static let java$sql$Time_setYear_I__V = invoker("setYear", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Time_setMonth_I__V = invoker("setMonth", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Time_setDate_I__V = invoker("setDate", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$sql$Time_valueOf_java$time$LocalTime__java$sql$Time = svoker("valueOf", returns: JObjectType("java/sql/Time"), arguments: (JObjectType("java/time/LocalTime")))
    public static func valueOf(a0: java$time$LocalTime?) throws -> java$sql$Time? {
        return try java$sql$Time$(jobj: java$sql$Time$.java$sql$Time_valueOf_java$time$LocalTime__java$sql$Time(a0?.jobj ?? nil))
    }

    private static let java$sql$Time_toLocalTime__java$time$LocalTime = invoker("toLocalTime", returns: JObjectType("java/time/LocalTime"))
    public func toLocalTime() throws -> java$time$LocalTime? {
        return try java$time$LocalTime$(jobj: java$sql$Time$.java$sql$Time_toLocalTime__java$time$LocalTime(jobj)())
    }

    private static let java$sql$Time_toInstant__java$time$Instant = invoker("toInstant", returns: JObjectType("java/time/Instant"))
}

public typealias java$sql$Time$ = java$sql$Time

public class java$sql$Timestamp : java$util$Date$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Timestamp_init_I_I_I_I_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint, _ a6: jint) throws {
        let jobj = try java$sql$Timestamp$.java$sql$Timestamp_init_I_I_I_I_I_I_I__V(a0, a1, a2, a3, a4, a5, a6)
        self.init(jobj: jobj)
    }

    private static let java$sql$Timestamp_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$sql$Timestamp$.java$sql$Timestamp_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$sql$Timestamp_setTime_J__V = invoker("setTime", returns: JVoid.jniType, arguments: (jlong.jniType))
    private static let java$sql$Timestamp_getTime__J = invoker("getTime", returns: jlong.jniType)
    private static let java$sql$Timestamp_valueOf_java$lang$String__java$sql$Timestamp = svoker("valueOf", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/lang/String")))
    public static func valueOf(a0: java$lang$String?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$Timestamp$.java$sql$Timestamp_valueOf_java$lang$String__java$sql$Timestamp(a0?.jobj ?? nil))
    }

    private static let java$sql$Timestamp_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$sql$Timestamp_getNanos__I = invoker("getNanos", returns: jint.jniType)
    public func getNanos() throws -> jint {
        return try java$sql$Timestamp$.java$sql$Timestamp_getNanos__I(jobj)()
    }

    private static let java$sql$Timestamp_setNanos_I__V = invoker("setNanos", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setNanos(a0: jint) throws -> Void {
        return try java$sql$Timestamp$.java$sql$Timestamp_setNanos_I__V(jobj)(a0)
    }

    private static let java$sql$Timestamp_equals_java$sql$Timestamp__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/sql/Timestamp")))
    public func equals(a0: java$sql$Timestamp?) throws -> jboolean {
        return try java$sql$Timestamp$.java$sql$Timestamp_equals_java$sql$Timestamp__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$sql$Timestamp_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$sql$Timestamp_before_java$sql$Timestamp__Z = invoker("before", returns: jboolean.jniType, arguments: (JObjectType("java/sql/Timestamp")))
    public func before(a0: java$sql$Timestamp?) throws -> jboolean {
        return try java$sql$Timestamp$.java$sql$Timestamp_before_java$sql$Timestamp__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$sql$Timestamp_after_java$sql$Timestamp__Z = invoker("after", returns: jboolean.jniType, arguments: (JObjectType("java/sql/Timestamp")))
    public func after(a0: java$sql$Timestamp?) throws -> jboolean {
        return try java$sql$Timestamp$.java$sql$Timestamp_after_java$sql$Timestamp__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$sql$Timestamp_compareTo_java$sql$Timestamp__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/sql/Timestamp")))
    public func compareTo(a0: java$sql$Timestamp?) throws -> jint {
        return try java$sql$Timestamp$.java$sql$Timestamp_compareTo_java$sql$Timestamp__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$sql$Timestamp_compareTo_java$util$Date__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/util/Date")))
    private static let java$sql$Timestamp_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$sql$Timestamp_valueOf_java$time$LocalDateTime__java$sql$Timestamp = svoker("valueOf", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/time/LocalDateTime")))
    public static func valueOf(a0: java$time$LocalDateTime?) throws -> java$sql$Timestamp? {
        return try java$sql$Timestamp$(jobj: java$sql$Timestamp$.java$sql$Timestamp_valueOf_java$time$LocalDateTime__java$sql$Timestamp(a0?.jobj ?? nil))
    }

    private static let java$sql$Timestamp_toLocalDateTime__java$time$LocalDateTime = invoker("toLocalDateTime", returns: JObjectType("java/time/LocalDateTime"))
    public func toLocalDateTime() throws -> java$time$LocalDateTime? {
        return try java$time$LocalDateTime$(jobj: java$sql$Timestamp$.java$sql$Timestamp_toLocalDateTime__java$time$LocalDateTime(jobj)())
    }

    private static let java$sql$Timestamp_from_java$time$Instant__java$sql$Timestamp = svoker("from", returns: JObjectType("java/sql/Timestamp"), arguments: (JObjectType("java/time/Instant")))
    private static let java$sql$Timestamp_toInstant__java$time$Instant = invoker("toInstant", returns: JObjectType("java/time/Instant"))
    private static let java$sql$Timestamp_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$sql$Timestamp$ = java$sql$Timestamp

public class java$sql$Types : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$sql$Types$ = java$sql$Types

public protocol java$sql$Wrapper : JavaObject {
    func unwrap(a0: java$lang$Class?) throws -> java$lang$Object?
    func isWrapperFor(a0: java$lang$Class?) throws -> jboolean
}

public class java$sql$Wrapper$ : java$lang$Object$, java$sql$Wrapper {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$sql$Wrapper_unwrap_java$lang$Class__java$lang$Object = invoker("unwrap", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class")))
    private static let java$sql$Wrapper_isWrapperFor_java$lang$Class__Z = invoker("isWrapperFor", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Class")))
}

public extension java$sql$Wrapper {
    func unwrap(a0: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$sql$Wrapper$.java$sql$Wrapper_unwrap_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func isWrapperFor(a0: java$lang$Class?) throws -> jboolean {
        return try java$sql$Wrapper$.java$sql$Wrapper_isWrapperFor_java$lang$Class__Z(jobj)(a0?.jobj ?? nil)
    }

}

public class java$text$Annotation : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$Annotation_init_java$lang$Object__V = constructor((JObjectType("java/lang/Object")))
    public convenience init!(_ a0: java$lang$Object?) throws {
        let jobj = try java$text$Annotation$.java$text$Annotation_init_java$lang$Object__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$Annotation_getValue__java$lang$Object = invoker("getValue", returns: JObjectType("java/lang/Object"))
    public func getValue() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$Annotation$.java$text$Annotation_getValue__java$lang$Object(jobj)())
    }

    private static let java$text$Annotation_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$Annotation$ = java$text$Annotation

public class java$text$AttributeEntry : java$lang$Object$, java$util$Map$Entry {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$AttributeEntry_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$AttributeEntry_getKey__java$text$AttributedCharacterIterator$Attribute = invoker("getKey", returns: JObjectType("java/text/AttributedCharacterIterator$Attribute"))
    public func getKey() throws -> java$text$AttributedCharacterIterator$Attribute? {
        return try java$text$AttributedCharacterIterator$Attribute$(jobj: java$text$AttributeEntry$.java$text$AttributeEntry_getKey__java$text$AttributedCharacterIterator$Attribute(jobj)())
    }

    private static let java$text$AttributeEntry_getValue__java$lang$Object = invoker("getValue", returns: JObjectType("java/lang/Object"))
    public func getValue() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$AttributeEntry$.java$text$AttributeEntry_getValue__java$lang$Object(jobj)())
    }

    private static let java$text$AttributeEntry_setValue_java$lang$Object__java$lang$Object = invoker("setValue", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func setValue(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$AttributeEntry$.java$text$AttributeEntry_setValue_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$AttributeEntry_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$AttributeEntry_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$text$AttributeEntry_getKey__java$lang$Object = invoker("getKey", returns: JObjectType("java/lang/Object"))
    public func getKey() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$AttributeEntry$.java$text$AttributeEntry_getKey__java$lang$Object(jobj)())
    }

}

public typealias java$text$AttributeEntry$ = java$text$AttributeEntry

public protocol java$text$AttributedCharacterIterator : java$text$CharacterIterator {
    func getRunStart() throws -> jint
    func getRunStart(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> jint
    func getRunStart(a0: java$util$Set?) throws -> jint
    func getRunLimit() throws -> jint
    func getRunLimit(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> jint
    func getRunLimit(a0: java$util$Set?) throws -> jint
    func getAttributes() throws -> java$util$Map?
    func getAttribute(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> java$lang$Object?
    func getAllAttributeKeys() throws -> java$util$Set?
}

public class java$text$AttributedCharacterIterator$ : java$lang$Object$, java$text$AttributedCharacterIterator, java$text$CharacterIterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$AttributedCharacterIterator_getRunStart__I = invoker("getRunStart", returns: jint.jniType)
    private static let java$text$AttributedCharacterIterator_getRunStart_java$text$AttributedCharacterIterator$Attribute__I = invoker("getRunStart", returns: jint.jniType, arguments: (JObjectType("java/text/AttributedCharacterIterator$Attribute")))
    private static let java$text$AttributedCharacterIterator_getRunStart_java$util$Set__I = invoker("getRunStart", returns: jint.jniType, arguments: (JObjectType("java/util/Set")))
    private static let java$text$AttributedCharacterIterator_getRunLimit__I = invoker("getRunLimit", returns: jint.jniType)
    private static let java$text$AttributedCharacterIterator_getRunLimit_java$text$AttributedCharacterIterator$Attribute__I = invoker("getRunLimit", returns: jint.jniType, arguments: (JObjectType("java/text/AttributedCharacterIterator$Attribute")))
    private static let java$text$AttributedCharacterIterator_getRunLimit_java$util$Set__I = invoker("getRunLimit", returns: jint.jniType, arguments: (JObjectType("java/util/Set")))
    private static let java$text$AttributedCharacterIterator_getAttributes__java$util$Map = invoker("getAttributes", returns: JObjectType("java/util/Map"))
    private static let java$text$AttributedCharacterIterator_getAttribute_java$text$AttributedCharacterIterator$Attribute__java$lang$Object = invoker("getAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/text/AttributedCharacterIterator$Attribute")))
    private static let java$text$AttributedCharacterIterator_getAllAttributeKeys__java$util$Set = invoker("getAllAttributeKeys", returns: JObjectType("java/util/Set"))
}

public extension java$text$AttributedCharacterIterator {
    func getRunStart() throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunStart__I(jobj)()
    }

    func getRunStart(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunStart_java$text$AttributedCharacterIterator$Attribute__I(jobj)(a0?.jobj ?? nil)
    }

    func getRunStart(a0: java$util$Set?) throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunStart_java$util$Set__I(jobj)(a0?.jobj ?? nil)
    }

    func getRunLimit() throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunLimit__I(jobj)()
    }

    func getRunLimit(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunLimit_java$text$AttributedCharacterIterator$Attribute__I(jobj)(a0?.jobj ?? nil)
    }

    func getRunLimit(a0: java$util$Set?) throws -> jint {
        return try java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getRunLimit_java$util$Set__I(jobj)(a0?.jobj ?? nil)
    }

    func getAttributes() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getAttributes__java$util$Map(jobj)())
    }

    func getAttribute(a0: java$text$AttributedCharacterIterator$Attribute?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getAttribute_java$text$AttributedCharacterIterator$Attribute__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getAllAttributeKeys() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$text$AttributedCharacterIterator$.java$text$AttributedCharacterIterator_getAllAttributeKeys__java$util$Set(jobj)())
    }

}

public class java$text$AttributedString : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$AttributedString_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$AttributedString$.java$text$AttributedString_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$AttributedString_init_java$lang$String_java$util$Map__V = constructor((JObjectType("java/lang/String"), JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$util$Map?) throws {
        let jobj = try java$text$AttributedString$.java$text$AttributedString_init_java$lang$String_java$util$Map__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$AttributedString_init_java$text$AttributedCharacterIterator__V = constructor((JObjectType("java/text/AttributedCharacterIterator")))
    public convenience init!(_ a0: java$text$AttributedCharacterIterator?) throws {
        let jobj = try java$text$AttributedString$.java$text$AttributedString_init_java$text$AttributedCharacterIterator__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$AttributedString_init_java$text$AttributedCharacterIterator_I_I__V = constructor((JObjectType("java/text/AttributedCharacterIterator"), jint.jniType, jint.jniType))
    public convenience init!(_ a0: java$text$AttributedCharacterIterator?, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$text$AttributedString$.java$text$AttributedString_init_java$text$AttributedCharacterIterator_I_I__V(a0?.jobj ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$text$AttributedString_init_java$text$AttributedCharacterIterator_I_I_Ajava$text$AttributedCharacterIterator$Attribute__V = constructor((JObjectType("java/text/AttributedCharacterIterator"), jint.jniType, jint.jniType, JArray(JObjectType("java/text/AttributedCharacterIterator$Attribute"))))
    public convenience init!(_ a0: java$text$AttributedCharacterIterator?, _ a1: jint, _ a2: jint, _ a3: [java$text$AttributedCharacterIterator$Attribute?]?) throws {
        let jobj = try java$text$AttributedString$.java$text$AttributedString_init_java$text$AttributedCharacterIterator_I_I_Ajava$text$AttributedCharacterIterator$Attribute__V(a0?.jobj ?? nil, a1, a2, a3?.map({ java$text$AttributedCharacterIterator$Attribute$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$AttributedString_addAttribute_java$text$AttributedCharacterIterator$Attribute_java$lang$Object__V = invoker("addAttribute", returns: JVoid.jniType, arguments: (JObjectType("java/text/AttributedCharacterIterator$Attribute"), JObjectType("java/lang/Object")))
    public func addAttribute(a0: java$text$AttributedCharacterIterator$Attribute?, _ a1: java$lang$Object?) throws -> Void {
        return try java$text$AttributedString$.java$text$AttributedString_addAttribute_java$text$AttributedCharacterIterator$Attribute_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$text$AttributedString_addAttribute_java$text$AttributedCharacterIterator$Attribute_java$lang$Object_I_I__V = invoker("addAttribute", returns: JVoid.jniType, arguments: (JObjectType("java/text/AttributedCharacterIterator$Attribute"), JObjectType("java/lang/Object"), jint.jniType, jint.jniType))
    public func addAttribute(a0: java$text$AttributedCharacterIterator$Attribute?, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$text$AttributedString$.java$text$AttributedString_addAttribute_java$text$AttributedCharacterIterator$Attribute_java$lang$Object_I_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3)
    }

    private static let java$text$AttributedString_addAttributes_java$util$Map_I_I__V = invoker("addAttributes", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map"), jint.jniType, jint.jniType))
    public func addAttributes(a0: java$util$Map?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$text$AttributedString$.java$text$AttributedString_addAttributes_java$util$Map_I_I__V(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$text$AttributedString_getIterator__java$text$AttributedCharacterIterator = invoker("getIterator", returns: JObjectType("java/text/AttributedCharacterIterator"))
    public func getIterator() throws -> java$text$AttributedCharacterIterator? {
        return try java$text$AttributedCharacterIterator$(jobj: java$text$AttributedString$.java$text$AttributedString_getIterator__java$text$AttributedCharacterIterator(jobj)())
    }

    private static let java$text$AttributedString_getIterator_Ajava$text$AttributedCharacterIterator$Attribute__java$text$AttributedCharacterIterator = invoker("getIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JArray(JObjectType("java/text/AttributedCharacterIterator$Attribute"))))
    public func getIterator(a0: [java$text$AttributedCharacterIterator$Attribute?]?) throws -> java$text$AttributedCharacterIterator? {
        return try java$text$AttributedCharacterIterator$(jobj: java$text$AttributedString$.java$text$AttributedString_getIterator_Ajava$text$AttributedCharacterIterator$Attribute__java$text$AttributedCharacterIterator(jobj)(a0?.map({ java$text$AttributedCharacterIterator$Attribute$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$text$AttributedString_getIterator_Ajava$text$AttributedCharacterIterator$Attribute_I_I__java$text$AttributedCharacterIterator = invoker("getIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JArray(JObjectType("java/text/AttributedCharacterIterator$Attribute")), jint.jniType, jint.jniType))
    public func getIterator(a0: [java$text$AttributedCharacterIterator$Attribute?]?, _ a1: jint, _ a2: jint) throws -> java$text$AttributedCharacterIterator? {
        return try java$text$AttributedCharacterIterator$(jobj: java$text$AttributedString$.java$text$AttributedString_getIterator_Ajava$text$AttributedCharacterIterator$Attribute_I_I__java$text$AttributedCharacterIterator(jobj)(a0?.map({ java$text$AttributedCharacterIterator$Attribute$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2))
    }

}

public typealias java$text$AttributedString$ = java$text$AttributedString

public final class java$text$Bidi : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$Bidi_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$text$Bidi$.java$text$Bidi_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$Bidi_init_java$text$AttributedCharacterIterator__V = constructor((JObjectType("java/text/AttributedCharacterIterator")))
    public convenience init!(_ a0: java$text$AttributedCharacterIterator?) throws {
        let jobj = try java$text$Bidi$.java$text$Bidi_init_java$text$AttributedCharacterIterator__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$Bidi_init_AC_I_AB_I_I_I__V = constructor((JArray(jchar.jniType), jint.jniType, JArray(jbyte.jniType), jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: [jchar]?, _ a1: jint, _ a2: [jbyte]?, _ a3: jint, _ a4: jint, _ a5: jint) throws {
        let jobj = try java$text$Bidi$.java$text$Bidi_init_AC_I_AB_I_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2?.arrayToJArray() ?? nil, a3, a4, a5)
        self.init(jobj: jobj)
    }

    private static let java$text$Bidi_createLineBidi_I_I__java$text$Bidi = invoker("createLineBidi", returns: JObjectType("java/text/Bidi"), arguments: (jint.jniType, jint.jniType))
    public func createLineBidi(a0: jint, _ a1: jint) throws -> java$text$Bidi? {
        return try java$text$Bidi$(jobj: java$text$Bidi$.java$text$Bidi_createLineBidi_I_I__java$text$Bidi(jobj)(a0, a1))
    }

    private static let java$text$Bidi_isMixed__Z = invoker("isMixed", returns: jboolean.jniType)
    public func isMixed() throws -> jboolean {
        return try java$text$Bidi$.java$text$Bidi_isMixed__Z(jobj)()
    }

    private static let java$text$Bidi_isLeftToRight__Z = invoker("isLeftToRight", returns: jboolean.jniType)
    public func isLeftToRight() throws -> jboolean {
        return try java$text$Bidi$.java$text$Bidi_isLeftToRight__Z(jobj)()
    }

    private static let java$text$Bidi_isRightToLeft__Z = invoker("isRightToLeft", returns: jboolean.jniType)
    public func isRightToLeft() throws -> jboolean {
        return try java$text$Bidi$.java$text$Bidi_isRightToLeft__Z(jobj)()
    }

    private static let java$text$Bidi_getLength__I = invoker("getLength", returns: jint.jniType)
    public func getLength() throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getLength__I(jobj)()
    }

    private static let java$text$Bidi_baseIsLeftToRight__Z = invoker("baseIsLeftToRight", returns: jboolean.jniType)
    public func baseIsLeftToRight() throws -> jboolean {
        return try java$text$Bidi$.java$text$Bidi_baseIsLeftToRight__Z(jobj)()
    }

    private static let java$text$Bidi_getBaseLevel__I = invoker("getBaseLevel", returns: jint.jniType)
    public func getBaseLevel() throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getBaseLevel__I(jobj)()
    }

    private static let java$text$Bidi_getLevelAt_I__I = invoker("getLevelAt", returns: jint.jniType, arguments: (jint.jniType))
    public func getLevelAt(a0: jint) throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getLevelAt_I__I(jobj)(a0)
    }

    private static let java$text$Bidi_getRunCount__I = invoker("getRunCount", returns: jint.jniType)
    public func getRunCount() throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getRunCount__I(jobj)()
    }

    private static let java$text$Bidi_getRunLevel_I__I = invoker("getRunLevel", returns: jint.jniType, arguments: (jint.jniType))
    public func getRunLevel(a0: jint) throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getRunLevel_I__I(jobj)(a0)
    }

    private static let java$text$Bidi_getRunStart_I__I = invoker("getRunStart", returns: jint.jniType, arguments: (jint.jniType))
    public func getRunStart(a0: jint) throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getRunStart_I__I(jobj)(a0)
    }

    private static let java$text$Bidi_getRunLimit_I__I = invoker("getRunLimit", returns: jint.jniType, arguments: (jint.jniType))
    public func getRunLimit(a0: jint) throws -> jint {
        return try java$text$Bidi$.java$text$Bidi_getRunLimit_I__I(jobj)(a0)
    }

    private static let java$text$Bidi_requiresBidi_AC_I_I__Z = svoker("requiresBidi", returns: jboolean.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func requiresBidi(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> jboolean {
        return try java$text$Bidi$.java$text$Bidi_requiresBidi_AC_I_I__Z(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$text$Bidi_reorderVisually_AB_I_Ajava$lang$Object_I_I__V = svoker("reorderVisually", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType))
    public static func reorderVisually(a0: [jbyte]?, _ a1: jint, _ a2: [java$lang$Object?]?, _ a3: jint, _ a4: jint) throws -> Void {
        return try java$text$Bidi$.java$text$Bidi_reorderVisually_AB_I_Ajava$lang$Object_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a3, a4)
    }

    private static let java$text$Bidi_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$Bidi$ = java$text$Bidi

public class java$text$BreakIterator : java$lang$Object$, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$BreakIterator_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$BreakIterator$.java$text$BreakIterator_clone__java$lang$Object(jobj)())
    }

    private static let java$text$BreakIterator_first__I = invoker("first", returns: jint.jniType)
    public func first() throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_first__I(jobj)()
    }

    private static let java$text$BreakIterator_last__I = invoker("last", returns: jint.jniType)
    public func last() throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_last__I(jobj)()
    }

    private static let java$text$BreakIterator_next_I__I = invoker("next", returns: jint.jniType, arguments: (jint.jniType))
    public func next(a0: jint) throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_next_I__I(jobj)(a0)
    }

    private static let java$text$BreakIterator_next__I = invoker("next", returns: jint.jniType)
    public func next() throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_next__I(jobj)()
    }

    private static let java$text$BreakIterator_previous__I = invoker("previous", returns: jint.jniType)
    public func previous() throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_previous__I(jobj)()
    }

    private static let java$text$BreakIterator_following_I__I = invoker("following", returns: jint.jniType, arguments: (jint.jniType))
    public func following(a0: jint) throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_following_I__I(jobj)(a0)
    }

    private static let java$text$BreakIterator_preceding_I__I = invoker("preceding", returns: jint.jniType, arguments: (jint.jniType))
    public func preceding(a0: jint) throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_preceding_I__I(jobj)(a0)
    }

    private static let java$text$BreakIterator_isBoundary_I__Z = invoker("isBoundary", returns: jboolean.jniType, arguments: (jint.jniType))
    public func isBoundary(a0: jint) throws -> jboolean {
        return try java$text$BreakIterator$.java$text$BreakIterator_isBoundary_I__Z(jobj)(a0)
    }

    private static let java$text$BreakIterator_current__I = invoker("current", returns: jint.jniType)
    public func current() throws -> jint {
        return try java$text$BreakIterator$.java$text$BreakIterator_current__I(jobj)()
    }

    private static let java$text$BreakIterator_getText__java$text$CharacterIterator = invoker("getText", returns: JObjectType("java/text/CharacterIterator"))
    public func getText() throws -> java$text$CharacterIterator? {
        return try java$text$CharacterIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getText__java$text$CharacterIterator(jobj)())
    }

    private static let java$text$BreakIterator_setText_java$lang$String__V = invoker("setText", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setText(a0: java$lang$String?) throws -> Void {
        return try java$text$BreakIterator$.java$text$BreakIterator_setText_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$BreakIterator_setText_java$text$CharacterIterator__V = invoker("setText", returns: JVoid.jniType, arguments: (JObjectType("java/text/CharacterIterator")))
    public func setText(a0: java$text$CharacterIterator?) throws -> Void {
        return try java$text$BreakIterator$.java$text$BreakIterator_setText_java$text$CharacterIterator__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$BreakIterator_getWordInstance__java$text$BreakIterator = svoker("getWordInstance", returns: JObjectType("java/text/BreakIterator"))
    public static func getWordInstance() throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getWordInstance__java$text$BreakIterator())
    }

    private static let java$text$BreakIterator_getWordInstance_java$util$Locale__java$text$BreakIterator = svoker("getWordInstance", returns: JObjectType("java/text/BreakIterator"), arguments: (JObjectType("java/util/Locale")))
    public static func getWordInstance(a0: java$util$Locale?) throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getWordInstance_java$util$Locale__java$text$BreakIterator(a0?.jobj ?? nil))
    }

    private static let java$text$BreakIterator_getLineInstance__java$text$BreakIterator = svoker("getLineInstance", returns: JObjectType("java/text/BreakIterator"))
    public static func getLineInstance() throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getLineInstance__java$text$BreakIterator())
    }

    private static let java$text$BreakIterator_getLineInstance_java$util$Locale__java$text$BreakIterator = svoker("getLineInstance", returns: JObjectType("java/text/BreakIterator"), arguments: (JObjectType("java/util/Locale")))
    public static func getLineInstance(a0: java$util$Locale?) throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getLineInstance_java$util$Locale__java$text$BreakIterator(a0?.jobj ?? nil))
    }

    private static let java$text$BreakIterator_getCharacterInstance__java$text$BreakIterator = svoker("getCharacterInstance", returns: JObjectType("java/text/BreakIterator"))
    public static func getCharacterInstance() throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getCharacterInstance__java$text$BreakIterator())
    }

    private static let java$text$BreakIterator_getCharacterInstance_java$util$Locale__java$text$BreakIterator = svoker("getCharacterInstance", returns: JObjectType("java/text/BreakIterator"), arguments: (JObjectType("java/util/Locale")))
    public static func getCharacterInstance(a0: java$util$Locale?) throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getCharacterInstance_java$util$Locale__java$text$BreakIterator(a0?.jobj ?? nil))
    }

    private static let java$text$BreakIterator_getSentenceInstance__java$text$BreakIterator = svoker("getSentenceInstance", returns: JObjectType("java/text/BreakIterator"))
    public static func getSentenceInstance() throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getSentenceInstance__java$text$BreakIterator())
    }

    private static let java$text$BreakIterator_getSentenceInstance_java$util$Locale__java$text$BreakIterator = svoker("getSentenceInstance", returns: JObjectType("java/text/BreakIterator"), arguments: (JObjectType("java/util/Locale")))
    public static func getSentenceInstance(a0: java$util$Locale?) throws -> java$text$BreakIterator? {
        return try java$text$BreakIterator$(jobj: java$text$BreakIterator$.java$text$BreakIterator_getSentenceInstance_java$util$Locale__java$text$BreakIterator(a0?.jobj ?? nil))
    }

    private static let java$text$BreakIterator_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$BreakIterator$.java$text$BreakIterator_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

}

public typealias java$text$BreakIterator$ = java$text$BreakIterator

public class java$text$CalendarBuilder : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$CalendarBuilder_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$CalendarBuilder$ = java$text$CalendarBuilder

public protocol java$text$CharacterIterator : java$lang$Cloneable {
    func first() throws -> jchar
    func last() throws -> jchar
    func current() throws -> jchar
    func next() throws -> jchar
    func previous() throws -> jchar
    func setIndex(a0: jint) throws -> jchar
    func getBeginIndex() throws -> jint
    func getEndIndex() throws -> jint
    func getIndex() throws -> jint
    func clone() throws -> java$lang$Object?
}

public class java$text$CharacterIterator$ : java$lang$Object$, java$text$CharacterIterator, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$CharacterIterator_first__C = invoker("first", returns: jchar.jniType)
    private static let java$text$CharacterIterator_last__C = invoker("last", returns: jchar.jniType)
    private static let java$text$CharacterIterator_current__C = invoker("current", returns: jchar.jniType)
    private static let java$text$CharacterIterator_next__C = invoker("next", returns: jchar.jniType)
    private static let java$text$CharacterIterator_previous__C = invoker("previous", returns: jchar.jniType)
    private static let java$text$CharacterIterator_setIndex_I__C = invoker("setIndex", returns: jchar.jniType, arguments: (jint.jniType))
    private static let java$text$CharacterIterator_getBeginIndex__I = invoker("getBeginIndex", returns: jint.jniType)
    private static let java$text$CharacterIterator_getEndIndex__I = invoker("getEndIndex", returns: jint.jniType)
    private static let java$text$CharacterIterator_getIndex__I = invoker("getIndex", returns: jint.jniType)
    private static let java$text$CharacterIterator_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
}

public extension java$text$CharacterIterator {
    func first() throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_first__C(jobj)()
    }

    func last() throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_last__C(jobj)()
    }

    func current() throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_current__C(jobj)()
    }

    func next() throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_next__C(jobj)()
    }

    func previous() throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_previous__C(jobj)()
    }

    func setIndex(a0: jint) throws -> jchar {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_setIndex_I__C(jobj)(a0)
    }

    func getBeginIndex() throws -> jint {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_getBeginIndex__I(jobj)()
    }

    func getEndIndex() throws -> jint {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_getEndIndex__I(jobj)()
    }

    func getIndex() throws -> jint {
        return try java$text$CharacterIterator$.java$text$CharacterIterator_getIndex__I(jobj)()
    }

    func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$CharacterIterator$.java$text$CharacterIterator_clone__java$lang$Object(jobj)())
    }

}

public class java$text$CharacterIteratorFieldDelegate : java$lang$Object$, java$text$Format$FieldDelegate {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$CharacterIteratorFieldDelegate_formatted_java$text$Format$Field_java$lang$Object_I_I_java$lang$StringBuffer__V = invoker("formatted", returns: JVoid.jniType, arguments: (JObjectType("java/text/Format$Field"), JObjectType("java/lang/Object"), jint.jniType, jint.jniType, JObjectType("java/lang/StringBuffer")))
    public func formatted(a0: java$text$Format$Field?, _ a1: java$lang$Object?, _ a2: jint, _ a3: jint, _ a4: java$lang$StringBuffer?) throws -> Void {
        return try java$text$CharacterIteratorFieldDelegate$.java$text$CharacterIteratorFieldDelegate_formatted_java$text$Format$Field_java$lang$Object_I_I_java$lang$StringBuffer__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3, a4?.jobj ?? nil)
    }

    private static let java$text$CharacterIteratorFieldDelegate_formatted_I_java$text$Format$Field_java$lang$Object_I_I_java$lang$StringBuffer__V = invoker("formatted", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/text/Format$Field"), JObjectType("java/lang/Object"), jint.jniType, jint.jniType, JObjectType("java/lang/StringBuffer")))
    public func formatted(a0: jint, _ a1: java$text$Format$Field?, _ a2: java$lang$Object?, _ a3: jint, _ a4: jint, _ a5: java$lang$StringBuffer?) throws -> Void {
        return try java$text$CharacterIteratorFieldDelegate$.java$text$CharacterIteratorFieldDelegate_formatted_I_java$text$Format$Field_java$lang$Object_I_I_java$lang$StringBuffer__V(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil, a3, a4, a5?.jobj ?? nil)
    }

    private static let java$text$CharacterIteratorFieldDelegate_getIterator_java$lang$String__java$text$AttributedCharacterIterator = invoker("getIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JObjectType("java/lang/String")))
    public func getIterator(a0: java$lang$String?) throws -> java$text$AttributedCharacterIterator? {
        return try java$text$AttributedCharacterIterator$(jobj: java$text$CharacterIteratorFieldDelegate$.java$text$CharacterIteratorFieldDelegate_getIterator_java$lang$String__java$text$AttributedCharacterIterator(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$text$CharacterIteratorFieldDelegate$ = java$text$CharacterIteratorFieldDelegate

public class java$text$ChoiceFormat : java$text$NumberFormat$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$ChoiceFormat_applyPattern_java$lang$String__V = invoker("applyPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_applyPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$ChoiceFormat_toPattern__java$lang$String = invoker("toPattern", returns: JObjectType("java/lang/String"))
    public func toPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$ChoiceFormat$.java$text$ChoiceFormat_toPattern__java$lang$String(jobj)())
    }

    private static let java$text$ChoiceFormat_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$ChoiceFormat$.java$text$ChoiceFormat_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$ChoiceFormat_init_AD_Ajava$lang$String__V = constructor((JArray(jdouble.jniType), JArray(JObjectType("java/lang/String"))))
    public convenience init!(_ a0: [jdouble]?, _ a1: [java$lang$String?]?) throws {
        let jobj = try java$text$ChoiceFormat$.java$text$ChoiceFormat_init_AD_Ajava$lang$String__V(a0?.arrayToJArray() ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$ChoiceFormat_setChoices_AD_Ajava$lang$String__V = invoker("setChoices", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), JArray(JObjectType("java/lang/String"))))
    public func setChoices(a0: [jdouble]?, _ a1: [java$lang$String?]?) throws -> Void {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_setChoices_AD_Ajava$lang$String__V(jobj)(a0?.arrayToJArray() ?? nil, a1?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$ChoiceFormat_getLimits__AD = invoker("getLimits", returns: JArray(jdouble.jniType))
    public func getLimits() throws -> [jdouble]? {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_getLimits__AD(jobj)().jarrayToArray()
    }

    private static let java$text$ChoiceFormat_getFormats__Ajava$lang$Object = invoker("getFormats", returns: JArray(JObjectType("java/lang/Object")))
    public func getFormats() throws -> [java$lang$Object?]? {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_getFormats__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$text$ChoiceFormat_format_J_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jlong.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$ChoiceFormat_format_D_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jdouble.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$ChoiceFormat_parse_java$lang$String_java$text$ParsePosition__java$lang$Number = invoker("parse", returns: JObjectType("java/lang/Number"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$ChoiceFormat_nextDouble_D__D = svoker("nextDouble", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func nextDouble(a0: jdouble) throws -> jdouble {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_nextDouble_D__D(a0)
    }

    private static let java$text$ChoiceFormat_previousDouble_D__D = svoker("previousDouble", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public static func previousDouble(a0: jdouble) throws -> jdouble {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_previousDouble_D__D(a0)
    }

    private static let java$text$ChoiceFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$ChoiceFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$ChoiceFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$ChoiceFormat_nextDouble_D_Z__D = svoker("nextDouble", returns: jdouble.jniType, arguments: (jdouble.jniType, jboolean.jniType))
    public static func nextDouble(a0: jdouble, _ a1: jboolean) throws -> jdouble {
        return try java$text$ChoiceFormat$.java$text$ChoiceFormat_nextDouble_D_Z__D(a0, a1)
    }

}

public typealias java$text$ChoiceFormat$ = java$text$ChoiceFormat

public final class java$text$CollationElementIterator : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$CollationElementIterator_reset__V = invoker("reset", returns: JVoid.jniType)
    public func reset() throws -> Void {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_reset__V(jobj)()
    }

    private static let java$text$CollationElementIterator_next__I = invoker("next", returns: jint.jniType)
    public func next() throws -> jint {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_next__I(jobj)()
    }

    private static let java$text$CollationElementIterator_previous__I = invoker("previous", returns: jint.jniType)
    public func previous() throws -> jint {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_previous__I(jobj)()
    }

    private static let java$text$CollationElementIterator_primaryOrder_I__I = svoker("primaryOrder", returns: jint.jniType, arguments: (jint.jniType))
    public static func primaryOrder(a0: jint) throws -> jint {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_primaryOrder_I__I(a0)
    }

    private static let java$text$CollationElementIterator_secondaryOrder_I__S = svoker("secondaryOrder", returns: jshort.jniType, arguments: (jint.jniType))
    public static func secondaryOrder(a0: jint) throws -> jshort {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_secondaryOrder_I__S(a0)
    }

    private static let java$text$CollationElementIterator_tertiaryOrder_I__S = svoker("tertiaryOrder", returns: jshort.jniType, arguments: (jint.jniType))
    public static func tertiaryOrder(a0: jint) throws -> jshort {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_tertiaryOrder_I__S(a0)
    }

    private static let java$text$CollationElementIterator_setOffset_I__V = invoker("setOffset", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setOffset(a0: jint) throws -> Void {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_setOffset_I__V(jobj)(a0)
    }

    private static let java$text$CollationElementIterator_getOffset__I = invoker("getOffset", returns: jint.jniType)
    public func getOffset() throws -> jint {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_getOffset__I(jobj)()
    }

    private static let java$text$CollationElementIterator_getMaxExpansion_I__I = invoker("getMaxExpansion", returns: jint.jniType, arguments: (jint.jniType))
    public func getMaxExpansion(a0: jint) throws -> jint {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_getMaxExpansion_I__I(jobj)(a0)
    }

    private static let java$text$CollationElementIterator_setText_java$lang$String__V = invoker("setText", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setText(a0: java$lang$String?) throws -> Void {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_setText_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$CollationElementIterator_setText_java$text$CharacterIterator__V = invoker("setText", returns: JVoid.jniType, arguments: (JObjectType("java/text/CharacterIterator")))
    public func setText(a0: java$text$CharacterIterator?) throws -> Void {
        return try java$text$CollationElementIterator$.java$text$CollationElementIterator_setText_java$text$CharacterIterator__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$text$CollationElementIterator$ = java$text$CollationElementIterator

public class java$text$CollationKey : java$lang$Object$, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$CollationKey_compareTo_java$text$CollationKey__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/text/CollationKey")))
    public func compareTo(a0: java$text$CollationKey?) throws -> jint {
        return try java$text$CollationKey$.java$text$CollationKey_compareTo_java$text$CollationKey__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$CollationKey_getSourceString__java$lang$String = invoker("getSourceString", returns: JObjectType("java/lang/String"))
    public func getSourceString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$CollationKey$.java$text$CollationKey_getSourceString__java$lang$String(jobj)())
    }

    private static let java$text$CollationKey_toByteArray__AB = invoker("toByteArray", returns: JArray(jbyte.jniType))
    public func toByteArray() throws -> [jbyte]? {
        return try java$text$CollationKey$.java$text$CollationKey_toByteArray__AB(jobj)().jarrayToArray()
    }

    private static let java$text$CollationKey_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$text$CollationKey$.java$text$CollationKey_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$text$CollationKey$ = java$text$CollationKey

public class java$text$Collator : java$lang$Object$, java$util$Comparator, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$Collator_getInstance__java$text$Collator = svoker("getInstance", returns: JObjectType("java/text/Collator"))
    public static func getInstance() throws -> java$text$Collator? {
        return try java$text$Collator$(jobj: java$text$Collator$.java$text$Collator_getInstance__java$text$Collator())
    }

    private static let java$text$Collator_getInstance_java$util$Locale__java$text$Collator = svoker("getInstance", returns: JObjectType("java/text/Collator"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$text$Collator? {
        return try java$text$Collator$(jobj: java$text$Collator$.java$text$Collator_getInstance_java$util$Locale__java$text$Collator(a0?.jobj ?? nil))
    }

    private static let java$text$Collator_compare_java$lang$String_java$lang$String__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func compare(a0: java$lang$String?, _ a1: java$lang$String?) throws -> jint {
        return try java$text$Collator$.java$text$Collator_compare_java$lang$String_java$lang$String__I(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$text$Collator_compare_java$lang$Object_java$lang$Object__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func compare(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jint {
        return try java$text$Collator$.java$text$Collator_compare_java$lang$Object_java$lang$Object__I(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$text$Collator_getCollationKey_java$lang$String__java$text$CollationKey = invoker("getCollationKey", returns: JObjectType("java/text/CollationKey"), arguments: (JObjectType("java/lang/String")))
    public func getCollationKey(a0: java$lang$String?) throws -> java$text$CollationKey? {
        return try java$text$CollationKey$(jobj: java$text$Collator$.java$text$Collator_getCollationKey_java$lang$String__java$text$CollationKey(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$Collator_equals_java$lang$String_java$lang$String__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func equals(a0: java$lang$String?, _ a1: java$lang$String?) throws -> jboolean {
        return try java$text$Collator$.java$text$Collator_equals_java$lang$String_java$lang$String__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$text$Collator_getStrength__I = invoker("getStrength", returns: jint.jniType)
    public func getStrength() throws -> jint {
        return try java$text$Collator$.java$text$Collator_getStrength__I(jobj)()
    }

    private static let java$text$Collator_setStrength_I__V = invoker("setStrength", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setStrength(a0: jint) throws -> Void {
        return try java$text$Collator$.java$text$Collator_setStrength_I__V(jobj)(a0)
    }

    private static let java$text$Collator_getDecomposition__I = invoker("getDecomposition", returns: jint.jniType)
    public func getDecomposition() throws -> jint {
        return try java$text$Collator$.java$text$Collator_getDecomposition__I(jobj)()
    }

    private static let java$text$Collator_setDecomposition_I__V = invoker("setDecomposition", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setDecomposition(a0: jint) throws -> Void {
        return try java$text$Collator$.java$text$Collator_setDecomposition_I__V(jobj)(a0)
    }

    private static let java$text$Collator_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$Collator$.java$text$Collator_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$text$Collator_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$Collator$.java$text$Collator_clone__java$lang$Object(jobj)())
    }

    private static let java$text$Collator_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$Collator_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$text$Collator$ = java$text$Collator

public class java$text$DateFormat : java$text$Format$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$DateFormat_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$DateFormat_format_java$util$Date_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/util/Date"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    public func format(a0: java$util$Date?, _ a1: java$lang$StringBuffer?, _ a2: java$text$FieldPosition?) throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$text$DateFormat$.java$text$DateFormat_format_java$util$Date_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$text$DateFormat_format_java$util$Date__java$lang$String = invoker("format", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Date")))
    public func format(a0: java$util$Date?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DateFormat$.java$text$DateFormat_format_java$util$Date__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$DateFormat_parse_java$lang$String__java$util$Date = invoker("parse", returns: JObjectType("java/util/Date"), arguments: (JObjectType("java/lang/String")))
    public func parse(a0: java$lang$String?) throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$text$DateFormat$.java$text$DateFormat_parse_java$lang$String__java$util$Date(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$DateFormat_parse_java$lang$String_java$text$ParsePosition__java$util$Date = invoker("parse", returns: JObjectType("java/util/Date"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    public func parse(a0: java$lang$String?, _ a1: java$text$ParsePosition?) throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$text$DateFormat$.java$text$DateFormat_parse_java$lang$String_java$text$ParsePosition__java$util$Date(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$text$DateFormat_parseObject_java$lang$String_java$text$ParsePosition__java$lang$Object = invoker("parseObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$DateFormat_getTimeInstance__java$text$DateFormat = svoker("getTimeInstance", returns: JObjectType("java/text/DateFormat"))
    public static func getTimeInstance() throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getTimeInstance__java$text$DateFormat())
    }

    private static let java$text$DateFormat_getTimeInstance_I__java$text$DateFormat = svoker("getTimeInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType))
    public static func getTimeInstance(a0: jint) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getTimeInstance_I__java$text$DateFormat(a0))
    }

    private static let java$text$DateFormat_getTimeInstance_I_java$util$Locale__java$text$DateFormat = svoker("getTimeInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType, JObjectType("java/util/Locale")))
    public static func getTimeInstance(a0: jint, _ a1: java$util$Locale?) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getTimeInstance_I_java$util$Locale__java$text$DateFormat(a0, a1?.jobj ?? nil))
    }

    private static let java$text$DateFormat_getDateInstance__java$text$DateFormat = svoker("getDateInstance", returns: JObjectType("java/text/DateFormat"))
    public static func getDateInstance() throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateInstance__java$text$DateFormat())
    }

    private static let java$text$DateFormat_getDateInstance_I__java$text$DateFormat = svoker("getDateInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType))
    public static func getDateInstance(a0: jint) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateInstance_I__java$text$DateFormat(a0))
    }

    private static let java$text$DateFormat_getDateInstance_I_java$util$Locale__java$text$DateFormat = svoker("getDateInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType, JObjectType("java/util/Locale")))
    public static func getDateInstance(a0: jint, _ a1: java$util$Locale?) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateInstance_I_java$util$Locale__java$text$DateFormat(a0, a1?.jobj ?? nil))
    }

    private static let java$text$DateFormat_getDateTimeInstance__java$text$DateFormat = svoker("getDateTimeInstance", returns: JObjectType("java/text/DateFormat"))
    public static func getDateTimeInstance() throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateTimeInstance__java$text$DateFormat())
    }

    private static let java$text$DateFormat_getDateTimeInstance_I_I__java$text$DateFormat = svoker("getDateTimeInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType, jint.jniType))
    public static func getDateTimeInstance(a0: jint, _ a1: jint) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateTimeInstance_I_I__java$text$DateFormat(a0, a1))
    }

    private static let java$text$DateFormat_getDateTimeInstance_I_I_java$util$Locale__java$text$DateFormat = svoker("getDateTimeInstance", returns: JObjectType("java/text/DateFormat"), arguments: (jint.jniType, jint.jniType, JObjectType("java/util/Locale")))
    public static func getDateTimeInstance(a0: jint, _ a1: jint, _ a2: java$util$Locale?) throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getDateTimeInstance_I_I_java$util$Locale__java$text$DateFormat(a0, a1, a2?.jobj ?? nil))
    }

    private static let java$text$DateFormat_getInstance__java$text$DateFormat = svoker("getInstance", returns: JObjectType("java/text/DateFormat"))
    public static func getInstance() throws -> java$text$DateFormat? {
        return try java$text$DateFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getInstance__java$text$DateFormat())
    }

    private static let java$text$DateFormat_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$DateFormat$.java$text$DateFormat_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$text$DateFormat_setCalendar_java$util$Calendar__V = invoker("setCalendar", returns: JVoid.jniType, arguments: (JObjectType("java/util/Calendar")))
    public func setCalendar(a0: java$util$Calendar?) throws -> Void {
        return try java$text$DateFormat$.java$text$DateFormat_setCalendar_java$util$Calendar__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DateFormat_getCalendar__java$util$Calendar = invoker("getCalendar", returns: JObjectType("java/util/Calendar"))
    public func getCalendar() throws -> java$util$Calendar? {
        return try java$util$Calendar$(jobj: java$text$DateFormat$.java$text$DateFormat_getCalendar__java$util$Calendar(jobj)())
    }

    private static let java$text$DateFormat_setNumberFormat_java$text$NumberFormat__V = invoker("setNumberFormat", returns: JVoid.jniType, arguments: (JObjectType("java/text/NumberFormat")))
    public func setNumberFormat(a0: java$text$NumberFormat?) throws -> Void {
        return try java$text$DateFormat$.java$text$DateFormat_setNumberFormat_java$text$NumberFormat__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DateFormat_getNumberFormat__java$text$NumberFormat = invoker("getNumberFormat", returns: JObjectType("java/text/NumberFormat"))
    public func getNumberFormat() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$DateFormat$.java$text$DateFormat_getNumberFormat__java$text$NumberFormat(jobj)())
    }

    private static let java$text$DateFormat_setTimeZone_java$util$TimeZone__V = invoker("setTimeZone", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimeZone")))
    public func setTimeZone(a0: java$util$TimeZone?) throws -> Void {
        return try java$text$DateFormat$.java$text$DateFormat_setTimeZone_java$util$TimeZone__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DateFormat_getTimeZone__java$util$TimeZone = invoker("getTimeZone", returns: JObjectType("java/util/TimeZone"))
    public func getTimeZone() throws -> java$util$TimeZone? {
        return try java$util$TimeZone$(jobj: java$text$DateFormat$.java$text$DateFormat_getTimeZone__java$util$TimeZone(jobj)())
    }

    private static let java$text$DateFormat_setLenient_Z__V = invoker("setLenient", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setLenient(a0: jboolean) throws -> Void {
        return try java$text$DateFormat$.java$text$DateFormat_setLenient_Z__V(jobj)(a0)
    }

    private static let java$text$DateFormat_isLenient__Z = invoker("isLenient", returns: jboolean.jniType)
    public func isLenient() throws -> jboolean {
        return try java$text$DateFormat$.java$text$DateFormat_isLenient__Z(jobj)()
    }

    private static let java$text$DateFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$DateFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$DateFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
}

public typealias java$text$DateFormat$ = java$text$DateFormat

public class java$text$DateFormatSymbols : java$lang$Object$, java$io$Serializable, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$DateFormatSymbols_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_init__V()
        self.init(jobj: jobj)
    }

    private static let java$text$DateFormatSymbols_init_java$util$Locale__V = constructor((JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$util$Locale?) throws {
        let jobj = try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_init_java$util$Locale__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$DateFormatSymbols_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$text$DateFormatSymbols_getInstance__java$text$DateFormatSymbols = svoker("getInstance", returns: JObjectType("java/text/DateFormatSymbols"))
    public static func getInstance() throws -> java$text$DateFormatSymbols? {
        return try java$text$DateFormatSymbols$(jobj: java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getInstance__java$text$DateFormatSymbols())
    }

    private static let java$text$DateFormatSymbols_getInstance_java$util$Locale__java$text$DateFormatSymbols = svoker("getInstance", returns: JObjectType("java/text/DateFormatSymbols"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$text$DateFormatSymbols? {
        return try java$text$DateFormatSymbols$(jobj: java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getInstance_java$util$Locale__java$text$DateFormatSymbols(a0?.jobj ?? nil))
    }

    private static let java$text$DateFormatSymbols_getEras__Ajava$lang$String = invoker("getEras", returns: JArray(JObjectType("java/lang/String")))
    public func getEras() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getEras__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setEras_Ajava$lang$String__V = invoker("setEras", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setEras(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setEras_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getMonths__Ajava$lang$String = invoker("getMonths", returns: JArray(JObjectType("java/lang/String")))
    public func getMonths() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getMonths__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setMonths_Ajava$lang$String__V = invoker("setMonths", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setMonths(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setMonths_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getShortMonths__Ajava$lang$String = invoker("getShortMonths", returns: JArray(JObjectType("java/lang/String")))
    public func getShortMonths() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getShortMonths__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setShortMonths_Ajava$lang$String__V = invoker("setShortMonths", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setShortMonths(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setShortMonths_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getWeekdays__Ajava$lang$String = invoker("getWeekdays", returns: JArray(JObjectType("java/lang/String")))
    public func getWeekdays() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getWeekdays__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setWeekdays_Ajava$lang$String__V = invoker("setWeekdays", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setWeekdays(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setWeekdays_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getShortWeekdays__Ajava$lang$String = invoker("getShortWeekdays", returns: JArray(JObjectType("java/lang/String")))
    public func getShortWeekdays() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getShortWeekdays__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setShortWeekdays_Ajava$lang$String__V = invoker("setShortWeekdays", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setShortWeekdays(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setShortWeekdays_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getAmPmStrings__Ajava$lang$String = invoker("getAmPmStrings", returns: JArray(JObjectType("java/lang/String")))
    public func getAmPmStrings() throws -> [java$lang$String?]? {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getAmPmStrings__Ajava$lang$String(jobj)().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$text$DateFormatSymbols_setAmPmStrings_Ajava$lang$String__V = invoker("setAmPmStrings", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/String"))))
    public func setAmPmStrings(a0: [java$lang$String?]?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setAmPmStrings_Ajava$lang$String__V(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$DateFormatSymbols_getLocalPatternChars__java$lang$String = invoker("getLocalPatternChars", returns: JObjectType("java/lang/String"))
    public func getLocalPatternChars() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DateFormatSymbols$.java$text$DateFormatSymbols_getLocalPatternChars__java$lang$String(jobj)())
    }

    private static let java$text$DateFormatSymbols_setLocalPatternChars_java$lang$String__V = invoker("setLocalPatternChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setLocalPatternChars(a0: java$lang$String?) throws -> Void {
        return try java$text$DateFormatSymbols$.java$text$DateFormatSymbols_setLocalPatternChars_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DateFormatSymbols_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$DateFormatSymbols$.java$text$DateFormatSymbols_clone__java$lang$Object(jobj)())
    }

    private static let java$text$DateFormatSymbols_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$DateFormatSymbols_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$text$DateFormatSymbols$ = java$text$DateFormatSymbols

public class java$text$DecimalFormat : java$text$NumberFormat$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$DecimalFormat_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$text$DecimalFormat$.java$text$DecimalFormat_init__V()
        self.init(jobj: jobj)
    }

    private static let java$text$DecimalFormat_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$DecimalFormat$.java$text$DecimalFormat_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$DecimalFormat_init_java$lang$String_java$text$DecimalFormatSymbols__V = constructor((JObjectType("java/lang/String"), JObjectType("java/text/DecimalFormatSymbols")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$text$DecimalFormatSymbols?) throws {
        let jobj = try java$text$DecimalFormat$.java$text$DecimalFormat_init_java$lang$String_java$text$DecimalFormatSymbols__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$DecimalFormat_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$DecimalFormat_format_D_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jdouble.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$DecimalFormat_format_J_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jlong.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$DecimalFormat_formatToCharacterIterator_java$lang$Object__java$text$AttributedCharacterIterator = invoker("formatToCharacterIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JObjectType("java/lang/Object")))
    private static let java$text$DecimalFormat_parse_java$lang$String_java$text$ParsePosition__java$lang$Number = invoker("parse", returns: JObjectType("java/lang/Number"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$DecimalFormat_getDecimalFormatSymbols__java$text$DecimalFormatSymbols = invoker("getDecimalFormatSymbols", returns: JObjectType("java/text/DecimalFormatSymbols"))
    public func getDecimalFormatSymbols() throws -> java$text$DecimalFormatSymbols? {
        return try java$text$DecimalFormatSymbols$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_getDecimalFormatSymbols__java$text$DecimalFormatSymbols(jobj)())
    }

    private static let java$text$DecimalFormat_setDecimalFormatSymbols_java$text$DecimalFormatSymbols__V = invoker("setDecimalFormatSymbols", returns: JVoid.jniType, arguments: (JObjectType("java/text/DecimalFormatSymbols")))
    public func setDecimalFormatSymbols(a0: java$text$DecimalFormatSymbols?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setDecimalFormatSymbols_java$text$DecimalFormatSymbols__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_getPositivePrefix__java$lang$String = invoker("getPositivePrefix", returns: JObjectType("java/lang/String"))
    public func getPositivePrefix() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_getPositivePrefix__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_setPositivePrefix_java$lang$String__V = invoker("setPositivePrefix", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setPositivePrefix(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setPositivePrefix_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_getNegativePrefix__java$lang$String = invoker("getNegativePrefix", returns: JObjectType("java/lang/String"))
    public func getNegativePrefix() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_getNegativePrefix__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_setNegativePrefix_java$lang$String__V = invoker("setNegativePrefix", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setNegativePrefix(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setNegativePrefix_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_getPositiveSuffix__java$lang$String = invoker("getPositiveSuffix", returns: JObjectType("java/lang/String"))
    public func getPositiveSuffix() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_getPositiveSuffix__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_setPositiveSuffix_java$lang$String__V = invoker("setPositiveSuffix", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setPositiveSuffix(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setPositiveSuffix_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_getNegativeSuffix__java$lang$String = invoker("getNegativeSuffix", returns: JObjectType("java/lang/String"))
    public func getNegativeSuffix() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_getNegativeSuffix__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_setNegativeSuffix_java$lang$String__V = invoker("setNegativeSuffix", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setNegativeSuffix(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setNegativeSuffix_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_getMultiplier__I = invoker("getMultiplier", returns: jint.jniType)
    public func getMultiplier() throws -> jint {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_getMultiplier__I(jobj)()
    }

    private static let java$text$DecimalFormat_setMultiplier_I__V = invoker("setMultiplier", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMultiplier(a0: jint) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setMultiplier_I__V(jobj)(a0)
    }

    private static let java$text$DecimalFormat_setGroupingUsed_Z__V = invoker("setGroupingUsed", returns: JVoid.jniType, arguments: (jboolean.jniType))
    private static let java$text$DecimalFormat_getGroupingSize__I = invoker("getGroupingSize", returns: jint.jniType)
    public func getGroupingSize() throws -> jint {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_getGroupingSize__I(jobj)()
    }

    private static let java$text$DecimalFormat_setGroupingSize_I__V = invoker("setGroupingSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setGroupingSize(a0: jint) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setGroupingSize_I__V(jobj)(a0)
    }

    private static let java$text$DecimalFormat_isDecimalSeparatorAlwaysShown__Z = invoker("isDecimalSeparatorAlwaysShown", returns: jboolean.jniType)
    public func isDecimalSeparatorAlwaysShown() throws -> jboolean {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_isDecimalSeparatorAlwaysShown__Z(jobj)()
    }

    private static let java$text$DecimalFormat_setDecimalSeparatorAlwaysShown_Z__V = invoker("setDecimalSeparatorAlwaysShown", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setDecimalSeparatorAlwaysShown(a0: jboolean) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setDecimalSeparatorAlwaysShown_Z__V(jobj)(a0)
    }

    private static let java$text$DecimalFormat_isParseBigDecimal__Z = invoker("isParseBigDecimal", returns: jboolean.jniType)
    public func isParseBigDecimal() throws -> jboolean {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_isParseBigDecimal__Z(jobj)()
    }

    private static let java$text$DecimalFormat_setParseBigDecimal_Z__V = invoker("setParseBigDecimal", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setParseBigDecimal(a0: jboolean) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_setParseBigDecimal_Z__V(jobj)(a0)
    }

    private static let java$text$DecimalFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$DecimalFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$DecimalFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$DecimalFormat_toPattern__java$lang$String = invoker("toPattern", returns: JObjectType("java/lang/String"))
    public func toPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_toPattern__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_toLocalizedPattern__java$lang$String = invoker("toLocalizedPattern", returns: JObjectType("java/lang/String"))
    public func toLocalizedPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormat$.java$text$DecimalFormat_toLocalizedPattern__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormat_applyPattern_java$lang$String__V = invoker("applyPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_applyPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_applyLocalizedPattern_java$lang$String__V = invoker("applyLocalizedPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyLocalizedPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormat$.java$text$DecimalFormat_applyLocalizedPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormat_setMaximumIntegerDigits_I__V = invoker("setMaximumIntegerDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$text$DecimalFormat_setMinimumIntegerDigits_I__V = invoker("setMinimumIntegerDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$text$DecimalFormat_setMaximumFractionDigits_I__V = invoker("setMaximumFractionDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$text$DecimalFormat_setMinimumFractionDigits_I__V = invoker("setMinimumFractionDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$text$DecimalFormat_getMaximumIntegerDigits__I = invoker("getMaximumIntegerDigits", returns: jint.jniType)
    private static let java$text$DecimalFormat_getMinimumIntegerDigits__I = invoker("getMinimumIntegerDigits", returns: jint.jniType)
    private static let java$text$DecimalFormat_getMaximumFractionDigits__I = invoker("getMaximumFractionDigits", returns: jint.jniType)
    private static let java$text$DecimalFormat_getMinimumFractionDigits__I = invoker("getMinimumFractionDigits", returns: jint.jniType)
    private static let java$text$DecimalFormat_getCurrency__java$util$Currency = invoker("getCurrency", returns: JObjectType("java/util/Currency"))
    private static let java$text$DecimalFormat_setCurrency_java$util$Currency__V = invoker("setCurrency", returns: JVoid.jniType, arguments: (JObjectType("java/util/Currency")))
    private static let java$text$DecimalFormat_getRoundingMode__java$math$RoundingMode = invoker("getRoundingMode", returns: JObjectType("java/math/RoundingMode"))
    private static let java$text$DecimalFormat_setRoundingMode_java$math$RoundingMode__V = invoker("setRoundingMode", returns: JVoid.jniType, arguments: (JObjectType("java/math/RoundingMode")))
}

public typealias java$text$DecimalFormat$ = java$text$DecimalFormat

public class java$text$DecimalFormatSymbols : java$lang$Object$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$DecimalFormatSymbols_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_init__V()
        self.init(jobj: jobj)
    }

    private static let java$text$DecimalFormatSymbols_init_java$util$Locale__V = constructor((JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$util$Locale?) throws {
        let jobj = try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_init_java$util$Locale__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$DecimalFormatSymbols_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$text$DecimalFormatSymbols_getInstance__java$text$DecimalFormatSymbols = svoker("getInstance", returns: JObjectType("java/text/DecimalFormatSymbols"))
    public static func getInstance() throws -> java$text$DecimalFormatSymbols? {
        return try java$text$DecimalFormatSymbols$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getInstance__java$text$DecimalFormatSymbols())
    }

    private static let java$text$DecimalFormatSymbols_getInstance_java$util$Locale__java$text$DecimalFormatSymbols = svoker("getInstance", returns: JObjectType("java/text/DecimalFormatSymbols"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$text$DecimalFormatSymbols? {
        return try java$text$DecimalFormatSymbols$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getInstance_java$util$Locale__java$text$DecimalFormatSymbols(a0?.jobj ?? nil))
    }

    private static let java$text$DecimalFormatSymbols_getZeroDigit__C = invoker("getZeroDigit", returns: jchar.jniType)
    public func getZeroDigit() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getZeroDigit__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setZeroDigit_C__V = invoker("setZeroDigit", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setZeroDigit(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setZeroDigit_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getGroupingSeparator__C = invoker("getGroupingSeparator", returns: jchar.jniType)
    public func getGroupingSeparator() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getGroupingSeparator__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setGroupingSeparator_C__V = invoker("setGroupingSeparator", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setGroupingSeparator(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setGroupingSeparator_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getDecimalSeparator__C = invoker("getDecimalSeparator", returns: jchar.jniType)
    public func getDecimalSeparator() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getDecimalSeparator__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setDecimalSeparator_C__V = invoker("setDecimalSeparator", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setDecimalSeparator(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setDecimalSeparator_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getPerMill__C = invoker("getPerMill", returns: jchar.jniType)
    public func getPerMill() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getPerMill__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setPerMill_C__V = invoker("setPerMill", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setPerMill(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setPerMill_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getPercent__C = invoker("getPercent", returns: jchar.jniType)
    public func getPercent() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getPercent__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setPercent_C__V = invoker("setPercent", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setPercent(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setPercent_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getDigit__C = invoker("getDigit", returns: jchar.jniType)
    public func getDigit() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getDigit__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setDigit_C__V = invoker("setDigit", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setDigit(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setDigit_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getPatternSeparator__C = invoker("getPatternSeparator", returns: jchar.jniType)
    public func getPatternSeparator() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getPatternSeparator__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setPatternSeparator_C__V = invoker("setPatternSeparator", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setPatternSeparator(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setPatternSeparator_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getInfinity__java$lang$String = invoker("getInfinity", returns: JObjectType("java/lang/String"))
    public func getInfinity() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getInfinity__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setInfinity_java$lang$String__V = invoker("setInfinity", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setInfinity(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setInfinity_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_getNaN__java$lang$String = invoker("getNaN", returns: JObjectType("java/lang/String"))
    public func getNaN() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getNaN__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setNaN_java$lang$String__V = invoker("setNaN", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setNaN(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setNaN_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_getMinusSign__C = invoker("getMinusSign", returns: jchar.jniType)
    public func getMinusSign() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getMinusSign__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setMinusSign_C__V = invoker("setMinusSign", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setMinusSign(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setMinusSign_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getCurrencySymbol__java$lang$String = invoker("getCurrencySymbol", returns: JObjectType("java/lang/String"))
    public func getCurrencySymbol() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getCurrencySymbol__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setCurrencySymbol_java$lang$String__V = invoker("setCurrencySymbol", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setCurrencySymbol(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setCurrencySymbol_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_getInternationalCurrencySymbol__java$lang$String = invoker("getInternationalCurrencySymbol", returns: JObjectType("java/lang/String"))
    public func getInternationalCurrencySymbol() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getInternationalCurrencySymbol__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setInternationalCurrencySymbol_java$lang$String__V = invoker("setInternationalCurrencySymbol", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setInternationalCurrencySymbol(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setInternationalCurrencySymbol_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_getCurrency__java$util$Currency = invoker("getCurrency", returns: JObjectType("java/util/Currency"))
    public func getCurrency() throws -> java$util$Currency? {
        return try java$util$Currency$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getCurrency__java$util$Currency(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setCurrency_java$util$Currency__V = invoker("setCurrency", returns: JVoid.jniType, arguments: (JObjectType("java/util/Currency")))
    public func setCurrency(a0: java$util$Currency?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setCurrency_java$util$Currency__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_getMonetaryDecimalSeparator__C = invoker("getMonetaryDecimalSeparator", returns: jchar.jniType)
    public func getMonetaryDecimalSeparator() throws -> jchar {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getMonetaryDecimalSeparator__C(jobj)()
    }

    private static let java$text$DecimalFormatSymbols_setMonetaryDecimalSeparator_C__V = invoker("setMonetaryDecimalSeparator", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func setMonetaryDecimalSeparator(a0: jchar) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setMonetaryDecimalSeparator_C__V(jobj)(a0)
    }

    private static let java$text$DecimalFormatSymbols_getExponentSeparator__java$lang$String = invoker("getExponentSeparator", returns: JObjectType("java/lang/String"))
    public func getExponentSeparator() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_getExponentSeparator__java$lang$String(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_setExponentSeparator_java$lang$String__V = invoker("setExponentSeparator", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setExponentSeparator(a0: java$lang$String?) throws -> Void {
        return try java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_setExponentSeparator_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$DecimalFormatSymbols_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$DecimalFormatSymbols$.java$text$DecimalFormatSymbols_clone__java$lang$Object(jobj)())
    }

    private static let java$text$DecimalFormatSymbols_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$DecimalFormatSymbols_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$text$DecimalFormatSymbols$ = java$text$DecimalFormatSymbols

public final class java$text$DigitList : java$lang$Object$, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$DigitList_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$text$DigitList$.java$text$DigitList_clear__V(jobj)()
    }

    private static let java$text$DigitList_append_C__V = invoker("append", returns: JVoid.jniType, arguments: (jchar.jniType))
    public func append(a0: jchar) throws -> Void {
        return try java$text$DigitList$.java$text$DigitList_append_C__V(jobj)(a0)
    }

    private static let java$text$DigitList_getDouble__D = invoker("getDouble", returns: jdouble.jniType)
    public func getDouble() throws -> jdouble {
        return try java$text$DigitList$.java$text$DigitList_getDouble__D(jobj)()
    }

    private static let java$text$DigitList_getLong__J = invoker("getLong", returns: jlong.jniType)
    public func getLong() throws -> jlong {
        return try java$text$DigitList$.java$text$DigitList_getLong__J(jobj)()
    }

    private static let java$text$DigitList_getBigDecimal__java$math$BigDecimal = invoker("getBigDecimal", returns: JObjectType("java/math/BigDecimal"))
    public func getBigDecimal() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$text$DigitList$.java$text$DigitList_getBigDecimal__java$math$BigDecimal(jobj)())
    }

    private static let java$text$DigitList_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$DigitList_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$DigitList_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$DigitList$.java$text$DigitList_clone__java$lang$Object(jobj)())
    }

    private static let java$text$DigitList_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$DigitList$ = java$text$DigitList

public class java$text$DontCareFieldPosition : java$text$FieldPosition$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$text$DontCareFieldPosition$ = java$text$DontCareFieldPosition

public final class java$text$EntryPair : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$EntryPair_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$text$EntryPair$.java$text$EntryPair_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$EntryPair_init_java$lang$String_I_Z__V = constructor((JObjectType("java/lang/String"), jint.jniType, jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint, _ a2: jboolean) throws {
        let jobj = try java$text$EntryPair$.java$text$EntryPair_init_java$lang$String_I_Z__V(a0?.jobj ?? nil, a1, a2)
        self.init(jobj: jobj)
    }

}

public typealias java$text$EntryPair$ = java$text$EntryPair

public class java$text$FieldPosition : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$FieldPosition_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$text$FieldPosition$.java$text$FieldPosition_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$text$FieldPosition_init_java$text$Format$Field__V = constructor((JObjectType("java/text/Format$Field")))
    public convenience init!(_ a0: java$text$Format$Field?) throws {
        let jobj = try java$text$FieldPosition$.java$text$FieldPosition_init_java$text$Format$Field__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$FieldPosition_init_java$text$Format$Field_I__V = constructor((JObjectType("java/text/Format$Field"), jint.jniType))
    public convenience init!(_ a0: java$text$Format$Field?, _ a1: jint) throws {
        let jobj = try java$text$FieldPosition$.java$text$FieldPosition_init_java$text$Format$Field_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$FieldPosition_getFieldAttribute__java$text$Format$Field = invoker("getFieldAttribute", returns: JObjectType("java/text/Format$Field"))
    public func getFieldAttribute() throws -> java$text$Format$Field? {
        return try java$text$Format$Field$(jobj: java$text$FieldPosition$.java$text$FieldPosition_getFieldAttribute__java$text$Format$Field(jobj)())
    }

    private static let java$text$FieldPosition_getField__I = invoker("getField", returns: jint.jniType)
    public func getField() throws -> jint {
        return try java$text$FieldPosition$.java$text$FieldPosition_getField__I(jobj)()
    }

    private static let java$text$FieldPosition_getBeginIndex__I = invoker("getBeginIndex", returns: jint.jniType)
    public func getBeginIndex() throws -> jint {
        return try java$text$FieldPosition$.java$text$FieldPosition_getBeginIndex__I(jobj)()
    }

    private static let java$text$FieldPosition_getEndIndex__I = invoker("getEndIndex", returns: jint.jniType)
    public func getEndIndex() throws -> jint {
        return try java$text$FieldPosition$.java$text$FieldPosition_getEndIndex__I(jobj)()
    }

    private static let java$text$FieldPosition_setBeginIndex_I__V = invoker("setBeginIndex", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setBeginIndex(a0: jint) throws -> Void {
        return try java$text$FieldPosition$.java$text$FieldPosition_setBeginIndex_I__V(jobj)(a0)
    }

    private static let java$text$FieldPosition_setEndIndex_I__V = invoker("setEndIndex", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setEndIndex(a0: jint) throws -> Void {
        return try java$text$FieldPosition$.java$text$FieldPosition_setEndIndex_I__V(jobj)(a0)
    }

    private static let java$text$FieldPosition_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$FieldPosition_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$FieldPosition_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$FieldPosition$ = java$text$FieldPosition

public class java$text$Format : java$lang$Object$, java$io$Serializable, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$Format_format_java$lang$Object__java$lang$String = invoker("format", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/Object")))
    public func format(a0: java$lang$Object?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$Format$.java$text$Format_format_java$lang$Object__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$Format_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    public func format(a0: java$lang$Object?, _ a1: java$lang$StringBuffer?, _ a2: java$text$FieldPosition?) throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$text$Format$.java$text$Format_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$text$Format_formatToCharacterIterator_java$lang$Object__java$text$AttributedCharacterIterator = invoker("formatToCharacterIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JObjectType("java/lang/Object")))
    public func formatToCharacterIterator(a0: java$lang$Object?) throws -> java$text$AttributedCharacterIterator? {
        return try java$text$AttributedCharacterIterator$(jobj: java$text$Format$.java$text$Format_formatToCharacterIterator_java$lang$Object__java$text$AttributedCharacterIterator(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$Format_parseObject_java$lang$String_java$text$ParsePosition__java$lang$Object = invoker("parseObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    public func parseObject(a0: java$lang$String?, _ a1: java$text$ParsePosition?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$Format$.java$text$Format_parseObject_java$lang$String_java$text$ParsePosition__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$text$Format_parseObject_java$lang$String__java$lang$Object = invoker("parseObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func parseObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$Format$.java$text$Format_parseObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$Format_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$Format$.java$text$Format_clone__java$lang$Object(jobj)())
    }

}

public typealias java$text$Format$ = java$text$Format

public final class java$text$MergeCollation : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$MergeCollation_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$MergeCollation$.java$text$MergeCollation_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$MergeCollation_getPattern__java$lang$String = invoker("getPattern", returns: JObjectType("java/lang/String"))
    public func getPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MergeCollation$.java$text$MergeCollation_getPattern__java$lang$String(jobj)())
    }

    private static let java$text$MergeCollation_getPattern_Z__java$lang$String = invoker("getPattern", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType))
    public func getPattern(a0: jboolean) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MergeCollation$.java$text$MergeCollation_getPattern_Z__java$lang$String(jobj)(a0))
    }

    private static let java$text$MergeCollation_emitPattern__java$lang$String = invoker("emitPattern", returns: JObjectType("java/lang/String"))
    public func emitPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MergeCollation$.java$text$MergeCollation_emitPattern__java$lang$String(jobj)())
    }

    private static let java$text$MergeCollation_emitPattern_Z__java$lang$String = invoker("emitPattern", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType))
    public func emitPattern(a0: jboolean) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MergeCollation$.java$text$MergeCollation_emitPattern_Z__java$lang$String(jobj)(a0))
    }

    private static let java$text$MergeCollation_setPattern_java$lang$String__V = invoker("setPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$MergeCollation$.java$text$MergeCollation_setPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$MergeCollation_addPattern_java$lang$String__V = invoker("addPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func addPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$MergeCollation$.java$text$MergeCollation_addPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$MergeCollation_getCount__I = invoker("getCount", returns: jint.jniType)
    public func getCount() throws -> jint {
        return try java$text$MergeCollation$.java$text$MergeCollation_getCount__I(jobj)()
    }

    private static let java$text$MergeCollation_getItemAt_I__java$text$PatternEntry = invoker("getItemAt", returns: JObjectType("java/text/PatternEntry"), arguments: (jint.jniType))
    public func getItemAt(a0: jint) throws -> java$text$PatternEntry? {
        return try java$text$PatternEntry$(jobj: java$text$MergeCollation$.java$text$MergeCollation_getItemAt_I__java$text$PatternEntry(jobj)(a0))
    }

}

public typealias java$text$MergeCollation$ = java$text$MergeCollation

public class java$text$MessageFormat : java$text$Format$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$MessageFormat_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$MessageFormat$.java$text$MessageFormat_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$MessageFormat_init_java$lang$String_java$util$Locale__V = constructor((JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$util$Locale?) throws {
        let jobj = try java$text$MessageFormat$.java$text$MessageFormat_init_java$lang$String_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$MessageFormat_setLocale_java$util$Locale__V = invoker("setLocale", returns: JVoid.jniType, arguments: (JObjectType("java/util/Locale")))
    public func setLocale(a0: java$util$Locale?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_setLocale_java$util$Locale__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$MessageFormat_getLocale__java$util$Locale = invoker("getLocale", returns: JObjectType("java/util/Locale"))
    public func getLocale() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$text$MessageFormat$.java$text$MessageFormat_getLocale__java$util$Locale(jobj)())
    }

    private static let java$text$MessageFormat_applyPattern_java$lang$String__V = invoker("applyPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_applyPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$MessageFormat_toPattern__java$lang$String = invoker("toPattern", returns: JObjectType("java/lang/String"))
    public func toPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MessageFormat$.java$text$MessageFormat_toPattern__java$lang$String(jobj)())
    }

    private static let java$text$MessageFormat_setFormatsByArgumentIndex_Ajava$text$Format__V = invoker("setFormatsByArgumentIndex", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/text/Format"))))
    public func setFormatsByArgumentIndex(a0: [java$text$Format?]?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_setFormatsByArgumentIndex_Ajava$text$Format__V(jobj)(a0?.map({ java$text$Format$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$MessageFormat_setFormats_Ajava$text$Format__V = invoker("setFormats", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/text/Format"))))
    public func setFormats(a0: [java$text$Format?]?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_setFormats_Ajava$text$Format__V(jobj)(a0?.map({ java$text$Format$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$text$MessageFormat_setFormatByArgumentIndex_I_java$text$Format__V = invoker("setFormatByArgumentIndex", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/text/Format")))
    public func setFormatByArgumentIndex(a0: jint, _ a1: java$text$Format?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_setFormatByArgumentIndex_I_java$text$Format__V(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$text$MessageFormat_setFormat_I_java$text$Format__V = invoker("setFormat", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/text/Format")))
    public func setFormat(a0: jint, _ a1: java$text$Format?) throws -> Void {
        return try java$text$MessageFormat$.java$text$MessageFormat_setFormat_I_java$text$Format__V(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$text$MessageFormat_getFormatsByArgumentIndex__Ajava$text$Format = invoker("getFormatsByArgumentIndex", returns: JArray(JObjectType("java/text/Format")))
    public func getFormatsByArgumentIndex() throws -> [java$text$Format?]? {
        return try java$text$MessageFormat$.java$text$MessageFormat_getFormatsByArgumentIndex__Ajava$text$Format(jobj)().jarrayToArray(java$text$Format$.self)?.map({ $0 as java$text$Format? })
    }

    private static let java$text$MessageFormat_getFormats__Ajava$text$Format = invoker("getFormats", returns: JArray(JObjectType("java/text/Format")))
    public func getFormats() throws -> [java$text$Format?]? {
        return try java$text$MessageFormat$.java$text$MessageFormat_getFormats__Ajava$text$Format(jobj)().jarrayToArray(java$text$Format$.self)?.map({ $0 as java$text$Format? })
    }

    private static let java$text$MessageFormat_format_Ajava$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    public func format(a0: [java$lang$Object?]?, _ a1: java$lang$StringBuffer?, _ a2: java$text$FieldPosition?) throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$text$MessageFormat$.java$text$MessageFormat_format_Ajava$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$text$MessageFormat_format_java$lang$String_Ajava$lang$Object__java$lang$String = svoker("format", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public static func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$MessageFormat$.java$text$MessageFormat_format_java$lang$String_Ajava$lang$Object__java$lang$String(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$text$MessageFormat_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$MessageFormat_formatToCharacterIterator_java$lang$Object__java$text$AttributedCharacterIterator = invoker("formatToCharacterIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JObjectType("java/lang/Object")))
    private static let java$text$MessageFormat_parse_java$lang$String_java$text$ParsePosition__Ajava$lang$Object = invoker("parse", returns: JArray(JObjectType("java/lang/Object")), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    public func parse(a0: java$lang$String?, _ a1: java$text$ParsePosition?) throws -> [java$lang$Object?]? {
        return try java$text$MessageFormat$.java$text$MessageFormat_parse_java$lang$String_java$text$ParsePosition__Ajava$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$text$MessageFormat_parse_java$lang$String__Ajava$lang$Object = invoker("parse", returns: JArray(JObjectType("java/lang/Object")), arguments: (JObjectType("java/lang/String")))
    public func parse(a0: java$lang$String?) throws -> [java$lang$Object?]? {
        return try java$text$MessageFormat$.java$text$MessageFormat_parse_java$lang$String__Ajava$lang$Object(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$text$MessageFormat_parseObject_java$lang$String_java$text$ParsePosition__java$lang$Object = invoker("parseObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$MessageFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$MessageFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$MessageFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$text$MessageFormat$ = java$text$MessageFormat

public final class java$text$Normalizer : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$Normalizer_normalize_java$lang$CharSequence_java$text$Normalizer$Form__java$lang$String = svoker("normalize", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/CharSequence"), JObjectType("java/text/Normalizer$Form")))
    public static func normalize(a0: java$lang$CharSequence?, _ a1: java$text$Normalizer$Form?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$Normalizer$.java$text$Normalizer_normalize_java$lang$CharSequence_java$text$Normalizer$Form__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$text$Normalizer_isNormalized_java$lang$CharSequence_java$text$Normalizer$Form__Z = svoker("isNormalized", returns: jboolean.jniType, arguments: (JObjectType("java/lang/CharSequence"), JObjectType("java/text/Normalizer$Form")))
    public static func isNormalized(a0: java$lang$CharSequence?, _ a1: java$text$Normalizer$Form?) throws -> jboolean {
        return try java$text$Normalizer$.java$text$Normalizer_isNormalized_java$lang$CharSequence_java$text$Normalizer$Form__Z(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public typealias java$text$Normalizer$ = java$text$Normalizer

public class java$text$NumberFormat : java$text$Format$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$NumberFormat_format_java$lang$Object_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$NumberFormat_parseObject_java$lang$String_java$text$ParsePosition__java$lang$Object = invoker("parseObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$NumberFormat_format_D__java$lang$String = invoker("format", returns: JObjectType("java/lang/String"), arguments: (jdouble.jniType))
    public func format(a0: jdouble) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$NumberFormat$.java$text$NumberFormat_format_D__java$lang$String(jobj)(a0))
    }

    private static let java$text$NumberFormat_format_J__java$lang$String = invoker("format", returns: JObjectType("java/lang/String"), arguments: (jlong.jniType))
    public func format(a0: jlong) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$NumberFormat$.java$text$NumberFormat_format_J__java$lang$String(jobj)(a0))
    }

    private static let java$text$NumberFormat_format_D_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jdouble.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    public func format(a0: jdouble, _ a1: java$lang$StringBuffer?, _ a2: java$text$FieldPosition?) throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$text$NumberFormat$.java$text$NumberFormat_format_D_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_format_J_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (jlong.jniType, JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    public func format(a0: jlong, _ a1: java$lang$StringBuffer?, _ a2: java$text$FieldPosition?) throws -> java$lang$StringBuffer? {
        return try java$lang$StringBuffer$(jobj: java$text$NumberFormat$.java$text$NumberFormat_format_J_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer(jobj)(a0, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_parse_java$lang$String_java$text$ParsePosition__java$lang$Number = invoker("parse", returns: JObjectType("java/lang/Number"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    public func parse(a0: java$lang$String?, _ a1: java$text$ParsePosition?) throws -> java$lang$Number? {
        return try java$lang$Number$(jobj: java$text$NumberFormat$.java$text$NumberFormat_parse_java$lang$String_java$text$ParsePosition__java$lang$Number(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_parse_java$lang$String__java$lang$Number = invoker("parse", returns: JObjectType("java/lang/Number"), arguments: (JObjectType("java/lang/String")))
    public func parse(a0: java$lang$String?) throws -> java$lang$Number? {
        return try java$lang$Number$(jobj: java$text$NumberFormat$.java$text$NumberFormat_parse_java$lang$String__java$lang$Number(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_isParseIntegerOnly__Z = invoker("isParseIntegerOnly", returns: jboolean.jniType)
    public func isParseIntegerOnly() throws -> jboolean {
        return try java$text$NumberFormat$.java$text$NumberFormat_isParseIntegerOnly__Z(jobj)()
    }

    private static let java$text$NumberFormat_setParseIntegerOnly_Z__V = invoker("setParseIntegerOnly", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setParseIntegerOnly(a0: jboolean) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setParseIntegerOnly_Z__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getInstance__java$text$NumberFormat = svoker("getInstance", returns: JObjectType("java/text/NumberFormat"))
    public static func getInstance() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getInstance__java$text$NumberFormat())
    }

    private static let java$text$NumberFormat_getInstance_java$util$Locale__java$text$NumberFormat = svoker("getInstance", returns: JObjectType("java/text/NumberFormat"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getInstance_java$util$Locale__java$text$NumberFormat(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_getNumberInstance__java$text$NumberFormat = svoker("getNumberInstance", returns: JObjectType("java/text/NumberFormat"))
    public static func getNumberInstance() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getNumberInstance__java$text$NumberFormat())
    }

    private static let java$text$NumberFormat_getNumberInstance_java$util$Locale__java$text$NumberFormat = svoker("getNumberInstance", returns: JObjectType("java/text/NumberFormat"), arguments: (JObjectType("java/util/Locale")))
    public static func getNumberInstance(a0: java$util$Locale?) throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getNumberInstance_java$util$Locale__java$text$NumberFormat(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_getIntegerInstance__java$text$NumberFormat = svoker("getIntegerInstance", returns: JObjectType("java/text/NumberFormat"))
    public static func getIntegerInstance() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getIntegerInstance__java$text$NumberFormat())
    }

    private static let java$text$NumberFormat_getIntegerInstance_java$util$Locale__java$text$NumberFormat = svoker("getIntegerInstance", returns: JObjectType("java/text/NumberFormat"), arguments: (JObjectType("java/util/Locale")))
    public static func getIntegerInstance(a0: java$util$Locale?) throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getIntegerInstance_java$util$Locale__java$text$NumberFormat(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_getCurrencyInstance__java$text$NumberFormat = svoker("getCurrencyInstance", returns: JObjectType("java/text/NumberFormat"))
    public static func getCurrencyInstance() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getCurrencyInstance__java$text$NumberFormat())
    }

    private static let java$text$NumberFormat_getCurrencyInstance_java$util$Locale__java$text$NumberFormat = svoker("getCurrencyInstance", returns: JObjectType("java/text/NumberFormat"), arguments: (JObjectType("java/util/Locale")))
    public static func getCurrencyInstance(a0: java$util$Locale?) throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getCurrencyInstance_java$util$Locale__java$text$NumberFormat(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_getPercentInstance__java$text$NumberFormat = svoker("getPercentInstance", returns: JObjectType("java/text/NumberFormat"))
    public static func getPercentInstance() throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getPercentInstance__java$text$NumberFormat())
    }

    private static let java$text$NumberFormat_getPercentInstance_java$util$Locale__java$text$NumberFormat = svoker("getPercentInstance", returns: JObjectType("java/text/NumberFormat"), arguments: (JObjectType("java/util/Locale")))
    public static func getPercentInstance(a0: java$util$Locale?) throws -> java$text$NumberFormat? {
        return try java$text$NumberFormat$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getPercentInstance_java$util$Locale__java$text$NumberFormat(a0?.jobj ?? nil))
    }

    private static let java$text$NumberFormat_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$text$NumberFormat$.java$text$NumberFormat_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$text$NumberFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$NumberFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$NumberFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$NumberFormat_isGroupingUsed__Z = invoker("isGroupingUsed", returns: jboolean.jniType)
    public func isGroupingUsed() throws -> jboolean {
        return try java$text$NumberFormat$.java$text$NumberFormat_isGroupingUsed__Z(jobj)()
    }

    private static let java$text$NumberFormat_setGroupingUsed_Z__V = invoker("setGroupingUsed", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setGroupingUsed(a0: jboolean) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setGroupingUsed_Z__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getMaximumIntegerDigits__I = invoker("getMaximumIntegerDigits", returns: jint.jniType)
    public func getMaximumIntegerDigits() throws -> jint {
        return try java$text$NumberFormat$.java$text$NumberFormat_getMaximumIntegerDigits__I(jobj)()
    }

    private static let java$text$NumberFormat_setMaximumIntegerDigits_I__V = invoker("setMaximumIntegerDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMaximumIntegerDigits(a0: jint) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setMaximumIntegerDigits_I__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getMinimumIntegerDigits__I = invoker("getMinimumIntegerDigits", returns: jint.jniType)
    public func getMinimumIntegerDigits() throws -> jint {
        return try java$text$NumberFormat$.java$text$NumberFormat_getMinimumIntegerDigits__I(jobj)()
    }

    private static let java$text$NumberFormat_setMinimumIntegerDigits_I__V = invoker("setMinimumIntegerDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMinimumIntegerDigits(a0: jint) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setMinimumIntegerDigits_I__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getMaximumFractionDigits__I = invoker("getMaximumFractionDigits", returns: jint.jniType)
    public func getMaximumFractionDigits() throws -> jint {
        return try java$text$NumberFormat$.java$text$NumberFormat_getMaximumFractionDigits__I(jobj)()
    }

    private static let java$text$NumberFormat_setMaximumFractionDigits_I__V = invoker("setMaximumFractionDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMaximumFractionDigits(a0: jint) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setMaximumFractionDigits_I__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getMinimumFractionDigits__I = invoker("getMinimumFractionDigits", returns: jint.jniType)
    public func getMinimumFractionDigits() throws -> jint {
        return try java$text$NumberFormat$.java$text$NumberFormat_getMinimumFractionDigits__I(jobj)()
    }

    private static let java$text$NumberFormat_setMinimumFractionDigits_I__V = invoker("setMinimumFractionDigits", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMinimumFractionDigits(a0: jint) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setMinimumFractionDigits_I__V(jobj)(a0)
    }

    private static let java$text$NumberFormat_getCurrency__java$util$Currency = invoker("getCurrency", returns: JObjectType("java/util/Currency"))
    public func getCurrency() throws -> java$util$Currency? {
        return try java$util$Currency$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getCurrency__java$util$Currency(jobj)())
    }

    private static let java$text$NumberFormat_setCurrency_java$util$Currency__V = invoker("setCurrency", returns: JVoid.jniType, arguments: (JObjectType("java/util/Currency")))
    public func setCurrency(a0: java$util$Currency?) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setCurrency_java$util$Currency__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$NumberFormat_getRoundingMode__java$math$RoundingMode = invoker("getRoundingMode", returns: JObjectType("java/math/RoundingMode"))
    public func getRoundingMode() throws -> java$math$RoundingMode? {
        return try java$math$RoundingMode$(jobj: java$text$NumberFormat$.java$text$NumberFormat_getRoundingMode__java$math$RoundingMode(jobj)())
    }

    private static let java$text$NumberFormat_setRoundingMode_java$math$RoundingMode__V = invoker("setRoundingMode", returns: JVoid.jniType, arguments: (JObjectType("java/math/RoundingMode")))
    public func setRoundingMode(a0: java$math$RoundingMode?) throws -> Void {
        return try java$text$NumberFormat$.java$text$NumberFormat_setRoundingMode_java$math$RoundingMode__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$text$NumberFormat$ = java$text$NumberFormat

public class java$text$ParseException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$ParseException_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$text$ParseException$.java$text$ParseException_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$ParseException_getErrorOffset__I = invoker("getErrorOffset", returns: jint.jniType)
    public func getErrorOffset() throws -> jint {
        return try java$text$ParseException$.java$text$ParseException_getErrorOffset__I(jobj)()
    }

}

public typealias java$text$ParseException$ = java$text$ParseException

public class java$text$ParsePosition : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$ParsePosition_getIndex__I = invoker("getIndex", returns: jint.jniType)
    public func getIndex() throws -> jint {
        return try java$text$ParsePosition$.java$text$ParsePosition_getIndex__I(jobj)()
    }

    private static let java$text$ParsePosition_setIndex_I__V = invoker("setIndex", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setIndex(a0: jint) throws -> Void {
        return try java$text$ParsePosition$.java$text$ParsePosition_setIndex_I__V(jobj)(a0)
    }

    private static let java$text$ParsePosition_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$text$ParsePosition$.java$text$ParsePosition_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$text$ParsePosition_setErrorIndex_I__V = invoker("setErrorIndex", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setErrorIndex(a0: jint) throws -> Void {
        return try java$text$ParsePosition$.java$text$ParsePosition_setErrorIndex_I__V(jobj)(a0)
    }

    private static let java$text$ParsePosition_getErrorIndex__I = invoker("getErrorIndex", returns: jint.jniType)
    public func getErrorIndex() throws -> jint {
        return try java$text$ParsePosition$.java$text$ParsePosition_getErrorIndex__I(jobj)()
    }

    private static let java$text$ParsePosition_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$ParsePosition_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$ParsePosition_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$ParsePosition$ = java$text$ParsePosition

public class java$text$PatternEntry : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$PatternEntry_appendQuotedExtension_java$lang$StringBuffer__V = invoker("appendQuotedExtension", returns: JVoid.jniType, arguments: (JObjectType("java/lang/StringBuffer")))
    public func appendQuotedExtension(a0: java$lang$StringBuffer?) throws -> Void {
        return try java$text$PatternEntry$.java$text$PatternEntry_appendQuotedExtension_java$lang$StringBuffer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$PatternEntry_appendQuotedChars_java$lang$StringBuffer__V = invoker("appendQuotedChars", returns: JVoid.jniType, arguments: (JObjectType("java/lang/StringBuffer")))
    public func appendQuotedChars(a0: java$lang$StringBuffer?) throws -> Void {
        return try java$text$PatternEntry$.java$text$PatternEntry_appendQuotedChars_java$lang$StringBuffer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$PatternEntry_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$PatternEntry_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$PatternEntry_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$text$PatternEntry$ = java$text$PatternEntry

public final class java$text$RBCollationTables : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$RBCollationTables_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$text$RBCollationTables$.java$text$RBCollationTables_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$RBCollationTables_getRules__java$lang$String = invoker("getRules", returns: JObjectType("java/lang/String"))
    public func getRules() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$RBCollationTables$.java$text$RBCollationTables_getRules__java$lang$String(jobj)())
    }

    private static let java$text$RBCollationTables_isFrenchSec__Z = invoker("isFrenchSec", returns: jboolean.jniType)
    public func isFrenchSec() throws -> jboolean {
        return try java$text$RBCollationTables$.java$text$RBCollationTables_isFrenchSec__Z(jobj)()
    }

    private static let java$text$RBCollationTables_isSEAsianSwapping__Z = invoker("isSEAsianSwapping", returns: jboolean.jniType)
    public func isSEAsianSwapping() throws -> jboolean {
        return try java$text$RBCollationTables$.java$text$RBCollationTables_isSEAsianSwapping__Z(jobj)()
    }

}

public typealias java$text$RBCollationTables$ = java$text$RBCollationTables

public final class java$text$RBTableBuilder : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$RBTableBuilder_init_java$text$RBCollationTables$BuildAPI__V = constructor((JObjectType("java/text/RBCollationTables$BuildAPI")))
    public convenience init!(_ a0: java$text$RBCollationTables$BuildAPI?) throws {
        let jobj = try java$text$RBTableBuilder$.java$text$RBTableBuilder_init_java$text$RBCollationTables$BuildAPI__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$RBTableBuilder_build_java$lang$String_I__V = invoker("build", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func build(a0: java$lang$String?, _ a1: jint) throws -> Void {
        return try java$text$RBTableBuilder$.java$text$RBTableBuilder_build_java$lang$String_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

}

public typealias java$text$RBTableBuilder$ = java$text$RBTableBuilder

public final class java$text$RuleBasedCollationKey : java$text$CollationKey$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$RuleBasedCollationKey_compareTo_java$text$CollationKey__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/text/CollationKey")))
    private static let java$text$RuleBasedCollationKey_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$RuleBasedCollationKey_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$RuleBasedCollationKey_toByteArray__AB = invoker("toByteArray", returns: JArray(jbyte.jniType))
    private static let java$text$RuleBasedCollationKey_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$text$RuleBasedCollationKey$ = java$text$RuleBasedCollationKey

public class java$text$RuleBasedCollator : java$text$Collator$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$RuleBasedCollator_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$RuleBasedCollator$.java$text$RuleBasedCollator_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$RuleBasedCollator_getRules__java$lang$String = invoker("getRules", returns: JObjectType("java/lang/String"))
    public func getRules() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$RuleBasedCollator$.java$text$RuleBasedCollator_getRules__java$lang$String(jobj)())
    }

    private static let java$text$RuleBasedCollator_getCollationElementIterator_java$lang$String__java$text$CollationElementIterator = invoker("getCollationElementIterator", returns: JObjectType("java/text/CollationElementIterator"), arguments: (JObjectType("java/lang/String")))
    public func getCollationElementIterator(a0: java$lang$String?) throws -> java$text$CollationElementIterator? {
        return try java$text$CollationElementIterator$(jobj: java$text$RuleBasedCollator$.java$text$RuleBasedCollator_getCollationElementIterator_java$lang$String__java$text$CollationElementIterator(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$RuleBasedCollator_getCollationElementIterator_java$text$CharacterIterator__java$text$CollationElementIterator = invoker("getCollationElementIterator", returns: JObjectType("java/text/CollationElementIterator"), arguments: (JObjectType("java/text/CharacterIterator")))
    public func getCollationElementIterator(a0: java$text$CharacterIterator?) throws -> java$text$CollationElementIterator? {
        return try java$text$CollationElementIterator$(jobj: java$text$RuleBasedCollator$.java$text$RuleBasedCollator_getCollationElementIterator_java$text$CharacterIterator__java$text$CollationElementIterator(jobj)(a0?.jobj ?? nil))
    }

    private static let java$text$RuleBasedCollator_compare_java$lang$String_java$lang$String__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    private static let java$text$RuleBasedCollator_getCollationKey_java$lang$String__java$text$CollationKey = invoker("getCollationKey", returns: JObjectType("java/text/CollationKey"), arguments: (JObjectType("java/lang/String")))
    private static let java$text$RuleBasedCollator_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$RuleBasedCollator_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$RuleBasedCollator_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$text$RuleBasedCollator$ = java$text$RuleBasedCollator

public class java$text$SimpleDateFormat : java$text$DateFormat$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$SimpleDateFormat_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_init__V()
        self.init(jobj: jobj)
    }

    private static let java$text$SimpleDateFormat_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$SimpleDateFormat_init_java$lang$String_java$util$Locale__V = constructor((JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$util$Locale?) throws {
        let jobj = try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_init_java$lang$String_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$SimpleDateFormat_init_java$lang$String_java$text$DateFormatSymbols__V = constructor((JObjectType("java/lang/String"), JObjectType("java/text/DateFormatSymbols")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$text$DateFormatSymbols?) throws {
        let jobj = try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_init_java$lang$String_java$text$DateFormatSymbols__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$SimpleDateFormat_set2DigitYearStart_java$util$Date__V = invoker("set2DigitYearStart", returns: JVoid.jniType, arguments: (JObjectType("java/util/Date")))
    public func set2DigitYearStart(a0: java$util$Date?) throws -> Void {
        return try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_set2DigitYearStart_java$util$Date__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$SimpleDateFormat_get2DigitYearStart__java$util$Date = invoker("get2DigitYearStart", returns: JObjectType("java/util/Date"))
    public func get2DigitYearStart() throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$text$SimpleDateFormat$.java$text$SimpleDateFormat_get2DigitYearStart__java$util$Date(jobj)())
    }

    private static let java$text$SimpleDateFormat_format_java$util$Date_java$lang$StringBuffer_java$text$FieldPosition__java$lang$StringBuffer = invoker("format", returns: JObjectType("java/lang/StringBuffer"), arguments: (JObjectType("java/util/Date"), JObjectType("java/lang/StringBuffer"), JObjectType("java/text/FieldPosition")))
    private static let java$text$SimpleDateFormat_formatToCharacterIterator_java$lang$Object__java$text$AttributedCharacterIterator = invoker("formatToCharacterIterator", returns: JObjectType("java/text/AttributedCharacterIterator"), arguments: (JObjectType("java/lang/Object")))
    private static let java$text$SimpleDateFormat_parse_java$lang$String_java$text$ParsePosition__java$util$Date = invoker("parse", returns: JObjectType("java/util/Date"), arguments: (JObjectType("java/lang/String"), JObjectType("java/text/ParsePosition")))
    private static let java$text$SimpleDateFormat_toPattern__java$lang$String = invoker("toPattern", returns: JObjectType("java/lang/String"))
    public func toPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$SimpleDateFormat$.java$text$SimpleDateFormat_toPattern__java$lang$String(jobj)())
    }

    private static let java$text$SimpleDateFormat_toLocalizedPattern__java$lang$String = invoker("toLocalizedPattern", returns: JObjectType("java/lang/String"))
    public func toLocalizedPattern() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$text$SimpleDateFormat$.java$text$SimpleDateFormat_toLocalizedPattern__java$lang$String(jobj)())
    }

    private static let java$text$SimpleDateFormat_applyPattern_java$lang$String__V = invoker("applyPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_applyPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$SimpleDateFormat_applyLocalizedPattern_java$lang$String__V = invoker("applyLocalizedPattern", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func applyLocalizedPattern(a0: java$lang$String?) throws -> Void {
        return try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_applyLocalizedPattern_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$SimpleDateFormat_getDateFormatSymbols__java$text$DateFormatSymbols = invoker("getDateFormatSymbols", returns: JObjectType("java/text/DateFormatSymbols"))
    public func getDateFormatSymbols() throws -> java$text$DateFormatSymbols? {
        return try java$text$DateFormatSymbols$(jobj: java$text$SimpleDateFormat$.java$text$SimpleDateFormat_getDateFormatSymbols__java$text$DateFormatSymbols(jobj)())
    }

    private static let java$text$SimpleDateFormat_setDateFormatSymbols_java$text$DateFormatSymbols__V = invoker("setDateFormatSymbols", returns: JVoid.jniType, arguments: (JObjectType("java/text/DateFormatSymbols")))
    public func setDateFormatSymbols(a0: java$text$DateFormatSymbols?) throws -> Void {
        return try java$text$SimpleDateFormat$.java$text$SimpleDateFormat_setDateFormatSymbols_java$text$DateFormatSymbols__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$SimpleDateFormat_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$text$SimpleDateFormat_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$SimpleDateFormat_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$text$SimpleDateFormat$ = java$text$SimpleDateFormat

public final class java$text$StringCharacterIterator : java$lang$Object$, java$text$CharacterIterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$text$StringCharacterIterator_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$text$StringCharacterIterator_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$text$StringCharacterIterator_init_java$lang$String_I_I_I__V = constructor((JObjectType("java/lang/String"), jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint, _ a2: jint, _ a3: jint) throws {
        let jobj = try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_init_java$lang$String_I_I_I__V(a0?.jobj ?? nil, a1, a2, a3)
        self.init(jobj: jobj)
    }

    private static let java$text$StringCharacterIterator_setText_java$lang$String__V = invoker("setText", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setText(a0: java$lang$String?) throws -> Void {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_setText_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$text$StringCharacterIterator_first__C = invoker("first", returns: jchar.jniType)
    public func first() throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_first__C(jobj)()
    }

    private static let java$text$StringCharacterIterator_last__C = invoker("last", returns: jchar.jniType)
    public func last() throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_last__C(jobj)()
    }

    private static let java$text$StringCharacterIterator_setIndex_I__C = invoker("setIndex", returns: jchar.jniType, arguments: (jint.jniType))
    public func setIndex(a0: jint) throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_setIndex_I__C(jobj)(a0)
    }

    private static let java$text$StringCharacterIterator_current__C = invoker("current", returns: jchar.jniType)
    public func current() throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_current__C(jobj)()
    }

    private static let java$text$StringCharacterIterator_next__C = invoker("next", returns: jchar.jniType)
    public func next() throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_next__C(jobj)()
    }

    private static let java$text$StringCharacterIterator_previous__C = invoker("previous", returns: jchar.jniType)
    public func previous() throws -> jchar {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_previous__C(jobj)()
    }

    private static let java$text$StringCharacterIterator_getBeginIndex__I = invoker("getBeginIndex", returns: jint.jniType)
    public func getBeginIndex() throws -> jint {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_getBeginIndex__I(jobj)()
    }

    private static let java$text$StringCharacterIterator_getEndIndex__I = invoker("getEndIndex", returns: jint.jniType)
    public func getEndIndex() throws -> jint {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_getEndIndex__I(jobj)()
    }

    private static let java$text$StringCharacterIterator_getIndex__I = invoker("getIndex", returns: jint.jniType)
    public func getIndex() throws -> jint {
        return try java$text$StringCharacterIterator$.java$text$StringCharacterIterator_getIndex__I(jobj)()
    }

    private static let java$text$StringCharacterIterator_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$text$StringCharacterIterator_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$text$StringCharacterIterator_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$text$StringCharacterIterator$.java$text$StringCharacterIterator_clone__java$lang$Object(jobj)())
    }

}

public typealias java$text$StringCharacterIterator$ = java$text$StringCharacterIterator

public class java$util$AbstractCollection : java$lang$Object$, java$util$Collection {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractCollection_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    public func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$AbstractCollection$.java$util$AbstractCollection_iterator__java$util$Iterator(jobj)())
    }

    private static let java$util$AbstractCollection_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_size__I(jobj)()
    }

    private static let java$util$AbstractCollection_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_isEmpty__Z(jobj)()
    }

    private static let java$util$AbstractCollection_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    public func toArray() throws -> [java$lang$Object?]? {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_toArray__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$AbstractCollection_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    public func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]? {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_toArray_Ajava$lang$Object__Ajava$lang$Object(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$AbstractCollection_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_remove_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    public func containsAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_containsAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    public func addAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_addAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    public func removeAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_removeAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    public func retainAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_retainAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractCollection_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$util$AbstractCollection$.java$util$AbstractCollection_clear__V(jobj)()
    }

    private static let java$util$AbstractCollection_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$AbstractCollection$ = java$util$AbstractCollection

public class java$util$AbstractList : java$util$AbstractCollection$, java$util$List {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractList_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$AbstractList_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    public func get(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractList$.java$util$AbstractList_get_I__java$lang$Object(jobj)(a0))
    }

    private static let java$util$AbstractList_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public func set(a0: jint, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractList$.java$util$AbstractList_set_I_java$lang$Object__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    private static let java$util$AbstractList_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public func add(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$util$AbstractList$.java$util$AbstractList_add_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$util$AbstractList_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    public func remove(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractList$.java$util$AbstractList_remove_I__java$lang$Object(jobj)(a0))
    }

    private static let java$util$AbstractList_indexOf_java$lang$Object__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func indexOf(a0: java$lang$Object?) throws -> jint {
        return try java$util$AbstractList$.java$util$AbstractList_indexOf_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractList_lastIndexOf_java$lang$Object__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func lastIndexOf(a0: java$lang$Object?) throws -> jint {
        return try java$util$AbstractList$.java$util$AbstractList_lastIndexOf_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractList_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$AbstractList_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    public func addAll(a0: jint, _ a1: java$util$Collection?) throws -> jboolean {
        return try java$util$AbstractList$.java$util$AbstractList_addAll_I_java$util$Collection__Z(jobj)(a0, a1?.jobj ?? nil)
    }

    private static let java$util$AbstractList_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$AbstractList_listIterator__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"))
    public func listIterator() throws -> java$util$ListIterator? {
        return try java$util$ListIterator$(jobj: java$util$AbstractList$.java$util$AbstractList_listIterator__java$util$ListIterator(jobj)())
    }

    private static let java$util$AbstractList_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    public func listIterator(a0: jint) throws -> java$util$ListIterator? {
        return try java$util$ListIterator$(jobj: java$util$AbstractList$.java$util$AbstractList_listIterator_I__java$util$ListIterator(jobj)(a0))
    }

    private static let java$util$AbstractList_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
    public func subList(a0: jint, _ a1: jint) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$AbstractList$.java$util$AbstractList_subList_I_I__java$util$List(jobj)(a0, a1))
    }

    private static let java$util$AbstractList_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$AbstractList_hashCode__I = invoker("hashCode", returns: jint.jniType)
}

public typealias java$util$AbstractList$ = java$util$AbstractList

public class java$util$AbstractMap : java$lang$Object$, java$util$Map {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractMap_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$util$AbstractMap$.java$util$AbstractMap_size__I(jobj)()
    }

    private static let java$util$AbstractMap_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try java$util$AbstractMap$.java$util$AbstractMap_isEmpty__Z(jobj)()
    }

    private static let java$util$AbstractMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsValue(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$AbstractMap$.java$util$AbstractMap_containsValue_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsKey(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$AbstractMap$.java$util$AbstractMap_containsKey_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractMap$.java$util$AbstractMap_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$AbstractMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractMap$.java$util$AbstractMap_put_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$AbstractMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractMap$.java$util$AbstractMap_remove_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$AbstractMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    public func putAll(a0: java$util$Map?) throws -> Void {
        return try java$util$AbstractMap$.java$util$AbstractMap_putAll_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$AbstractMap_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$util$AbstractMap$.java$util$AbstractMap_clear__V(jobj)()
    }

    private static let java$util$AbstractMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    public func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$AbstractMap$.java$util$AbstractMap_keySet__java$util$Set(jobj)())
    }

    private static let java$util$AbstractMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    public func values() throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$AbstractMap$.java$util$AbstractMap_values__java$util$Collection(jobj)())
    }

    private static let java$util$AbstractMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    public func entrySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$AbstractMap$.java$util$AbstractMap_entrySet__java$util$Set(jobj)())
    }

    private static let java$util$AbstractMap_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$AbstractMap_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$AbstractMap_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$AbstractMap$ = java$util$AbstractMap

public class java$util$AbstractQueue : java$util$AbstractCollection$, java$util$Queue {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractQueue_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$AbstractQueue_remove__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"))
    public func remove() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractQueue$.java$util$AbstractQueue_remove__java$lang$Object(jobj)())
    }

    private static let java$util$AbstractQueue_element__java$lang$Object = invoker("element", returns: JObjectType("java/lang/Object"))
    public func element() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$AbstractQueue$.java$util$AbstractQueue_element__java$lang$Object(jobj)())
    }

    private static let java$util$AbstractQueue_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$AbstractQueue_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
}

public typealias java$util$AbstractQueue$ = java$util$AbstractQueue

public class java$util$AbstractSequentialList : java$util$AbstractList$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractSequentialList_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$AbstractSequentialList_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$AbstractSequentialList_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$AbstractSequentialList_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$AbstractSequentialList_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$AbstractSequentialList_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$AbstractSequentialList_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
}

public typealias java$util$AbstractSequentialList$ = java$util$AbstractSequentialList

public class java$util$AbstractSet : java$util$AbstractCollection$, java$util$Set {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$AbstractSet_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$AbstractSet_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$AbstractSet_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
}

public typealias java$util$AbstractSet$ = java$util$AbstractSet

public class java$util$ArrayDeque : java$util$AbstractCollection$, java$util$Deque, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ArrayDeque_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$ArrayDeque$.java$util$ArrayDeque_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayDeque_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$ArrayDeque$.java$util$ArrayDeque_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayDeque_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$ArrayDeque$.java$util$ArrayDeque_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayDeque_addFirst_java$lang$Object__V = invoker("addFirst", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func addFirst(a0: java$lang$Object?) throws -> Void {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_addFirst_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_addLast_java$lang$Object__V = invoker("addLast", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func addLast(a0: java$lang$Object?) throws -> Void {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_addLast_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_offerFirst_java$lang$Object__Z = invoker("offerFirst", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offerFirst(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_offerFirst_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_offerLast_java$lang$Object__Z = invoker("offerLast", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offerLast(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_offerLast_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_removeFirst__java$lang$Object = invoker("removeFirst", returns: JObjectType("java/lang/Object"))
    public func removeFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_removeFirst__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_removeLast__java$lang$Object = invoker("removeLast", returns: JObjectType("java/lang/Object"))
    public func removeLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_removeLast__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_pollFirst__java$lang$Object = invoker("pollFirst", returns: JObjectType("java/lang/Object"))
    public func pollFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_pollFirst__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_pollLast__java$lang$Object = invoker("pollLast", returns: JObjectType("java/lang/Object"))
    public func pollLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_pollLast__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_getFirst__java$lang$Object = invoker("getFirst", returns: JObjectType("java/lang/Object"))
    public func getFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_getFirst__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_getLast__java$lang$Object = invoker("getLast", returns: JObjectType("java/lang/Object"))
    public func getLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_getLast__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_peekFirst__java$lang$Object = invoker("peekFirst", returns: JObjectType("java/lang/Object"))
    public func peekFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_peekFirst__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_peekLast__java$lang$Object = invoker("peekLast", returns: JObjectType("java/lang/Object"))
    public func peekLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_peekLast__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_removeFirstOccurrence_java$lang$Object__Z = invoker("removeFirstOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func removeFirstOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_removeFirstOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_removeLastOccurrence_java$lang$Object__Z = invoker("removeLastOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func removeLastOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_removeLastOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayDeque_offer_java$lang$Object__Z = invoker("offer", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offer(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_offer_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_remove__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"))
    public func remove() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_remove__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_poll__java$lang$Object = invoker("poll", returns: JObjectType("java/lang/Object"))
    public func poll() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_poll__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_element__java$lang$Object = invoker("element", returns: JObjectType("java/lang/Object"))
    public func element() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_element__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
    public func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_peek__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_push_java$lang$Object__V = invoker("push", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func push(a0: java$lang$Object?) throws -> Void {
        return try java$util$ArrayDeque$.java$util$ArrayDeque_push_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayDeque_pop__java$lang$Object = invoker("pop", returns: JObjectType("java/lang/Object"))
    public func pop() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_pop__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayDeque_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$ArrayDeque_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$ArrayDeque_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$ArrayDeque_descendingIterator__java$util$Iterator = invoker("descendingIterator", returns: JObjectType("java/util/Iterator"))
    public func descendingIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_descendingIterator__java$util$Iterator(jobj)())
    }

    private static let java$util$ArrayDeque_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayDeque_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayDeque_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$ArrayDeque_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$ArrayDeque_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$ArrayDeque_clone__java$util$ArrayDeque = invoker("clone", returns: JObjectType("java/util/ArrayDeque"))
    public func clone() throws -> java$util$ArrayDeque? {
        return try java$util$ArrayDeque$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_clone__java$util$ArrayDeque(jobj)())
    }

    private static let java$util$ArrayDeque_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_spliterator__java$util$Spliterator(jobj)())
    }

    private static let java$util$ArrayDeque_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayDeque$.java$util$ArrayDeque_clone__java$lang$Object(jobj)())
    }

}

public typealias java$util$ArrayDeque$ = java$util$ArrayDeque

public class java$util$ArrayList : java$util$AbstractList$, java$util$RandomAccess, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ArrayList_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$ArrayList$.java$util$ArrayList_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayList_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$ArrayList$.java$util$ArrayList_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayList_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$ArrayList$.java$util$ArrayList_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$ArrayList_trimToSize__V = invoker("trimToSize", returns: JVoid.jniType)
    public func trimToSize() throws -> Void {
        return try java$util$ArrayList$.java$util$ArrayList_trimToSize__V(jobj)()
    }

    private static let java$util$ArrayList_ensureCapacity_I__V = invoker("ensureCapacity", returns: JVoid.jniType, arguments: (jint.jniType))
    public func ensureCapacity(a0: jint) throws -> Void {
        return try java$util$ArrayList$.java$util$ArrayList_ensureCapacity_I__V(jobj)(a0)
    }

    private static let java$util$ArrayList_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$ArrayList_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$ArrayList_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_indexOf_java$lang$Object__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_lastIndexOf_java$lang$Object__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ArrayList$.java$util$ArrayList_clone__java$lang$Object(jobj)())
    }

    private static let java$util$ArrayList_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$ArrayList_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$ArrayList_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$ArrayList_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ArrayList_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$ArrayList_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$ArrayList_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$ArrayList_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$ArrayList_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$ArrayList_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    private static let java$util$ArrayList_listIterator__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"))
    private static let java$util$ArrayList_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$ArrayList_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
    private static let java$util$ArrayList_forEach_java$util$function$Consumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    public func forEach(a0: java$util$function$Consumer?) throws -> Void {
        return try java$util$ArrayList$.java$util$ArrayList_forEach_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayList_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$ArrayList$.java$util$ArrayList_spliterator__java$util$Spliterator(jobj)())
    }

    private static let java$util$ArrayList_removeIf_java$util$function$Predicate__Z = invoker("removeIf", returns: jboolean.jniType, arguments: (JObjectType("java/util/function/Predicate")))
    public func removeIf(a0: java$util$function$Predicate?) throws -> jboolean {
        return try java$util$ArrayList$.java$util$ArrayList_removeIf_java$util$function$Predicate__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayList_replaceAll_java$util$function$UnaryOperator__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/UnaryOperator")))
    public func replaceAll(a0: java$util$function$UnaryOperator?) throws -> Void {
        return try java$util$ArrayList$.java$util$ArrayList_replaceAll_java$util$function$UnaryOperator__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ArrayList_sort_java$util$Comparator__V = invoker("sort", returns: JVoid.jniType, arguments: (JObjectType("java/util/Comparator")))
    public func sort(a0: java$util$Comparator?) throws -> Void {
        return try java$util$ArrayList$.java$util$ArrayList_sort_java$util$Comparator__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$ArrayList$ = java$util$ArrayList

public class java$util$ArrayPrefixHelpers : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$ArrayPrefixHelpers$ = java$util$ArrayPrefixHelpers

public class java$util$Arrays : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Arrays_sort_AI__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jint.jniType)))
    public static func sort(a0: [jint]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AI__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AI_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jint.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jint]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AI_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AJ__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jlong.jniType)))
    public static func sort(a0: [jlong]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AJ__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AJ_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jlong]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AJ_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AS__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jshort.jniType)))
    public static func sort(a0: [jshort]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AS__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AS_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jshort.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jshort]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AS_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AC__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public static func sort(a0: [jchar]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AC__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AC_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AC_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AB__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public static func sort(a0: [jbyte]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AB__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AB_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AB_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AF__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType)))
    public static func sort(a0: [jfloat]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AF__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AF_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jfloat]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AF_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_AD__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType)))
    public static func sort(a0: [jdouble]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AD__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_AD_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType))
    public static func sort(a0: [jdouble]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_AD_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AB__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public static func parallelSort(a0: [jbyte]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AB__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AB_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AB_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AC__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jchar.jniType)))
    public static func parallelSort(a0: [jchar]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AC__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AC_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AC_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AS__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jshort.jniType)))
    public static func parallelSort(a0: [jshort]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AS__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AS_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jshort.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jshort]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AS_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AI__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jint.jniType)))
    public static func parallelSort(a0: [jint]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AI__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AI_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jint.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jint]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AI_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AJ__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jlong.jniType)))
    public static func parallelSort(a0: [jlong]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AJ__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AJ_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jlong]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AJ_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AF__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType)))
    public static func parallelSort(a0: [jfloat]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AF__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AF_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jfloat]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AF_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_AD__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType)))
    public static func parallelSort(a0: [jdouble]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AD__V(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_AD_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [jdouble]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_AD_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_Ajava$lang$Comparable__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Comparable"))))
    public static func parallelSort(a0: [java$lang$Comparable?]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_Ajava$lang$Comparable__V(a0?.map({ java$lang$Comparable$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_parallelSort_Ajava$lang$Comparable_I_I__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Comparable")), jint.jniType, jint.jniType))
    public static func parallelSort(a0: [java$lang$Comparable?]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_Ajava$lang$Comparable_I_I__V(a0?.map({ java$lang$Comparable$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_parallelSort_Ajava$lang$Object_java$util$Comparator__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/util/Comparator")))
    public static func parallelSort(a0: [java$lang$Object?]?, _ a1: java$util$Comparator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_Ajava$lang$Object_java$util$Comparator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelSort_Ajava$lang$Object_I_I_java$util$Comparator__V = svoker("parallelSort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/util/Comparator")))
    public static func parallelSort(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$util$Comparator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSort_Ajava$lang$Object_I_I_java$util$Comparator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_sort_Ajava$lang$Object__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func sort(a0: [java$lang$Object?]?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_Ajava$lang$Object__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_sort_Ajava$lang$Object_I_I__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType))
    public static func sort(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_Ajava$lang$Object_I_I__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2)
    }

    private static let java$util$Arrays_sort_Ajava$lang$Object_java$util$Comparator__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/util/Comparator")))
    public static func sort(a0: [java$lang$Object?]?, _ a1: java$util$Comparator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_Ajava$lang$Object_java$util$Comparator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_sort_Ajava$lang$Object_I_I_java$util$Comparator__V = svoker("sort", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/util/Comparator")))
    public static func sort(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$util$Comparator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_sort_Ajava$lang$Object_I_I_java$util$Comparator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_Ajava$lang$Object_java$util$function$BinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/util/function/BinaryOperator")))
    public static func parallelPrefix(a0: [java$lang$Object?]?, _ a1: java$util$function$BinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_Ajava$lang$Object_java$util$function$BinaryOperator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_Ajava$lang$Object_I_I_java$util$function$BinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/util/function/BinaryOperator")))
    public static func parallelPrefix(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$util$function$BinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_Ajava$lang$Object_I_I_java$util$function$BinaryOperator__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AJ_java$util$function$LongBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), JObjectType("java/util/function/LongBinaryOperator")))
    public static func parallelPrefix(a0: [jlong]?, _ a1: java$util$function$LongBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AJ_java$util$function$LongBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AJ_I_I_java$util$function$LongBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType, JObjectType("java/util/function/LongBinaryOperator")))
    public static func parallelPrefix(a0: [jlong]?, _ a1: jint, _ a2: jint, _ a3: java$util$function$LongBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AJ_I_I_java$util$function$LongBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AD_java$util$function$DoubleBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), JObjectType("java/util/function/DoubleBinaryOperator")))
    public static func parallelPrefix(a0: [jdouble]?, _ a1: java$util$function$DoubleBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AD_java$util$function$DoubleBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AD_I_I_java$util$function$DoubleBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType, JObjectType("java/util/function/DoubleBinaryOperator")))
    public static func parallelPrefix(a0: [jdouble]?, _ a1: jint, _ a2: jint, _ a3: java$util$function$DoubleBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AD_I_I_java$util$function$DoubleBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AI_java$util$function$IntBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jint.jniType), JObjectType("java/util/function/IntBinaryOperator")))
    public static func parallelPrefix(a0: [jint]?, _ a1: java$util$function$IntBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AI_java$util$function$IntBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelPrefix_AI_I_I_java$util$function$IntBinaryOperator__V = svoker("parallelPrefix", returns: JVoid.jniType, arguments: (JArray(jint.jniType), jint.jniType, jint.jniType, JObjectType("java/util/function/IntBinaryOperator")))
    public static func parallelPrefix(a0: [jint]?, _ a1: jint, _ a2: jint, _ a3: java$util$function$IntBinaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelPrefix_AI_I_I_java$util$function$IntBinaryOperator__V(a0?.arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_binarySearch_AJ_J__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jlong.jniType), jlong.jniType))
    public static func binarySearch(a0: [jlong]?, _ a1: jlong) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AJ_J__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AJ_I_I_J__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType, jlong.jniType))
    public static func binarySearch(a0: [jlong]?, _ a1: jint, _ a2: jint, _ a3: jlong) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AJ_I_I_J__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AI_I__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jint.jniType), jint.jniType))
    public static func binarySearch(a0: [jint]?, _ a1: jint) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AI_I__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AI_I_I_I__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jint.jniType), jint.jniType, jint.jniType, jint.jniType))
    public static func binarySearch(a0: [jint]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AI_I_I_I__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AS_S__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jshort.jniType), jshort.jniType))
    public static func binarySearch(a0: [jshort]?, _ a1: jshort) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AS_S__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AS_I_I_S__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jshort.jniType), jint.jniType, jint.jniType, jshort.jniType))
    public static func binarySearch(a0: [jshort]?, _ a1: jint, _ a2: jint, _ a3: jshort) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AS_I_I_S__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AC_C__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jchar.jniType), jchar.jniType))
    public static func binarySearch(a0: [jchar]?, _ a1: jchar) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AC_C__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AC_I_I_C__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType, jchar.jniType))
    public static func binarySearch(a0: [jchar]?, _ a1: jint, _ a2: jint, _ a3: jchar) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AC_I_I_C__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AB_B__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jbyte.jniType))
    public static func binarySearch(a0: [jbyte]?, _ a1: jbyte) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AB_B__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AB_I_I_B__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType, jbyte.jniType))
    public static func binarySearch(a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: jbyte) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AB_I_I_B__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AD_D__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jdouble.jniType), jdouble.jniType))
    public static func binarySearch(a0: [jdouble]?, _ a1: jdouble) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AD_D__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AD_I_I_D__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType, jdouble.jniType))
    public static func binarySearch(a0: [jdouble]?, _ a1: jint, _ a2: jint, _ a3: jdouble) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AD_I_I_D__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_AF_F__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jfloat.jniType), jfloat.jniType))
    public static func binarySearch(a0: [jfloat]?, _ a1: jfloat) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AF_F__I(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_binarySearch_AF_I_I_F__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(jfloat.jniType), jint.jniType, jint.jniType, jfloat.jniType))
    public static func binarySearch(a0: [jfloat]?, _ a1: jint, _ a2: jint, _ a3: jfloat) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_AF_I_I_F__I(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_binarySearch_Ajava$lang$Object_java$lang$Object__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/lang/Object")))
    public static func binarySearch(a0: [java$lang$Object?]?, _ a1: java$lang$Object?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_Ajava$lang$Object_java$lang$Object__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_binarySearch_Ajava$lang$Object_I_I_java$lang$Object__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/lang/Object")))
    public static func binarySearch(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$lang$Object?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_Ajava$lang$Object_I_I_java$lang$Object__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_binarySearch_Ajava$lang$Object_java$lang$Object_java$util$Comparator__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/lang/Object"), JObjectType("java/util/Comparator")))
    public static func binarySearch(a0: [java$lang$Object?]?, _ a1: java$lang$Object?, _ a2: java$util$Comparator?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_Ajava$lang$Object_java$lang$Object_java$util$Comparator__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Arrays_binarySearch_Ajava$lang$Object_I_I_java$lang$Object_java$util$Comparator__I = svoker("binarySearch", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/lang/Object"), JObjectType("java/util/Comparator")))
    public static func binarySearch(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$lang$Object?, _ a4: java$util$Comparator?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_binarySearch_Ajava$lang$Object_I_I_java$lang$Object_java$util$Comparator__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil, a4?.jobj ?? nil)
    }

    private static let java$util$Arrays_equals_AJ_AJ__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jlong.jniType), JArray(jlong.jniType)))
    public static func equals(a0: [jlong]?, _ a1: [jlong]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AJ_AJ__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AI_AI__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jint.jniType), JArray(jint.jniType)))
    public static func equals(a0: [jint]?, _ a1: [jint]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AI_AI__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AS_AS__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jshort.jniType), JArray(jshort.jniType)))
    public static func equals(a0: [jshort]?, _ a1: [jshort]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AS_AS__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AC_AC__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jchar.jniType), JArray(jchar.jniType)))
    public static func equals(a0: [jchar]?, _ a1: [jchar]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AC_AC__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AB_AB__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jbyte.jniType), JArray(jbyte.jniType)))
    public static func equals(a0: [jbyte]?, _ a1: [jbyte]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AB_AB__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AZ_AZ__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jboolean.jniType), JArray(jboolean.jniType)))
    public static func equals(a0: [jboolean]?, _ a1: [jboolean]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AZ_AZ__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AD_AD__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jdouble.jniType), JArray(jdouble.jniType)))
    public static func equals(a0: [jdouble]?, _ a1: [jdouble]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AD_AD__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_AF_AF__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(jfloat.jniType), JArray(jfloat.jniType)))
    public static func equals(a0: [jfloat]?, _ a1: [jfloat]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_AF_AF__Z(a0?.arrayToJArray() ?? nil, a1?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_equals_Ajava$lang$Object_Ajava$lang$Object__Z = svoker("equals", returns: jboolean.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JArray(JObjectType("java/lang/Object"))))
    public static func equals(a0: [java$lang$Object?]?, _ a1: [java$lang$Object?]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_equals_Ajava$lang$Object_Ajava$lang$Object__Z(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_fill_AJ_J__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), jlong.jniType))
    public static func fill(a0: [jlong]?, _ a1: jlong) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AJ_J__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AJ_I_I_J__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType, jlong.jniType))
    public static func fill(a0: [jlong]?, _ a1: jint, _ a2: jint, _ a3: jlong) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AJ_I_I_J__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AI_I__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jint.jniType), jint.jniType))
    public static func fill(a0: [jint]?, _ a1: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AI_I__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AI_I_I_I__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jint.jniType), jint.jniType, jint.jniType, jint.jniType))
    public static func fill(a0: [jint]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AI_I_I_I__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AS_S__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jshort.jniType), jshort.jniType))
    public static func fill(a0: [jshort]?, _ a1: jshort) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AS_S__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AS_I_I_S__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jshort.jniType), jint.jniType, jint.jniType, jshort.jniType))
    public static func fill(a0: [jshort]?, _ a1: jint, _ a2: jint, _ a3: jshort) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AS_I_I_S__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AC_C__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jchar.jniType))
    public static func fill(a0: [jchar]?, _ a1: jchar) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AC_C__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AC_I_I_C__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType, jchar.jniType))
    public static func fill(a0: [jchar]?, _ a1: jint, _ a2: jint, _ a3: jchar) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AC_I_I_C__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AB_B__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jbyte.jniType))
    public static func fill(a0: [jbyte]?, _ a1: jbyte) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AB_B__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AB_I_I_B__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType, jbyte.jniType))
    public static func fill(a0: [jbyte]?, _ a1: jint, _ a2: jint, _ a3: jbyte) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AB_I_I_B__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AZ_Z__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jboolean.jniType), jboolean.jniType))
    public static func fill(a0: [jboolean]?, _ a1: jboolean) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AZ_Z__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AZ_I_I_Z__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jboolean.jniType), jint.jniType, jint.jniType, jboolean.jniType))
    public static func fill(a0: [jboolean]?, _ a1: jint, _ a2: jint, _ a3: jboolean) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AZ_I_I_Z__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AD_D__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), jdouble.jniType))
    public static func fill(a0: [jdouble]?, _ a1: jdouble) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AD_D__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AD_I_I_D__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType, jdouble.jniType))
    public static func fill(a0: [jdouble]?, _ a1: jint, _ a2: jint, _ a3: jdouble) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AD_I_I_D__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_AF_F__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType), jfloat.jniType))
    public static func fill(a0: [jfloat]?, _ a1: jfloat) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AF_F__V(a0?.arrayToJArray() ?? nil, a1)
    }

    private static let java$util$Arrays_fill_AF_I_I_F__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(jfloat.jniType), jint.jniType, jint.jniType, jfloat.jniType))
    public static func fill(a0: [jfloat]?, _ a1: jint, _ a2: jint, _ a3: jfloat) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_AF_I_I_F__V(a0?.arrayToJArray() ?? nil, a1, a2, a3)
    }

    private static let java$util$Arrays_fill_Ajava$lang$Object_java$lang$Object__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/lang/Object")))
    public static func fill(a0: [java$lang$Object?]?, _ a1: java$lang$Object?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_Ajava$lang$Object_java$lang$Object__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_fill_Ajava$lang$Object_I_I_java$lang$Object__V = svoker("fill", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/lang/Object")))
    public static func fill(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$lang$Object?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_fill_Ajava$lang$Object_I_I_java$lang$Object__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil)
    }

    private static let java$util$Arrays_copyOf_Ajava$lang$Object_I__Ajava$lang$Object = svoker("copyOf", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType))
    public static func copyOf(a0: [java$lang$Object?]?, _ a1: jint) throws -> [java$lang$Object?]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_Ajava$lang$Object_I__Ajava$lang$Object(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$Arrays_copyOf_Ajava$lang$Object_I_java$lang$Class__Ajava$lang$Object = svoker("copyOf", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, JObjectType("java/lang/Class")))
    public static func copyOf(a0: [java$lang$Object?]?, _ a1: jint, _ a2: java$lang$Class?) throws -> [java$lang$Object?]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_Ajava$lang$Object_I_java$lang$Class__Ajava$lang$Object(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2?.jobj ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$Arrays_copyOf_AB_I__AB = svoker("copyOf", returns: JArray(jbyte.jniType), arguments: (JArray(jbyte.jniType), jint.jniType))
    public static func copyOf(a0: [jbyte]?, _ a1: jint) throws -> [jbyte]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AB_I__AB(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AS_I__AS = svoker("copyOf", returns: JArray(jshort.jniType), arguments: (JArray(jshort.jniType), jint.jniType))
    public static func copyOf(a0: [jshort]?, _ a1: jint) throws -> [jshort]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AS_I__AS(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AI_I__AI = svoker("copyOf", returns: JArray(jint.jniType), arguments: (JArray(jint.jniType), jint.jniType))
    public static func copyOf(a0: [jint]?, _ a1: jint) throws -> [jint]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AI_I__AI(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AJ_I__AJ = svoker("copyOf", returns: JArray(jlong.jniType), arguments: (JArray(jlong.jniType), jint.jniType))
    public static func copyOf(a0: [jlong]?, _ a1: jint) throws -> [jlong]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AJ_I__AJ(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AC_I__AC = svoker("copyOf", returns: JArray(jchar.jniType), arguments: (JArray(jchar.jniType), jint.jniType))
    public static func copyOf(a0: [jchar]?, _ a1: jint) throws -> [jchar]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AC_I__AC(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AF_I__AF = svoker("copyOf", returns: JArray(jfloat.jniType), arguments: (JArray(jfloat.jniType), jint.jniType))
    public static func copyOf(a0: [jfloat]?, _ a1: jint) throws -> [jfloat]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AF_I__AF(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AD_I__AD = svoker("copyOf", returns: JArray(jdouble.jniType), arguments: (JArray(jdouble.jniType), jint.jniType))
    public static func copyOf(a0: [jdouble]?, _ a1: jint) throws -> [jdouble]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AD_I__AD(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOf_AZ_I__AZ = svoker("copyOf", returns: JArray(jboolean.jniType), arguments: (JArray(jboolean.jniType), jint.jniType))
    public static func copyOf(a0: [jboolean]?, _ a1: jint) throws -> [jboolean]? {
        return try java$util$Arrays$.java$util$Arrays_copyOf_AZ_I__AZ(a0?.arrayToJArray() ?? nil, a1).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_Ajava$lang$Object_I_I__Ajava$lang$Object = svoker("copyOfRange", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint) throws -> [java$lang$Object?]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_Ajava$lang$Object_I_I__Ajava$lang$Object(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$Arrays_copyOfRange_Ajava$lang$Object_I_I_java$lang$Class__Ajava$lang$Object = svoker("copyOfRange", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, JObjectType("java/lang/Class")))
    public static func copyOfRange(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: java$lang$Class?) throws -> [java$lang$Object?]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_Ajava$lang$Object_I_I_java$lang$Class__Ajava$lang$Object(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3?.jobj ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    private static let java$util$Arrays_copyOfRange_AB_I_I__AB = svoker("copyOfRange", returns: JArray(jbyte.jniType), arguments: (JArray(jbyte.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jbyte]?, _ a1: jint, _ a2: jint) throws -> [jbyte]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AB_I_I__AB(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AS_I_I__AS = svoker("copyOfRange", returns: JArray(jshort.jniType), arguments: (JArray(jshort.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jshort]?, _ a1: jint, _ a2: jint) throws -> [jshort]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AS_I_I__AS(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AI_I_I__AI = svoker("copyOfRange", returns: JArray(jint.jniType), arguments: (JArray(jint.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jint]?, _ a1: jint, _ a2: jint) throws -> [jint]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AI_I_I__AI(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AJ_I_I__AJ = svoker("copyOfRange", returns: JArray(jlong.jniType), arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jlong]?, _ a1: jint, _ a2: jint) throws -> [jlong]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AJ_I_I__AJ(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AC_I_I__AC = svoker("copyOfRange", returns: JArray(jchar.jniType), arguments: (JArray(jchar.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jchar]?, _ a1: jint, _ a2: jint) throws -> [jchar]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AC_I_I__AC(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AF_I_I__AF = svoker("copyOfRange", returns: JArray(jfloat.jniType), arguments: (JArray(jfloat.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jfloat]?, _ a1: jint, _ a2: jint) throws -> [jfloat]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AF_I_I__AF(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AD_I_I__AD = svoker("copyOfRange", returns: JArray(jdouble.jniType), arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jdouble]?, _ a1: jint, _ a2: jint) throws -> [jdouble]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AD_I_I__AD(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_copyOfRange_AZ_I_I__AZ = svoker("copyOfRange", returns: JArray(jboolean.jniType), arguments: (JArray(jboolean.jniType), jint.jniType, jint.jniType))
    public static func copyOfRange(a0: [jboolean]?, _ a1: jint, _ a2: jint) throws -> [jboolean]? {
        return try java$util$Arrays$.java$util$Arrays_copyOfRange_AZ_I_I__AZ(a0?.arrayToJArray() ?? nil, a1, a2).jarrayToArray()
    }

    private static let java$util$Arrays_asList_Ajava$lang$Object__java$util$List = svoker("asList", returns: JObjectType("java/util/List"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func asList(a0: [java$lang$Object?]?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Arrays$.java$util$Arrays_asList_Ajava$lang$Object__java$util$List(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_hashCode_AJ__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jlong.jniType)))
    public static func hashCode(a0: [jlong]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AJ__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AI__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jint.jniType)))
    public static func hashCode(a0: [jint]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AI__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AS__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jshort.jniType)))
    public static func hashCode(a0: [jshort]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AS__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AC__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jchar.jniType)))
    public static func hashCode(a0: [jchar]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AC__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AB__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jbyte.jniType)))
    public static func hashCode(a0: [jbyte]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AB__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AZ__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jboolean.jniType)))
    public static func hashCode(a0: [jboolean]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AZ__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AF__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jfloat.jniType)))
    public static func hashCode(a0: [jfloat]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AF__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_AD__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(jdouble.jniType)))
    public static func hashCode(a0: [jdouble]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_AD__I(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_hashCode_Ajava$lang$Object__I = svoker("hashCode", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func hashCode(a0: [java$lang$Object?]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_hashCode_Ajava$lang$Object__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_deepHashCode_Ajava$lang$Object__I = svoker("deepHashCode", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func deepHashCode(a0: [java$lang$Object?]?) throws -> jint {
        return try java$util$Arrays$.java$util$Arrays_deepHashCode_Ajava$lang$Object__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_deepEquals_Ajava$lang$Object_Ajava$lang$Object__Z = svoker("deepEquals", returns: jboolean.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JArray(JObjectType("java/lang/Object"))))
    public static func deepEquals(a0: [java$lang$Object?]?, _ a1: [java$lang$Object?]?) throws -> jboolean {
        return try java$util$Arrays$.java$util$Arrays_deepEquals_Ajava$lang$Object_Ajava$lang$Object__Z(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Arrays_toString_AJ__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jlong.jniType)))
    public static func toString(a0: [jlong]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AJ__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AI__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jint.jniType)))
    public static func toString(a0: [jint]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AI__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AS__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jshort.jniType)))
    public static func toString(a0: [jshort]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AS__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AC__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jchar.jniType)))
    public static func toString(a0: [jchar]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AC__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AB__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jbyte.jniType)))
    public static func toString(a0: [jbyte]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AB__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AZ__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jboolean.jniType)))
    public static func toString(a0: [jboolean]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AZ__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AF__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jfloat.jniType)))
    public static func toString(a0: [jfloat]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AF__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_AD__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(jdouble.jniType)))
    public static func toString(a0: [jdouble]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_AD__java$lang$String(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_toString_Ajava$lang$Object__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func toString(a0: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_toString_Ajava$lang$Object__java$lang$String(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_deepToString_Ajava$lang$Object__java$lang$String = svoker("deepToString", returns: JObjectType("java/lang/String"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func deepToString(a0: [java$lang$Object?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Arrays$.java$util$Arrays_deepToString_Ajava$lang$Object__java$lang$String(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_setAll_Ajava$lang$Object_java$util$function$IntFunction__V = svoker("setAll", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/util/function/IntFunction")))
    public static func setAll(a0: [java$lang$Object?]?, _ a1: java$util$function$IntFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_setAll_Ajava$lang$Object_java$util$function$IntFunction__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelSetAll_Ajava$lang$Object_java$util$function$IntFunction__V = svoker("parallelSetAll", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object")), JObjectType("java/util/function/IntFunction")))
    public static func parallelSetAll(a0: [java$lang$Object?]?, _ a1: java$util$function$IntFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSetAll_Ajava$lang$Object_java$util$function$IntFunction__V(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_setAll_AI_java$util$function$IntUnaryOperator__V = svoker("setAll", returns: JVoid.jniType, arguments: (JArray(jint.jniType), JObjectType("java/util/function/IntUnaryOperator")))
    public static func setAll(a0: [jint]?, _ a1: java$util$function$IntUnaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_setAll_AI_java$util$function$IntUnaryOperator__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelSetAll_AI_java$util$function$IntUnaryOperator__V = svoker("parallelSetAll", returns: JVoid.jniType, arguments: (JArray(jint.jniType), JObjectType("java/util/function/IntUnaryOperator")))
    public static func parallelSetAll(a0: [jint]?, _ a1: java$util$function$IntUnaryOperator?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSetAll_AI_java$util$function$IntUnaryOperator__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_setAll_AJ_java$util$function$IntToLongFunction__V = svoker("setAll", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), JObjectType("java/util/function/IntToLongFunction")))
    public static func setAll(a0: [jlong]?, _ a1: java$util$function$IntToLongFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_setAll_AJ_java$util$function$IntToLongFunction__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelSetAll_AJ_java$util$function$IntToLongFunction__V = svoker("parallelSetAll", returns: JVoid.jniType, arguments: (JArray(jlong.jniType), JObjectType("java/util/function/IntToLongFunction")))
    public static func parallelSetAll(a0: [jlong]?, _ a1: java$util$function$IntToLongFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSetAll_AJ_java$util$function$IntToLongFunction__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_setAll_AD_java$util$function$IntToDoubleFunction__V = svoker("setAll", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), JObjectType("java/util/function/IntToDoubleFunction")))
    public static func setAll(a0: [jdouble]?, _ a1: java$util$function$IntToDoubleFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_setAll_AD_java$util$function$IntToDoubleFunction__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_parallelSetAll_AD_java$util$function$IntToDoubleFunction__V = svoker("parallelSetAll", returns: JVoid.jniType, arguments: (JArray(jdouble.jniType), JObjectType("java/util/function/IntToDoubleFunction")))
    public static func parallelSetAll(a0: [jdouble]?, _ a1: java$util$function$IntToDoubleFunction?) throws -> Void {
        return try java$util$Arrays$.java$util$Arrays_parallelSetAll_AD_java$util$function$IntToDoubleFunction__V(a0?.arrayToJArray() ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Arrays_spliterator_Ajava$lang$Object__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func spliterator(a0: [java$lang$Object?]?) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_Ajava$lang$Object__java$util$Spliterator(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_spliterator_Ajava$lang$Object_I_I__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType))
    public static func spliterator(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_Ajava$lang$Object_I_I__java$util$Spliterator(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_spliterator_AI__java$util$Spliterator$OfInt = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JArray(jint.jniType)))
    public static func spliterator(a0: [jint]?) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AI__java$util$Spliterator$OfInt(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_spliterator_AI_I_I__java$util$Spliterator$OfInt = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JArray(jint.jniType), jint.jniType, jint.jniType))
    public static func spliterator(a0: [jint]?, _ a1: jint, _ a2: jint) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AI_I_I__java$util$Spliterator$OfInt(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_spliterator_AJ__java$util$Spliterator$OfLong = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JArray(jlong.jniType)))
    public static func spliterator(a0: [jlong]?) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AJ__java$util$Spliterator$OfLong(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_spliterator_AJ_I_I__java$util$Spliterator$OfLong = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType))
    public static func spliterator(a0: [jlong]?, _ a1: jint, _ a2: jint) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AJ_I_I__java$util$Spliterator$OfLong(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_spliterator_AD__java$util$Spliterator$OfDouble = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JArray(jdouble.jniType)))
    public static func spliterator(a0: [jdouble]?) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AD__java$util$Spliterator$OfDouble(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_spliterator_AD_I_I__java$util$Spliterator$OfDouble = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType))
    public static func spliterator(a0: [jdouble]?, _ a1: jint, _ a2: jint) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Arrays$.java$util$Arrays_spliterator_AD_I_I__java$util$Spliterator$OfDouble(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_stream_Ajava$lang$Object__java$util$stream$Stream = svoker("stream", returns: JObjectType("java/util/stream/Stream"), arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func stream(a0: [java$lang$Object?]?) throws -> java$util$stream$Stream? {
        return try java$util$stream$Stream$(jobj: java$util$Arrays$.java$util$Arrays_stream_Ajava$lang$Object__java$util$stream$Stream(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_stream_Ajava$lang$Object_I_I__java$util$stream$Stream = svoker("stream", returns: JObjectType("java/util/stream/Stream"), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType))
    public static func stream(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint) throws -> java$util$stream$Stream? {
        return try java$util$stream$Stream$(jobj: java$util$Arrays$.java$util$Arrays_stream_Ajava$lang$Object_I_I__java$util$stream$Stream(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_stream_AI__java$util$stream$IntStream = svoker("stream", returns: JObjectType("java/util/stream/IntStream"), arguments: (JArray(jint.jniType)))
    public static func stream(a0: [jint]?) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AI__java$util$stream$IntStream(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_stream_AI_I_I__java$util$stream$IntStream = svoker("stream", returns: JObjectType("java/util/stream/IntStream"), arguments: (JArray(jint.jniType), jint.jniType, jint.jniType))
    public static func stream(a0: [jint]?, _ a1: jint, _ a2: jint) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AI_I_I__java$util$stream$IntStream(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_stream_AJ__java$util$stream$LongStream = svoker("stream", returns: JObjectType("java/util/stream/LongStream"), arguments: (JArray(jlong.jniType)))
    public static func stream(a0: [jlong]?) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AJ__java$util$stream$LongStream(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_stream_AJ_I_I__java$util$stream$LongStream = svoker("stream", returns: JObjectType("java/util/stream/LongStream"), arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType))
    public static func stream(a0: [jlong]?, _ a1: jint, _ a2: jint) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AJ_I_I__java$util$stream$LongStream(a0?.arrayToJArray() ?? nil, a1, a2))
    }

    private static let java$util$Arrays_stream_AD__java$util$stream$DoubleStream = svoker("stream", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (JArray(jdouble.jniType)))
    public static func stream(a0: [jdouble]?) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AD__java$util$stream$DoubleStream(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$Arrays_stream_AD_I_I__java$util$stream$DoubleStream = svoker("stream", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType))
    public static func stream(a0: [jdouble]?, _ a1: jint, _ a2: jint) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Arrays$.java$util$Arrays_stream_AD_I_I__java$util$stream$DoubleStream(a0?.arrayToJArray() ?? nil, a1, a2))
    }

}

public typealias java$util$Arrays$ = java$util$Arrays

public class java$util$ArraysParallelSortHelpers : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$ArraysParallelSortHelpers$ = java$util$ArraysParallelSortHelpers

public class java$util$Base64 : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Base64_getEncoder__java$util$Base64$Encoder = svoker("getEncoder", returns: JObjectType("java/util/Base64$Encoder"))
    public static func getEncoder() throws -> java$util$Base64$Encoder? {
        return try java$util$Base64$Encoder$(jobj: java$util$Base64$.java$util$Base64_getEncoder__java$util$Base64$Encoder())
    }

    private static let java$util$Base64_getUrlEncoder__java$util$Base64$Encoder = svoker("getUrlEncoder", returns: JObjectType("java/util/Base64$Encoder"))
    public static func getUrlEncoder() throws -> java$util$Base64$Encoder? {
        return try java$util$Base64$Encoder$(jobj: java$util$Base64$.java$util$Base64_getUrlEncoder__java$util$Base64$Encoder())
    }

    private static let java$util$Base64_getMimeEncoder__java$util$Base64$Encoder = svoker("getMimeEncoder", returns: JObjectType("java/util/Base64$Encoder"))
    public static func getMimeEncoder() throws -> java$util$Base64$Encoder? {
        return try java$util$Base64$Encoder$(jobj: java$util$Base64$.java$util$Base64_getMimeEncoder__java$util$Base64$Encoder())
    }

    private static let java$util$Base64_getMimeEncoder_I_AB__java$util$Base64$Encoder = svoker("getMimeEncoder", returns: JObjectType("java/util/Base64$Encoder"), arguments: (jint.jniType, JArray(jbyte.jniType)))
    public static func getMimeEncoder(a0: jint, _ a1: [jbyte]?) throws -> java$util$Base64$Encoder? {
        return try java$util$Base64$Encoder$(jobj: java$util$Base64$.java$util$Base64_getMimeEncoder_I_AB__java$util$Base64$Encoder(a0, a1?.arrayToJArray() ?? nil))
    }

    private static let java$util$Base64_getDecoder__java$util$Base64$Decoder = svoker("getDecoder", returns: JObjectType("java/util/Base64$Decoder"))
    public static func getDecoder() throws -> java$util$Base64$Decoder? {
        return try java$util$Base64$Decoder$(jobj: java$util$Base64$.java$util$Base64_getDecoder__java$util$Base64$Decoder())
    }

    private static let java$util$Base64_getUrlDecoder__java$util$Base64$Decoder = svoker("getUrlDecoder", returns: JObjectType("java/util/Base64$Decoder"))
    public static func getUrlDecoder() throws -> java$util$Base64$Decoder? {
        return try java$util$Base64$Decoder$(jobj: java$util$Base64$.java$util$Base64_getUrlDecoder__java$util$Base64$Decoder())
    }

    private static let java$util$Base64_getMimeDecoder__java$util$Base64$Decoder = svoker("getMimeDecoder", returns: JObjectType("java/util/Base64$Decoder"))
    public static func getMimeDecoder() throws -> java$util$Base64$Decoder? {
        return try java$util$Base64$Decoder$(jobj: java$util$Base64$.java$util$Base64_getMimeDecoder__java$util$Base64$Decoder())
    }

}

public typealias java$util$Base64$ = java$util$Base64

public class java$util$BitSet : java$lang$Object$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$BitSet_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$BitSet$.java$util$BitSet_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$BitSet_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$BitSet$.java$util$BitSet_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$BitSet_valueOf_AJ__java$util$BitSet = svoker("valueOf", returns: JObjectType("java/util/BitSet"), arguments: (JArray(jlong.jniType)))
    public static func valueOf(a0: [jlong]?) throws -> java$util$BitSet? {
        return try java$util$BitSet$(jobj: java$util$BitSet$.java$util$BitSet_valueOf_AJ__java$util$BitSet(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$BitSet_valueOf_java$nio$LongBuffer__java$util$BitSet = svoker("valueOf", returns: JObjectType("java/util/BitSet"), arguments: (JObjectType("java/nio/LongBuffer")))
    public static func valueOf(a0: java$nio$LongBuffer?) throws -> java$util$BitSet? {
        return try java$util$BitSet$(jobj: java$util$BitSet$.java$util$BitSet_valueOf_java$nio$LongBuffer__java$util$BitSet(a0?.jobj ?? nil))
    }

    private static let java$util$BitSet_valueOf_AB__java$util$BitSet = svoker("valueOf", returns: JObjectType("java/util/BitSet"), arguments: (JArray(jbyte.jniType)))
    public static func valueOf(a0: [jbyte]?) throws -> java$util$BitSet? {
        return try java$util$BitSet$(jobj: java$util$BitSet$.java$util$BitSet_valueOf_AB__java$util$BitSet(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$BitSet_valueOf_java$nio$ByteBuffer__java$util$BitSet = svoker("valueOf", returns: JObjectType("java/util/BitSet"), arguments: (JObjectType("java/nio/ByteBuffer")))
    public static func valueOf(a0: java$nio$ByteBuffer?) throws -> java$util$BitSet? {
        return try java$util$BitSet$(jobj: java$util$BitSet$.java$util$BitSet_valueOf_java$nio$ByteBuffer__java$util$BitSet(a0?.jobj ?? nil))
    }

    private static let java$util$BitSet_toByteArray__AB = invoker("toByteArray", returns: JArray(jbyte.jniType))
    public func toByteArray() throws -> [jbyte]? {
        return try java$util$BitSet$.java$util$BitSet_toByteArray__AB(jobj)().jarrayToArray()
    }

    private static let java$util$BitSet_toLongArray__AJ = invoker("toLongArray", returns: JArray(jlong.jniType))
    public func toLongArray() throws -> [jlong]? {
        return try java$util$BitSet$.java$util$BitSet_toLongArray__AJ(jobj)().jarrayToArray()
    }

    private static let java$util$BitSet_flip_I__V = invoker("flip", returns: JVoid.jniType, arguments: (jint.jniType))
    public func flip(a0: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_flip_I__V(jobj)(a0)
    }

    private static let java$util$BitSet_flip_I_I__V = invoker("flip", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func flip(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_flip_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$BitSet_set_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType))
    public func set(a0: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_set_I__V(jobj)(a0)
    }

    private static let java$util$BitSet_set_I_Z__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    public func set(a0: jint, _ a1: jboolean) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_set_I_Z__V(jobj)(a0, a1)
    }

    private static let java$util$BitSet_set_I_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func set(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_set_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$BitSet_set_I_I_Z__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jboolean.jniType))
    public func set(a0: jint, _ a1: jint, _ a2: jboolean) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_set_I_I_Z__V(jobj)(a0, a1, a2)
    }

    private static let java$util$BitSet_clear_I__V = invoker("clear", returns: JVoid.jniType, arguments: (jint.jniType))
    public func clear(a0: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_clear_I__V(jobj)(a0)
    }

    private static let java$util$BitSet_clear_I_I__V = invoker("clear", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func clear(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_clear_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$BitSet_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_clear__V(jobj)()
    }

    private static let java$util$BitSet_get_I__Z = invoker("get", returns: jboolean.jniType, arguments: (jint.jniType))
    public func get(a0: jint) throws -> jboolean {
        return try java$util$BitSet$.java$util$BitSet_get_I__Z(jobj)(a0)
    }

    private static let java$util$BitSet_get_I_I__java$util$BitSet = invoker("get", returns: JObjectType("java/util/BitSet"), arguments: (jint.jniType, jint.jniType))
    public func get(a0: jint, _ a1: jint) throws -> java$util$BitSet? {
        return try java$util$BitSet$(jobj: java$util$BitSet$.java$util$BitSet_get_I_I__java$util$BitSet(jobj)(a0, a1))
    }

    private static let java$util$BitSet_nextSetBit_I__I = invoker("nextSetBit", returns: jint.jniType, arguments: (jint.jniType))
    public func nextSetBit(a0: jint) throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_nextSetBit_I__I(jobj)(a0)
    }

    private static let java$util$BitSet_nextClearBit_I__I = invoker("nextClearBit", returns: jint.jniType, arguments: (jint.jniType))
    public func nextClearBit(a0: jint) throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_nextClearBit_I__I(jobj)(a0)
    }

    private static let java$util$BitSet_previousSetBit_I__I = invoker("previousSetBit", returns: jint.jniType, arguments: (jint.jniType))
    public func previousSetBit(a0: jint) throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_previousSetBit_I__I(jobj)(a0)
    }

    private static let java$util$BitSet_previousClearBit_I__I = invoker("previousClearBit", returns: jint.jniType, arguments: (jint.jniType))
    public func previousClearBit(a0: jint) throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_previousClearBit_I__I(jobj)(a0)
    }

    private static let java$util$BitSet_length__I = invoker("length", returns: jint.jniType)
    public func length() throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_length__I(jobj)()
    }

    private static let java$util$BitSet_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try java$util$BitSet$.java$util$BitSet_isEmpty__Z(jobj)()
    }

    private static let java$util$BitSet_intersects_java$util$BitSet__Z = invoker("intersects", returns: jboolean.jniType, arguments: (JObjectType("java/util/BitSet")))
    public func intersects(a0: java$util$BitSet?) throws -> jboolean {
        return try java$util$BitSet$.java$util$BitSet_intersects_java$util$BitSet__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$BitSet_cardinality__I = invoker("cardinality", returns: jint.jniType)
    public func cardinality() throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_cardinality__I(jobj)()
    }

    private static let java$util$BitSet_and_java$util$BitSet__V = invoker("and", returns: JVoid.jniType, arguments: (JObjectType("java/util/BitSet")))
    public func and(a0: java$util$BitSet?) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_and_java$util$BitSet__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$BitSet_or_java$util$BitSet__V = invoker("or", returns: JVoid.jniType, arguments: (JObjectType("java/util/BitSet")))
    public func or(a0: java$util$BitSet?) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_or_java$util$BitSet__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$BitSet_xor_java$util$BitSet__V = invoker("xor", returns: JVoid.jniType, arguments: (JObjectType("java/util/BitSet")))
    public func xor(a0: java$util$BitSet?) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_xor_java$util$BitSet__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$BitSet_andNot_java$util$BitSet__V = invoker("andNot", returns: JVoid.jniType, arguments: (JObjectType("java/util/BitSet")))
    public func andNot(a0: java$util$BitSet?) throws -> Void {
        return try java$util$BitSet$.java$util$BitSet_andNot_java$util$BitSet__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$BitSet_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$BitSet_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$util$BitSet$.java$util$BitSet_size__I(jobj)()
    }

    private static let java$util$BitSet_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$BitSet_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$BitSet$.java$util$BitSet_clone__java$lang$Object(jobj)())
    }

    private static let java$util$BitSet_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$BitSet_stream__java$util$stream$IntStream = invoker("stream", returns: JObjectType("java/util/stream/IntStream"))
    public func stream() throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$BitSet$.java$util$BitSet_stream__java$util$stream$IntStream(jobj)())
    }

}

public typealias java$util$BitSet$ = java$util$BitSet

public class java$util$Calendar : java$lang$Object$, java$io$Serializable, java$lang$Cloneable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Calendar_getInstance__java$util$Calendar = svoker("getInstance", returns: JObjectType("java/util/Calendar"))
    public static func getInstance() throws -> java$util$Calendar? {
        return try java$util$Calendar$(jobj: java$util$Calendar$.java$util$Calendar_getInstance__java$util$Calendar())
    }

    private static let java$util$Calendar_getInstance_java$util$TimeZone__java$util$Calendar = svoker("getInstance", returns: JObjectType("java/util/Calendar"), arguments: (JObjectType("java/util/TimeZone")))
    public static func getInstance(a0: java$util$TimeZone?) throws -> java$util$Calendar? {
        return try java$util$Calendar$(jobj: java$util$Calendar$.java$util$Calendar_getInstance_java$util$TimeZone__java$util$Calendar(a0?.jobj ?? nil))
    }

    private static let java$util$Calendar_getInstance_java$util$Locale__java$util$Calendar = svoker("getInstance", returns: JObjectType("java/util/Calendar"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$util$Calendar? {
        return try java$util$Calendar$(jobj: java$util$Calendar$.java$util$Calendar_getInstance_java$util$Locale__java$util$Calendar(a0?.jobj ?? nil))
    }

    private static let java$util$Calendar_getInstance_java$util$TimeZone_java$util$Locale__java$util$Calendar = svoker("getInstance", returns: JObjectType("java/util/Calendar"), arguments: (JObjectType("java/util/TimeZone"), JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$TimeZone?, _ a1: java$util$Locale?) throws -> java$util$Calendar? {
        return try java$util$Calendar$(jobj: java$util$Calendar$.java$util$Calendar_getInstance_java$util$TimeZone_java$util$Locale__java$util$Calendar(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Calendar_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$util$Calendar$.java$util$Calendar_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$util$Calendar_getTime__java$util$Date = invoker("getTime", returns: JObjectType("java/util/Date"))
    public func getTime() throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$util$Calendar$.java$util$Calendar_getTime__java$util$Date(jobj)())
    }

    private static let java$util$Calendar_setTime_java$util$Date__V = invoker("setTime", returns: JVoid.jniType, arguments: (JObjectType("java/util/Date")))
    public func setTime(a0: java$util$Date?) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setTime_java$util$Date__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Calendar_getTimeInMillis__J = invoker("getTimeInMillis", returns: jlong.jniType)
    public func getTimeInMillis() throws -> jlong {
        return try java$util$Calendar$.java$util$Calendar_getTimeInMillis__J(jobj)()
    }

    private static let java$util$Calendar_setTimeInMillis_J__V = invoker("setTimeInMillis", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setTimeInMillis(a0: jlong) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setTimeInMillis_J__V(jobj)(a0)
    }

    private static let java$util$Calendar_get_I__I = invoker("get", returns: jint.jniType, arguments: (jint.jniType))
    public func get(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_get_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_set_I_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func set(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_set_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$Calendar_set_I_I_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func set(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_set_I_I_I__V(jobj)(a0, a1, a2)
    }

    private static let java$util$Calendar_set_I_I_I_I_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public func set(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_set_I_I_I_I_I__V(jobj)(a0, a1, a2, a3, a4)
    }

    private static let java$util$Calendar_set_I_I_I_I_I_I__V = invoker("set", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public func set(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_set_I_I_I_I_I_I__V(jobj)(a0, a1, a2, a3, a4, a5)
    }

    private static let java$util$Calendar_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_clear__V(jobj)()
    }

    private static let java$util$Calendar_clear_I__V = invoker("clear", returns: JVoid.jniType, arguments: (jint.jniType))
    public func clear(a0: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_clear_I__V(jobj)(a0)
    }

    private static let java$util$Calendar_isSet_I__Z = invoker("isSet", returns: jboolean.jniType, arguments: (jint.jniType))
    public func isSet(a0: jint) throws -> jboolean {
        return try java$util$Calendar$.java$util$Calendar_isSet_I__Z(jobj)(a0)
    }

    private static let java$util$Calendar_getDisplayName_I_I_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType, JObjectType("java/util/Locale")))
    public func getDisplayName(a0: jint, _ a1: jint, _ a2: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Calendar$.java$util$Calendar_getDisplayName_I_I_java$util$Locale__java$lang$String(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    private static let java$util$Calendar_getDisplayNames_I_I_java$util$Locale__java$util$Map = invoker("getDisplayNames", returns: JObjectType("java/util/Map"), arguments: (jint.jniType, jint.jniType, JObjectType("java/util/Locale")))
    public func getDisplayNames(a0: jint, _ a1: jint, _ a2: java$util$Locale?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Calendar$.java$util$Calendar_getDisplayNames_I_I_java$util$Locale__java$util$Map(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    private static let java$util$Calendar_getAvailableCalendarTypes__java$util$Set = svoker("getAvailableCalendarTypes", returns: JObjectType("java/util/Set"))
    public static func getAvailableCalendarTypes() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Calendar$.java$util$Calendar_getAvailableCalendarTypes__java$util$Set())
    }

    private static let java$util$Calendar_getCalendarType__java$lang$String = invoker("getCalendarType", returns: JObjectType("java/lang/String"))
    public func getCalendarType() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Calendar$.java$util$Calendar_getCalendarType__java$lang$String(jobj)())
    }

    private static let java$util$Calendar_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Calendar_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Calendar_before_java$lang$Object__Z = invoker("before", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func before(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Calendar$.java$util$Calendar_before_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Calendar_after_java$lang$Object__Z = invoker("after", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func after(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Calendar$.java$util$Calendar_after_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Calendar_compareTo_java$util$Calendar__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/util/Calendar")))
    public func compareTo(a0: java$util$Calendar?) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_compareTo_java$util$Calendar__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Calendar_add_I_I__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func add(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_add_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$Calendar_roll_I_Z__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    public func roll(a0: jint, _ a1: jboolean) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_roll_I_Z__V(jobj)(a0, a1)
    }

    private static let java$util$Calendar_roll_I_I__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    public func roll(a0: jint, _ a1: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_roll_I_I__V(jobj)(a0, a1)
    }

    private static let java$util$Calendar_setTimeZone_java$util$TimeZone__V = invoker("setTimeZone", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimeZone")))
    public func setTimeZone(a0: java$util$TimeZone?) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setTimeZone_java$util$TimeZone__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Calendar_getTimeZone__java$util$TimeZone = invoker("getTimeZone", returns: JObjectType("java/util/TimeZone"))
    public func getTimeZone() throws -> java$util$TimeZone? {
        return try java$util$TimeZone$(jobj: java$util$Calendar$.java$util$Calendar_getTimeZone__java$util$TimeZone(jobj)())
    }

    private static let java$util$Calendar_setLenient_Z__V = invoker("setLenient", returns: JVoid.jniType, arguments: (jboolean.jniType))
    public func setLenient(a0: jboolean) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setLenient_Z__V(jobj)(a0)
    }

    private static let java$util$Calendar_isLenient__Z = invoker("isLenient", returns: jboolean.jniType)
    public func isLenient() throws -> jboolean {
        return try java$util$Calendar$.java$util$Calendar_isLenient__Z(jobj)()
    }

    private static let java$util$Calendar_setFirstDayOfWeek_I__V = invoker("setFirstDayOfWeek", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setFirstDayOfWeek(a0: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setFirstDayOfWeek_I__V(jobj)(a0)
    }

    private static let java$util$Calendar_getFirstDayOfWeek__I = invoker("getFirstDayOfWeek", returns: jint.jniType)
    public func getFirstDayOfWeek() throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getFirstDayOfWeek__I(jobj)()
    }

    private static let java$util$Calendar_setMinimalDaysInFirstWeek_I__V = invoker("setMinimalDaysInFirstWeek", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMinimalDaysInFirstWeek(a0: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setMinimalDaysInFirstWeek_I__V(jobj)(a0)
    }

    private static let java$util$Calendar_getMinimalDaysInFirstWeek__I = invoker("getMinimalDaysInFirstWeek", returns: jint.jniType)
    public func getMinimalDaysInFirstWeek() throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getMinimalDaysInFirstWeek__I(jobj)()
    }

    private static let java$util$Calendar_isWeekDateSupported__Z = invoker("isWeekDateSupported", returns: jboolean.jniType)
    public func isWeekDateSupported() throws -> jboolean {
        return try java$util$Calendar$.java$util$Calendar_isWeekDateSupported__Z(jobj)()
    }

    private static let java$util$Calendar_getWeekYear__I = invoker("getWeekYear", returns: jint.jniType)
    public func getWeekYear() throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getWeekYear__I(jobj)()
    }

    private static let java$util$Calendar_setWeekDate_I_I_I__V = invoker("setWeekDate", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func setWeekDate(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Calendar$.java$util$Calendar_setWeekDate_I_I_I__V(jobj)(a0, a1, a2)
    }

    private static let java$util$Calendar_getWeeksInWeekYear__I = invoker("getWeeksInWeekYear", returns: jint.jniType)
    public func getWeeksInWeekYear() throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getWeeksInWeekYear__I(jobj)()
    }

    private static let java$util$Calendar_getMinimum_I__I = invoker("getMinimum", returns: jint.jniType, arguments: (jint.jniType))
    public func getMinimum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getMinimum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_getMaximum_I__I = invoker("getMaximum", returns: jint.jniType, arguments: (jint.jniType))
    public func getMaximum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getMaximum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_getGreatestMinimum_I__I = invoker("getGreatestMinimum", returns: jint.jniType, arguments: (jint.jniType))
    public func getGreatestMinimum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getGreatestMinimum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_getLeastMaximum_I__I = invoker("getLeastMaximum", returns: jint.jniType, arguments: (jint.jniType))
    public func getLeastMaximum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getLeastMaximum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_getActualMinimum_I__I = invoker("getActualMinimum", returns: jint.jniType, arguments: (jint.jniType))
    public func getActualMinimum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getActualMinimum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_getActualMaximum_I__I = invoker("getActualMaximum", returns: jint.jniType, arguments: (jint.jniType))
    public func getActualMaximum(a0: jint) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_getActualMaximum_I__I(jobj)(a0)
    }

    private static let java$util$Calendar_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Calendar$.java$util$Calendar_clone__java$lang$Object(jobj)())
    }

    private static let java$util$Calendar_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Calendar_toInstant__java$time$Instant = invoker("toInstant", returns: JObjectType("java/time/Instant"))
    public func toInstant() throws -> java$time$Instant? {
        return try java$time$Instant$(jobj: java$util$Calendar$.java$util$Calendar_toInstant__java$time$Instant(jobj)())
    }

    private static let java$util$Calendar_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$util$Calendar$.java$util$Calendar_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$Calendar$ = java$util$Calendar

public protocol java$util$Collection : java$lang$Iterable {
    func size() throws -> jint
    func isEmpty() throws -> jboolean
    func contains(a0: java$lang$Object?) throws -> jboolean
    func iterator() throws -> java$util$Iterator?
    func toArray() throws -> [java$lang$Object?]?
    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]?
    func add(a0: java$lang$Object?) throws -> jboolean
    func remove(a0: java$lang$Object?) throws -> jboolean
    func containsAll(a0: java$util$Collection?) throws -> jboolean
    func addAll(a0: java$util$Collection?) throws -> jboolean
    func removeAll(a0: java$util$Collection?) throws -> jboolean
    func removeIf(a0: java$util$function$Predicate?) throws -> jboolean
    func retainAll(a0: java$util$Collection?) throws -> jboolean
    func clear() throws -> Void
    func equals(a0: java$lang$Object?) throws -> jboolean
    func hashCode() throws -> jint
    func spliterator() throws -> java$util$Spliterator?
    func stream() throws -> java$util$stream$Stream?
    func parallelStream() throws -> java$util$stream$Stream?
}

public class java$util$Collection$ : java$lang$Object$, java$util$Collection, java$lang$Iterable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Collection_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Collection_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$Collection_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Collection_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$Collection_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$Collection_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$Collection_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Collection_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Collection_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Collection_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Collection_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Collection_removeIf_java$util$function$Predicate__Z = invoker("removeIf", returns: jboolean.jniType, arguments: (JObjectType("java/util/function/Predicate")))
    private static let java$util$Collection_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Collection_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$Collection_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Collection_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Collection_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    private static let java$util$Collection_stream__java$util$stream$Stream = invoker("stream", returns: JObjectType("java/util/stream/Stream"))
    private static let java$util$Collection_parallelStream__java$util$stream$Stream = invoker("parallelStream", returns: JObjectType("java/util/stream/Stream"))
}

public extension java$util$Collection {
    func size() throws -> jint {
        return try java$util$Collection$.java$util$Collection_size__I(jobj)()
    }

    func isEmpty() throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_isEmpty__Z(jobj)()
    }

    func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Collection$.java$util$Collection_iterator__java$util$Iterator(jobj)())
    }

    func toArray() throws -> [java$lang$Object?]? {
        return try java$util$Collection$.java$util$Collection_toArray__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]? {
        return try java$util$Collection$.java$util$Collection_toArray_Ajava$lang$Object__Ajava$lang$Object(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func remove(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_remove_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func containsAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_containsAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func addAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_addAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func removeAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_removeAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func removeIf(a0: java$util$function$Predicate?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_removeIf_java$util$function$Predicate__Z(jobj)(a0?.jobj ?? nil)
    }

    func retainAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_retainAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func clear() throws -> Void {
        return try java$util$Collection$.java$util$Collection_clear__V(jobj)()
    }

    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Collection$.java$util$Collection_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func hashCode() throws -> jint {
        return try java$util$Collection$.java$util$Collection_hashCode__I(jobj)()
    }

    func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Collection$.java$util$Collection_spliterator__java$util$Spliterator(jobj)())
    }

    func stream() throws -> java$util$stream$Stream? {
        return try java$util$stream$Stream$(jobj: java$util$Collection$.java$util$Collection_stream__java$util$stream$Stream(jobj)())
    }

    func parallelStream() throws -> java$util$stream$Stream? {
        return try java$util$stream$Stream$(jobj: java$util$Collection$.java$util$Collection_parallelStream__java$util$stream$Stream(jobj)())
    }

}

public class java$util$Collections : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Collections_sort_java$util$List__V = svoker("sort", returns: JVoid.jniType, arguments: (JObjectType("java/util/List")))
    public static func sort(a0: java$util$List?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_sort_java$util$List__V(a0?.jobj ?? nil)
    }

    private static let java$util$Collections_sort_java$util$List_java$util$Comparator__V = svoker("sort", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/util/Comparator")))
    public static func sort(a0: java$util$List?, _ a1: java$util$Comparator?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_sort_java$util$List_java$util$Comparator__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_binarySearch_java$util$List_java$lang$Object__I = svoker("binarySearch", returns: jint.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/lang/Object")))
    public static func binarySearch(a0: java$util$List?, _ a1: java$lang$Object?) throws -> jint {
        return try java$util$Collections$.java$util$Collections_binarySearch_java$util$List_java$lang$Object__I(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_binarySearch_java$util$List_java$lang$Object_java$util$Comparator__I = svoker("binarySearch", returns: jint.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/lang/Object"), JObjectType("java/util/Comparator")))
    public static func binarySearch(a0: java$util$List?, _ a1: java$lang$Object?, _ a2: java$util$Comparator?) throws -> jint {
        return try java$util$Collections$.java$util$Collections_binarySearch_java$util$List_java$lang$Object_java$util$Comparator__I(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Collections_reverse_java$util$List__V = svoker("reverse", returns: JVoid.jniType, arguments: (JObjectType("java/util/List")))
    public static func reverse(a0: java$util$List?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_reverse_java$util$List__V(a0?.jobj ?? nil)
    }

    private static let java$util$Collections_shuffle_java$util$List__V = svoker("shuffle", returns: JVoid.jniType, arguments: (JObjectType("java/util/List")))
    public static func shuffle(a0: java$util$List?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_shuffle_java$util$List__V(a0?.jobj ?? nil)
    }

    private static let java$util$Collections_shuffle_java$util$List_java$util$Random__V = svoker("shuffle", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/util/Random")))
    public static func shuffle(a0: java$util$List?, _ a1: java$util$Random?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_shuffle_java$util$List_java$util$Random__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_swap_java$util$List_I_I__V = svoker("swap", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), jint.jniType, jint.jniType))
    public static func swap(a0: java$util$List?, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$Collections$.java$util$Collections_swap_java$util$List_I_I__V(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$util$Collections_fill_java$util$List_java$lang$Object__V = svoker("fill", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/lang/Object")))
    public static func fill(a0: java$util$List?, _ a1: java$lang$Object?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_fill_java$util$List_java$lang$Object__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_copy_java$util$List_java$util$List__V = svoker("copy", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/util/List")))
    public static func copy(a0: java$util$List?, _ a1: java$util$List?) throws -> Void {
        return try java$util$Collections$.java$util$Collections_copy_java$util$List_java$util$List__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_min_java$util$Collection__java$lang$Object = svoker("min", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Collection")))
    public static func min(a0: java$util$Collection?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Collections$.java$util$Collections_min_java$util$Collection__java$lang$Object(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_min_java$util$Collection_java$util$Comparator__java$lang$Object = svoker("min", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Collection"), JObjectType("java/util/Comparator")))
    public static func min(a0: java$util$Collection?, _ a1: java$util$Comparator?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Collections$.java$util$Collections_min_java$util$Collection_java$util$Comparator__java$lang$Object(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_max_java$util$Collection__java$lang$Object = svoker("max", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Collection")))
    public static func max(a0: java$util$Collection?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Collections$.java$util$Collections_max_java$util$Collection__java$lang$Object(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_max_java$util$Collection_java$util$Comparator__java$lang$Object = svoker("max", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/Collection"), JObjectType("java/util/Comparator")))
    public static func max(a0: java$util$Collection?, _ a1: java$util$Comparator?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Collections$.java$util$Collections_max_java$util$Collection_java$util$Comparator__java$lang$Object(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_rotate_java$util$List_I__V = svoker("rotate", returns: JVoid.jniType, arguments: (JObjectType("java/util/List"), jint.jniType))
    public static func rotate(a0: java$util$List?, _ a1: jint) throws -> Void {
        return try java$util$Collections$.java$util$Collections_rotate_java$util$List_I__V(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Collections_replaceAll_java$util$List_java$lang$Object_java$lang$Object__Z = svoker("replaceAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public static func replaceAll(a0: java$util$List?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean {
        return try java$util$Collections$.java$util$Collections_replaceAll_java$util$List_java$lang$Object_java$lang$Object__Z(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Collections_indexOfSubList_java$util$List_java$util$List__I = svoker("indexOfSubList", returns: jint.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/util/List")))
    public static func indexOfSubList(a0: java$util$List?, _ a1: java$util$List?) throws -> jint {
        return try java$util$Collections$.java$util$Collections_indexOfSubList_java$util$List_java$util$List__I(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_lastIndexOfSubList_java$util$List_java$util$List__I = svoker("lastIndexOfSubList", returns: jint.jniType, arguments: (JObjectType("java/util/List"), JObjectType("java/util/List")))
    public static func lastIndexOfSubList(a0: java$util$List?, _ a1: java$util$List?) throws -> jint {
        return try java$util$Collections$.java$util$Collections_lastIndexOfSubList_java$util$List_java$util$List__I(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_unmodifiableCollection_java$util$Collection__java$util$Collection = svoker("unmodifiableCollection", returns: JObjectType("java/util/Collection"), arguments: (JObjectType("java/util/Collection")))
    public static func unmodifiableCollection(a0: java$util$Collection?) throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$Collections$.java$util$Collections_unmodifiableCollection_java$util$Collection__java$util$Collection(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableSet_java$util$Set__java$util$Set = svoker("unmodifiableSet", returns: JObjectType("java/util/Set"), arguments: (JObjectType("java/util/Set")))
    public static func unmodifiableSet(a0: java$util$Set?) throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_unmodifiableSet_java$util$Set__java$util$Set(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableSortedSet_java$util$SortedSet__java$util$SortedSet = svoker("unmodifiableSortedSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/util/SortedSet")))
    public static func unmodifiableSortedSet(a0: java$util$SortedSet?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$Collections$.java$util$Collections_unmodifiableSortedSet_java$util$SortedSet__java$util$SortedSet(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableNavigableSet_java$util$NavigableSet__java$util$NavigableSet = svoker("unmodifiableNavigableSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/util/NavigableSet")))
    public static func unmodifiableNavigableSet(a0: java$util$NavigableSet?) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$Collections$.java$util$Collections_unmodifiableNavigableSet_java$util$NavigableSet__java$util$NavigableSet(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableList_java$util$List__java$util$List = svoker("unmodifiableList", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List")))
    public static func unmodifiableList(a0: java$util$List?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_unmodifiableList_java$util$List__java$util$List(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableMap_java$util$Map__java$util$Map = svoker("unmodifiableMap", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/util/Map")))
    public static func unmodifiableMap(a0: java$util$Map?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Collections$.java$util$Collections_unmodifiableMap_java$util$Map__java$util$Map(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableSortedMap_java$util$SortedMap__java$util$SortedMap = svoker("unmodifiableSortedMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/util/SortedMap")))
    public static func unmodifiableSortedMap(a0: java$util$SortedMap?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$Collections$.java$util$Collections_unmodifiableSortedMap_java$util$SortedMap__java$util$SortedMap(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_unmodifiableNavigableMap_java$util$NavigableMap__java$util$NavigableMap = svoker("unmodifiableNavigableMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/util/NavigableMap")))
    public static func unmodifiableNavigableMap(a0: java$util$NavigableMap?) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$Collections$.java$util$Collections_unmodifiableNavigableMap_java$util$NavigableMap__java$util$NavigableMap(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedCollection_java$util$Collection__java$util$Collection = svoker("synchronizedCollection", returns: JObjectType("java/util/Collection"), arguments: (JObjectType("java/util/Collection")))
    public static func synchronizedCollection(a0: java$util$Collection?) throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$Collections$.java$util$Collections_synchronizedCollection_java$util$Collection__java$util$Collection(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedSet_java$util$Set__java$util$Set = svoker("synchronizedSet", returns: JObjectType("java/util/Set"), arguments: (JObjectType("java/util/Set")))
    public static func synchronizedSet(a0: java$util$Set?) throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_synchronizedSet_java$util$Set__java$util$Set(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedSortedSet_java$util$SortedSet__java$util$SortedSet = svoker("synchronizedSortedSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/util/SortedSet")))
    public static func synchronizedSortedSet(a0: java$util$SortedSet?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$Collections$.java$util$Collections_synchronizedSortedSet_java$util$SortedSet__java$util$SortedSet(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedNavigableSet_java$util$NavigableSet__java$util$NavigableSet = svoker("synchronizedNavigableSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/util/NavigableSet")))
    public static func synchronizedNavigableSet(a0: java$util$NavigableSet?) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$Collections$.java$util$Collections_synchronizedNavigableSet_java$util$NavigableSet__java$util$NavigableSet(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedList_java$util$List__java$util$List = svoker("synchronizedList", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List")))
    public static func synchronizedList(a0: java$util$List?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_synchronizedList_java$util$List__java$util$List(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedMap_java$util$Map__java$util$Map = svoker("synchronizedMap", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/util/Map")))
    public static func synchronizedMap(a0: java$util$Map?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Collections$.java$util$Collections_synchronizedMap_java$util$Map__java$util$Map(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedSortedMap_java$util$SortedMap__java$util$SortedMap = svoker("synchronizedSortedMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/util/SortedMap")))
    public static func synchronizedSortedMap(a0: java$util$SortedMap?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$Collections$.java$util$Collections_synchronizedSortedMap_java$util$SortedMap__java$util$SortedMap(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_synchronizedNavigableMap_java$util$NavigableMap__java$util$NavigableMap = svoker("synchronizedNavigableMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/util/NavigableMap")))
    public static func synchronizedNavigableMap(a0: java$util$NavigableMap?) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$Collections$.java$util$Collections_synchronizedNavigableMap_java$util$NavigableMap__java$util$NavigableMap(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedCollection_java$util$Collection_java$lang$Class__java$util$Collection = svoker("checkedCollection", returns: JObjectType("java/util/Collection"), arguments: (JObjectType("java/util/Collection"), JObjectType("java/lang/Class")))
    public static func checkedCollection(a0: java$util$Collection?, _ a1: java$lang$Class?) throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$Collections$.java$util$Collections_checkedCollection_java$util$Collection_java$lang$Class__java$util$Collection(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedQueue_java$util$Queue_java$lang$Class__java$util$Queue = svoker("checkedQueue", returns: JObjectType("java/util/Queue"), arguments: (JObjectType("java/util/Queue"), JObjectType("java/lang/Class")))
    public static func checkedQueue(a0: java$util$Queue?, _ a1: java$lang$Class?) throws -> java$util$Queue? {
        return try java$util$Queue$(jobj: java$util$Collections$.java$util$Collections_checkedQueue_java$util$Queue_java$lang$Class__java$util$Queue(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedSet_java$util$Set_java$lang$Class__java$util$Set = svoker("checkedSet", returns: JObjectType("java/util/Set"), arguments: (JObjectType("java/util/Set"), JObjectType("java/lang/Class")))
    public static func checkedSet(a0: java$util$Set?, _ a1: java$lang$Class?) throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_checkedSet_java$util$Set_java$lang$Class__java$util$Set(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedSortedSet_java$util$SortedSet_java$lang$Class__java$util$SortedSet = svoker("checkedSortedSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/util/SortedSet"), JObjectType("java/lang/Class")))
    public static func checkedSortedSet(a0: java$util$SortedSet?, _ a1: java$lang$Class?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$Collections$.java$util$Collections_checkedSortedSet_java$util$SortedSet_java$lang$Class__java$util$SortedSet(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedNavigableSet_java$util$NavigableSet_java$lang$Class__java$util$NavigableSet = svoker("checkedNavigableSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/util/NavigableSet"), JObjectType("java/lang/Class")))
    public static func checkedNavigableSet(a0: java$util$NavigableSet?, _ a1: java$lang$Class?) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$Collections$.java$util$Collections_checkedNavigableSet_java$util$NavigableSet_java$lang$Class__java$util$NavigableSet(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedList_java$util$List_java$lang$Class__java$util$List = svoker("checkedList", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List"), JObjectType("java/lang/Class")))
    public static func checkedList(a0: java$util$List?, _ a1: java$lang$Class?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_checkedList_java$util$List_java$lang$Class__java$util$List(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedMap_java$util$Map_java$lang$Class_java$lang$Class__java$util$Map = svoker("checkedMap", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/util/Map"), JObjectType("java/lang/Class"), JObjectType("java/lang/Class")))
    public static func checkedMap(a0: java$util$Map?, _ a1: java$lang$Class?, _ a2: java$lang$Class?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Collections$.java$util$Collections_checkedMap_java$util$Map_java$lang$Class_java$lang$Class__java$util$Map(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedSortedMap_java$util$SortedMap_java$lang$Class_java$lang$Class__java$util$SortedMap = svoker("checkedSortedMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/util/SortedMap"), JObjectType("java/lang/Class"), JObjectType("java/lang/Class")))
    public static func checkedSortedMap(a0: java$util$SortedMap?, _ a1: java$lang$Class?, _ a2: java$lang$Class?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$Collections$.java$util$Collections_checkedSortedMap_java$util$SortedMap_java$lang$Class_java$lang$Class__java$util$SortedMap(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$Collections_checkedNavigableMap_java$util$NavigableMap_java$lang$Class_java$lang$Class__java$util$NavigableMap = svoker("checkedNavigableMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/util/NavigableMap"), JObjectType("java/lang/Class"), JObjectType("java/lang/Class")))
    public static func checkedNavigableMap(a0: java$util$NavigableMap?, _ a1: java$lang$Class?, _ a2: java$lang$Class?) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$Collections$.java$util$Collections_checkedNavigableMap_java$util$NavigableMap_java$lang$Class_java$lang$Class__java$util$NavigableMap(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$Collections_emptyIterator__java$util$Iterator = svoker("emptyIterator", returns: JObjectType("java/util/Iterator"))
    public static func emptyIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Collections$.java$util$Collections_emptyIterator__java$util$Iterator())
    }

    private static let java$util$Collections_emptyListIterator__java$util$ListIterator = svoker("emptyListIterator", returns: JObjectType("java/util/ListIterator"))
    public static func emptyListIterator() throws -> java$util$ListIterator? {
        return try java$util$ListIterator$(jobj: java$util$Collections$.java$util$Collections_emptyListIterator__java$util$ListIterator())
    }

    private static let java$util$Collections_emptyEnumeration__java$util$Enumeration = svoker("emptyEnumeration", returns: JObjectType("java/util/Enumeration"))
    public static func emptyEnumeration() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Collections$.java$util$Collections_emptyEnumeration__java$util$Enumeration())
    }

    private static let java$util$Collections_emptySet__java$util$Set = svoker("emptySet", returns: JObjectType("java/util/Set"))
    public static func emptySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_emptySet__java$util$Set())
    }

    private static let java$util$Collections_emptySortedSet__java$util$SortedSet = svoker("emptySortedSet", returns: JObjectType("java/util/SortedSet"))
    public static func emptySortedSet() throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$Collections$.java$util$Collections_emptySortedSet__java$util$SortedSet())
    }

    private static let java$util$Collections_emptyNavigableSet__java$util$NavigableSet = svoker("emptyNavigableSet", returns: JObjectType("java/util/NavigableSet"))
    public static func emptyNavigableSet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$Collections$.java$util$Collections_emptyNavigableSet__java$util$NavigableSet())
    }

    private static let java$util$Collections_emptyList__java$util$List = svoker("emptyList", returns: JObjectType("java/util/List"))
    public static func emptyList() throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_emptyList__java$util$List())
    }

    private static let java$util$Collections_emptyMap__java$util$Map = svoker("emptyMap", returns: JObjectType("java/util/Map"))
    public static func emptyMap() throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Collections$.java$util$Collections_emptyMap__java$util$Map())
    }

    private static let java$util$Collections_emptySortedMap__java$util$SortedMap = svoker("emptySortedMap", returns: JObjectType("java/util/SortedMap"))
    public static func emptySortedMap() throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$Collections$.java$util$Collections_emptySortedMap__java$util$SortedMap())
    }

    private static let java$util$Collections_emptyNavigableMap__java$util$NavigableMap = svoker("emptyNavigableMap", returns: JObjectType("java/util/NavigableMap"))
    public static func emptyNavigableMap() throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$Collections$.java$util$Collections_emptyNavigableMap__java$util$NavigableMap())
    }

    private static let java$util$Collections_singleton_java$lang$Object__java$util$Set = svoker("singleton", returns: JObjectType("java/util/Set"), arguments: (JObjectType("java/lang/Object")))
    public static func singleton(a0: java$lang$Object?) throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_singleton_java$lang$Object__java$util$Set(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_singletonList_java$lang$Object__java$util$List = svoker("singletonList", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/lang/Object")))
    public static func singletonList(a0: java$lang$Object?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_singletonList_java$lang$Object__java$util$List(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_singletonMap_java$lang$Object_java$lang$Object__java$util$Map = svoker("singletonMap", returns: JObjectType("java/util/Map"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public static func singletonMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$Map? {
        return try java$util$Map$(jobj: java$util$Collections$.java$util$Collections_singletonMap_java$lang$Object_java$lang$Object__java$util$Map(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_nCopies_I_java$lang$Object__java$util$List = svoker("nCopies", returns: JObjectType("java/util/List"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    public static func nCopies(a0: jint, _ a1: java$lang$Object?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Collections$.java$util$Collections_nCopies_I_java$lang$Object__java$util$List(a0, a1?.jobj ?? nil))
    }

    private static let java$util$Collections_reverseOrder__java$util$Comparator = svoker("reverseOrder", returns: JObjectType("java/util/Comparator"))
    public static func reverseOrder() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Collections$.java$util$Collections_reverseOrder__java$util$Comparator())
    }

    private static let java$util$Collections_reverseOrder_java$util$Comparator__java$util$Comparator = svoker("reverseOrder", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/Comparator")))
    public static func reverseOrder(a0: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Collections$.java$util$Collections_reverseOrder_java$util$Comparator__java$util$Comparator(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_enumeration_java$util$Collection__java$util$Enumeration = svoker("enumeration", returns: JObjectType("java/util/Enumeration"), arguments: (JObjectType("java/util/Collection")))
    public static func enumeration(a0: java$util$Collection?) throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Collections$.java$util$Collections_enumeration_java$util$Collection__java$util$Enumeration(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_list_java$util$Enumeration__java$util$ArrayList = svoker("list", returns: JObjectType("java/util/ArrayList"), arguments: (JObjectType("java/util/Enumeration")))
    public static func list(a0: java$util$Enumeration?) throws -> java$util$ArrayList? {
        return try java$util$ArrayList$(jobj: java$util$Collections$.java$util$Collections_list_java$util$Enumeration__java$util$ArrayList(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_frequency_java$util$Collection_java$lang$Object__I = svoker("frequency", returns: jint.jniType, arguments: (JObjectType("java/util/Collection"), JObjectType("java/lang/Object")))
    public static func frequency(a0: java$util$Collection?, _ a1: java$lang$Object?) throws -> jint {
        return try java$util$Collections$.java$util$Collections_frequency_java$util$Collection_java$lang$Object__I(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_disjoint_java$util$Collection_java$util$Collection__Z = svoker("disjoint", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection"), JObjectType("java/util/Collection")))
    public static func disjoint(a0: java$util$Collection?, _ a1: java$util$Collection?) throws -> jboolean {
        return try java$util$Collections$.java$util$Collections_disjoint_java$util$Collection_java$util$Collection__Z(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Collections_addAll_java$util$Collection_Ajava$lang$Object__Z = svoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection"), JArray(JObjectType("java/lang/Object"))))
    public static func addAll(a0: java$util$Collection?, _ a1: [java$lang$Object?]?) throws -> jboolean {
        return try java$util$Collections$.java$util$Collections_addAll_java$util$Collection_Ajava$lang$Object__Z(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Collections_newSetFromMap_java$util$Map__java$util$Set = svoker("newSetFromMap", returns: JObjectType("java/util/Set"), arguments: (JObjectType("java/util/Map")))
    public static func newSetFromMap(a0: java$util$Map?) throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Collections$.java$util$Collections_newSetFromMap_java$util$Map__java$util$Set(a0?.jobj ?? nil))
    }

    private static let java$util$Collections_asLifoQueue_java$util$Deque__java$util$Queue = svoker("asLifoQueue", returns: JObjectType("java/util/Queue"), arguments: (JObjectType("java/util/Deque")))
    public static func asLifoQueue(a0: java$util$Deque?) throws -> java$util$Queue? {
        return try java$util$Queue$(jobj: java$util$Collections$.java$util$Collections_asLifoQueue_java$util$Deque__java$util$Queue(a0?.jobj ?? nil))
    }

}

public typealias java$util$Collections$ = java$util$Collections

public class java$util$ComparableTimSort : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$ComparableTimSort$ = java$util$ComparableTimSort

public protocol java$util$Comparator : JavaObject {
    func compare(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jint
    func equals(a0: java$lang$Object?) throws -> jboolean
    func reversed() throws -> java$util$Comparator?
    func thenComparing(a0: java$util$Comparator?) throws -> java$util$Comparator?
    func thenComparing(a0: java$util$function$Function?, _ a1: java$util$Comparator?) throws -> java$util$Comparator?
    func thenComparing(a0: java$util$function$Function?) throws -> java$util$Comparator?
    func thenComparingInt(a0: java$util$function$ToIntFunction?) throws -> java$util$Comparator?
    func thenComparingLong(a0: java$util$function$ToLongFunction?) throws -> java$util$Comparator?
    func thenComparingDouble(a0: java$util$function$ToDoubleFunction?) throws -> java$util$Comparator?
    static func reverseOrder() throws -> java$util$Comparator?
    static func naturalOrder() throws -> java$util$Comparator?
    static func nullsFirst(a0: java$util$Comparator?) throws -> java$util$Comparator?
    static func nullsLast(a0: java$util$Comparator?) throws -> java$util$Comparator?
    static func comparing(a0: java$util$function$Function?, _ a1: java$util$Comparator?) throws -> java$util$Comparator?
    static func comparing(a0: java$util$function$Function?) throws -> java$util$Comparator?
    static func comparingInt(a0: java$util$function$ToIntFunction?) throws -> java$util$Comparator?
    static func comparingLong(a0: java$util$function$ToLongFunction?) throws -> java$util$Comparator?
    static func comparingDouble(a0: java$util$function$ToDoubleFunction?) throws -> java$util$Comparator?
}

public class java$util$Comparator$ : java$lang$Object$, java$util$Comparator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Comparator_compare_java$lang$Object_java$lang$Object__I = invoker("compare", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Comparator_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Comparator_reversed__java$util$Comparator = invoker("reversed", returns: JObjectType("java/util/Comparator"))
    private static let java$util$Comparator_thenComparing_java$util$Comparator__java$util$Comparator = invoker("thenComparing", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/Comparator")))
    private static let java$util$Comparator_thenComparing_java$util$function$Function_java$util$Comparator__java$util$Comparator = invoker("thenComparing", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/Function"), JObjectType("java/util/Comparator")))
    private static let java$util$Comparator_thenComparing_java$util$function$Function__java$util$Comparator = invoker("thenComparing", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/Function")))
    private static let java$util$Comparator_thenComparingInt_java$util$function$ToIntFunction__java$util$Comparator = invoker("thenComparingInt", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToIntFunction")))
    private static let java$util$Comparator_thenComparingLong_java$util$function$ToLongFunction__java$util$Comparator = invoker("thenComparingLong", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToLongFunction")))
    private static let java$util$Comparator_thenComparingDouble_java$util$function$ToDoubleFunction__java$util$Comparator = invoker("thenComparingDouble", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToDoubleFunction")))
    private static let java$util$Comparator_reverseOrder__java$util$Comparator = svoker("reverseOrder", returns: JObjectType("java/util/Comparator"))
    private static let java$util$Comparator_naturalOrder__java$util$Comparator = svoker("naturalOrder", returns: JObjectType("java/util/Comparator"))
    private static let java$util$Comparator_nullsFirst_java$util$Comparator__java$util$Comparator = svoker("nullsFirst", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/Comparator")))
    private static let java$util$Comparator_nullsLast_java$util$Comparator__java$util$Comparator = svoker("nullsLast", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/Comparator")))
    private static let java$util$Comparator_comparing_java$util$function$Function_java$util$Comparator__java$util$Comparator = svoker("comparing", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/Function"), JObjectType("java/util/Comparator")))
    private static let java$util$Comparator_comparing_java$util$function$Function__java$util$Comparator = svoker("comparing", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/Function")))
    private static let java$util$Comparator_comparingInt_java$util$function$ToIntFunction__java$util$Comparator = svoker("comparingInt", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToIntFunction")))
    private static let java$util$Comparator_comparingLong_java$util$function$ToLongFunction__java$util$Comparator = svoker("comparingLong", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToLongFunction")))
    private static let java$util$Comparator_comparingDouble_java$util$function$ToDoubleFunction__java$util$Comparator = svoker("comparingDouble", returns: JObjectType("java/util/Comparator"), arguments: (JObjectType("java/util/function/ToDoubleFunction")))
}

public extension java$util$Comparator {
    func compare(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jint {
        return try java$util$Comparator$.java$util$Comparator_compare_java$lang$Object_java$lang$Object__I(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Comparator$.java$util$Comparator_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func reversed() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_reversed__java$util$Comparator(jobj)())
    }

    func thenComparing(a0: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparing_java$util$Comparator__java$util$Comparator(jobj)(a0?.jobj ?? nil))
    }

    func thenComparing(a0: java$util$function$Function?, _ a1: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparing_java$util$function$Function_java$util$Comparator__java$util$Comparator(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func thenComparing(a0: java$util$function$Function?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparing_java$util$function$Function__java$util$Comparator(jobj)(a0?.jobj ?? nil))
    }

    func thenComparingInt(a0: java$util$function$ToIntFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparingInt_java$util$function$ToIntFunction__java$util$Comparator(jobj)(a0?.jobj ?? nil))
    }

    func thenComparingLong(a0: java$util$function$ToLongFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparingLong_java$util$function$ToLongFunction__java$util$Comparator(jobj)(a0?.jobj ?? nil))
    }

    func thenComparingDouble(a0: java$util$function$ToDoubleFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_thenComparingDouble_java$util$function$ToDoubleFunction__java$util$Comparator(jobj)(a0?.jobj ?? nil))
    }

    static func reverseOrder() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_reverseOrder__java$util$Comparator())
    }

    static func naturalOrder() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_naturalOrder__java$util$Comparator())
    }

    static func nullsFirst(a0: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_nullsFirst_java$util$Comparator__java$util$Comparator(a0?.jobj ?? nil))
    }

    static func nullsLast(a0: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_nullsLast_java$util$Comparator__java$util$Comparator(a0?.jobj ?? nil))
    }

    static func comparing(a0: java$util$function$Function?, _ a1: java$util$Comparator?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_comparing_java$util$function$Function_java$util$Comparator__java$util$Comparator(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    static func comparing(a0: java$util$function$Function?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_comparing_java$util$function$Function__java$util$Comparator(a0?.jobj ?? nil))
    }

    static func comparingInt(a0: java$util$function$ToIntFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_comparingInt_java$util$function$ToIntFunction__java$util$Comparator(a0?.jobj ?? nil))
    }

    static func comparingLong(a0: java$util$function$ToLongFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_comparingLong_java$util$function$ToLongFunction__java$util$Comparator(a0?.jobj ?? nil))
    }

    static func comparingDouble(a0: java$util$function$ToDoubleFunction?) throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Comparator$.java$util$Comparator_comparingDouble_java$util$function$ToDoubleFunction__java$util$Comparator(a0?.jobj ?? nil))
    }

}

public class java$util$Comparators : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$Comparators$ = java$util$Comparators

public class java$util$ConcurrentModificationException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ConcurrentModificationException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$ConcurrentModificationException$.java$util$ConcurrentModificationException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$ConcurrentModificationException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$ConcurrentModificationException$.java$util$ConcurrentModificationException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$ConcurrentModificationException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$util$ConcurrentModificationException$.java$util$ConcurrentModificationException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$ConcurrentModificationException_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$util$ConcurrentModificationException$.java$util$ConcurrentModificationException_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$ConcurrentModificationException$ = java$util$ConcurrentModificationException

public final class java$util$Currency : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Currency_getInstance_java$lang$String__java$util$Currency = svoker("getInstance", returns: JObjectType("java/util/Currency"), arguments: (JObjectType("java/lang/String")))
    public static func getInstance(a0: java$lang$String?) throws -> java$util$Currency? {
        return try java$util$Currency$(jobj: java$util$Currency$.java$util$Currency_getInstance_java$lang$String__java$util$Currency(a0?.jobj ?? nil))
    }

    private static let java$util$Currency_getInstance_java$util$Locale__java$util$Currency = svoker("getInstance", returns: JObjectType("java/util/Currency"), arguments: (JObjectType("java/util/Locale")))
    public static func getInstance(a0: java$util$Locale?) throws -> java$util$Currency? {
        return try java$util$Currency$(jobj: java$util$Currency$.java$util$Currency_getInstance_java$util$Locale__java$util$Currency(a0?.jobj ?? nil))
    }

    private static let java$util$Currency_getAvailableCurrencies__java$util$Set = svoker("getAvailableCurrencies", returns: JObjectType("java/util/Set"))
    public static func getAvailableCurrencies() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Currency$.java$util$Currency_getAvailableCurrencies__java$util$Set())
    }

    private static let java$util$Currency_getCurrencyCode__java$lang$String = invoker("getCurrencyCode", returns: JObjectType("java/lang/String"))
    public func getCurrencyCode() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Currency$.java$util$Currency_getCurrencyCode__java$lang$String(jobj)())
    }

    private static let java$util$Currency_getSymbol__java$lang$String = invoker("getSymbol", returns: JObjectType("java/lang/String"))
    public func getSymbol() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Currency$.java$util$Currency_getSymbol__java$lang$String(jobj)())
    }

    private static let java$util$Currency_getSymbol_java$util$Locale__java$lang$String = invoker("getSymbol", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getSymbol(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Currency$.java$util$Currency_getSymbol_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Currency_getDefaultFractionDigits__I = invoker("getDefaultFractionDigits", returns: jint.jniType)
    public func getDefaultFractionDigits() throws -> jint {
        return try java$util$Currency$.java$util$Currency_getDefaultFractionDigits__I(jobj)()
    }

    private static let java$util$Currency_getNumericCode__I = invoker("getNumericCode", returns: jint.jniType)
    public func getNumericCode() throws -> jint {
        return try java$util$Currency$.java$util$Currency_getNumericCode__I(jobj)()
    }

    private static let java$util$Currency_getDisplayName__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"))
    public func getDisplayName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Currency$.java$util$Currency_getDisplayName__java$lang$String(jobj)())
    }

    private static let java$util$Currency_getDisplayName_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayName(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Currency$.java$util$Currency_getDisplayName_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Currency_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$Currency$ = java$util$Currency

public class java$util$Date : java$lang$Object$, java$io$Serializable, java$lang$Cloneable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Date_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Date$.java$util$Date_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Date_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$util$Date$.java$util$Date_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$Date_init_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$util$Date$.java$util$Date_init_I_I_I__V(a0, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$util$Date_init_I_I_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint) throws {
        let jobj = try java$util$Date$.java$util$Date_init_I_I_I_I_I__V(a0, a1, a2, a3, a4)
        self.init(jobj: jobj)
    }

    private static let java$util$Date_init_I_I_I_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint) throws {
        let jobj = try java$util$Date$.java$util$Date_init_I_I_I_I_I_I__V(a0, a1, a2, a3, a4, a5)
        self.init(jobj: jobj)
    }

    private static let java$util$Date_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$Date$.java$util$Date_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Date_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Date$.java$util$Date_clone__java$lang$Object(jobj)())
    }

    private static let java$util$Date_UTC_I_I_I_I_I_I__J = svoker("UTC", returns: jlong.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public static func UTC(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint) throws -> jlong {
        return try java$util$Date$.java$util$Date_UTC_I_I_I_I_I_I__J(a0, a1, a2, a3, a4, a5)
    }

    private static let java$util$Date_parse_java$lang$String__J = svoker("parse", returns: jlong.jniType, arguments: (JObjectType("java/lang/String")))
    public static func parse(a0: java$lang$String?) throws -> jlong {
        return try java$util$Date$.java$util$Date_parse_java$lang$String__J(a0?.jobj ?? nil)
    }

    private static let java$util$Date_getYear__I = invoker("getYear", returns: jint.jniType)
    public func getYear() throws -> jint {
        return try java$util$Date$.java$util$Date_getYear__I(jobj)()
    }

    private static let java$util$Date_setYear_I__V = invoker("setYear", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setYear(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setYear_I__V(jobj)(a0)
    }

    private static let java$util$Date_getMonth__I = invoker("getMonth", returns: jint.jniType)
    public func getMonth() throws -> jint {
        return try java$util$Date$.java$util$Date_getMonth__I(jobj)()
    }

    private static let java$util$Date_setMonth_I__V = invoker("setMonth", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMonth(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setMonth_I__V(jobj)(a0)
    }

    private static let java$util$Date_getDate__I = invoker("getDate", returns: jint.jniType)
    public func getDate() throws -> jint {
        return try java$util$Date$.java$util$Date_getDate__I(jobj)()
    }

    private static let java$util$Date_setDate_I__V = invoker("setDate", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setDate(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setDate_I__V(jobj)(a0)
    }

    private static let java$util$Date_getDay__I = invoker("getDay", returns: jint.jniType)
    public func getDay() throws -> jint {
        return try java$util$Date$.java$util$Date_getDay__I(jobj)()
    }

    private static let java$util$Date_getHours__I = invoker("getHours", returns: jint.jniType)
    public func getHours() throws -> jint {
        return try java$util$Date$.java$util$Date_getHours__I(jobj)()
    }

    private static let java$util$Date_setHours_I__V = invoker("setHours", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setHours(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setHours_I__V(jobj)(a0)
    }

    private static let java$util$Date_getMinutes__I = invoker("getMinutes", returns: jint.jniType)
    public func getMinutes() throws -> jint {
        return try java$util$Date$.java$util$Date_getMinutes__I(jobj)()
    }

    private static let java$util$Date_setMinutes_I__V = invoker("setMinutes", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setMinutes(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setMinutes_I__V(jobj)(a0)
    }

    private static let java$util$Date_getSeconds__I = invoker("getSeconds", returns: jint.jniType)
    public func getSeconds() throws -> jint {
        return try java$util$Date$.java$util$Date_getSeconds__I(jobj)()
    }

    private static let java$util$Date_setSeconds_I__V = invoker("setSeconds", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSeconds(a0: jint) throws -> Void {
        return try java$util$Date$.java$util$Date_setSeconds_I__V(jobj)(a0)
    }

    private static let java$util$Date_getTime__J = invoker("getTime", returns: jlong.jniType)
    public func getTime() throws -> jlong {
        return try java$util$Date$.java$util$Date_getTime__J(jobj)()
    }

    private static let java$util$Date_setTime_J__V = invoker("setTime", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setTime(a0: jlong) throws -> Void {
        return try java$util$Date$.java$util$Date_setTime_J__V(jobj)(a0)
    }

    private static let java$util$Date_before_java$util$Date__Z = invoker("before", returns: jboolean.jniType, arguments: (JObjectType("java/util/Date")))
    public func before(a0: java$util$Date?) throws -> jboolean {
        return try java$util$Date$.java$util$Date_before_java$util$Date__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Date_after_java$util$Date__Z = invoker("after", returns: jboolean.jniType, arguments: (JObjectType("java/util/Date")))
    public func after(a0: java$util$Date?) throws -> jboolean {
        return try java$util$Date$.java$util$Date_after_java$util$Date__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Date_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Date_compareTo_java$util$Date__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/util/Date")))
    public func compareTo(a0: java$util$Date?) throws -> jint {
        return try java$util$Date$.java$util$Date_compareTo_java$util$Date__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Date_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Date_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Date_toLocaleString__java$lang$String = invoker("toLocaleString", returns: JObjectType("java/lang/String"))
    public func toLocaleString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Date$.java$util$Date_toLocaleString__java$lang$String(jobj)())
    }

    private static let java$util$Date_toGMTString__java$lang$String = invoker("toGMTString", returns: JObjectType("java/lang/String"))
    public func toGMTString() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Date$.java$util$Date_toGMTString__java$lang$String(jobj)())
    }

    private static let java$util$Date_getTimezoneOffset__I = invoker("getTimezoneOffset", returns: jint.jniType)
    public func getTimezoneOffset() throws -> jint {
        return try java$util$Date$.java$util$Date_getTimezoneOffset__I(jobj)()
    }

    private static let java$util$Date_from_java$time$Instant__java$util$Date = svoker("from", returns: JObjectType("java/util/Date"), arguments: (JObjectType("java/time/Instant")))
    public static func from(a0: java$time$Instant?) throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$util$Date$.java$util$Date_from_java$time$Instant__java$util$Date(a0?.jobj ?? nil))
    }

    private static let java$util$Date_toInstant__java$time$Instant = invoker("toInstant", returns: JObjectType("java/time/Instant"))
    public func toInstant() throws -> java$time$Instant? {
        return try java$time$Instant$(jobj: java$util$Date$.java$util$Date_toInstant__java$time$Instant(jobj)())
    }

    private static let java$util$Date_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$util$Date$.java$util$Date_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$Date$ = java$util$Date

public protocol java$util$Deque : java$util$Queue {
    func addFirst(a0: java$lang$Object?) throws -> Void
    func addLast(a0: java$lang$Object?) throws -> Void
    func offerFirst(a0: java$lang$Object?) throws -> jboolean
    func offerLast(a0: java$lang$Object?) throws -> jboolean
    func removeFirst() throws -> java$lang$Object?
    func removeLast() throws -> java$lang$Object?
    func pollFirst() throws -> java$lang$Object?
    func pollLast() throws -> java$lang$Object?
    func getFirst() throws -> java$lang$Object?
    func getLast() throws -> java$lang$Object?
    func peekFirst() throws -> java$lang$Object?
    func peekLast() throws -> java$lang$Object?
    func removeFirstOccurrence(a0: java$lang$Object?) throws -> jboolean
    func removeLastOccurrence(a0: java$lang$Object?) throws -> jboolean
    func add(a0: java$lang$Object?) throws -> jboolean
    func offer(a0: java$lang$Object?) throws -> jboolean
    func remove() throws -> java$lang$Object?
    func poll() throws -> java$lang$Object?
    func element() throws -> java$lang$Object?
    func peek() throws -> java$lang$Object?
    func push(a0: java$lang$Object?) throws -> Void
    func pop() throws -> java$lang$Object?
    func remove(a0: java$lang$Object?) throws -> jboolean
    func contains(a0: java$lang$Object?) throws -> jboolean
    func size() throws -> jint
    func iterator() throws -> java$util$Iterator?
    func descendingIterator() throws -> java$util$Iterator?
}

public class java$util$Deque$ : java$lang$Object$, java$util$Deque, java$util$Queue {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Deque_addFirst_java$lang$Object__V = invoker("addFirst", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_addLast_java$lang$Object__V = invoker("addLast", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_offerFirst_java$lang$Object__Z = invoker("offerFirst", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_offerLast_java$lang$Object__Z = invoker("offerLast", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_removeFirst__java$lang$Object = invoker("removeFirst", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_removeLast__java$lang$Object = invoker("removeLast", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_pollFirst__java$lang$Object = invoker("pollFirst", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_pollLast__java$lang$Object = invoker("pollLast", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_getFirst__java$lang$Object = invoker("getFirst", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_getLast__java$lang$Object = invoker("getLast", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_peekFirst__java$lang$Object = invoker("peekFirst", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_peekLast__java$lang$Object = invoker("peekLast", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_removeFirstOccurrence_java$lang$Object__Z = invoker("removeFirstOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_removeLastOccurrence_java$lang$Object__Z = invoker("removeLastOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_offer_java$lang$Object__Z = invoker("offer", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_remove__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_poll__java$lang$Object = invoker("poll", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_element__java$lang$Object = invoker("element", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_push_java$lang$Object__V = invoker("push", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_pop__java$lang$Object = invoker("pop", returns: JObjectType("java/lang/Object"))
    private static let java$util$Deque_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Deque_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Deque_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$Deque_descendingIterator__java$util$Iterator = invoker("descendingIterator", returns: JObjectType("java/util/Iterator"))
}

public extension java$util$Deque {
    func addFirst(a0: java$lang$Object?) throws -> Void {
        return try java$util$Deque$.java$util$Deque_addFirst_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    func addLast(a0: java$lang$Object?) throws -> Void {
        return try java$util$Deque$.java$util$Deque_addLast_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    func offerFirst(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_offerFirst_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func offerLast(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_offerLast_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func removeFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_removeFirst__java$lang$Object(jobj)())
    }

    func removeLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_removeLast__java$lang$Object(jobj)())
    }

    func pollFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_pollFirst__java$lang$Object(jobj)())
    }

    func pollLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_pollLast__java$lang$Object(jobj)())
    }

    func getFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_getFirst__java$lang$Object(jobj)())
    }

    func getLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_getLast__java$lang$Object(jobj)())
    }

    func peekFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_peekFirst__java$lang$Object(jobj)())
    }

    func peekLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_peekLast__java$lang$Object(jobj)())
    }

    func removeFirstOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_removeFirstOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func removeLastOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_removeLastOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func offer(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_offer_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func remove() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_remove__java$lang$Object(jobj)())
    }

    func poll() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_poll__java$lang$Object(jobj)())
    }

    func element() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_element__java$lang$Object(jobj)())
    }

    func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_peek__java$lang$Object(jobj)())
    }

    func push(a0: java$lang$Object?) throws -> Void {
        return try java$util$Deque$.java$util$Deque_push_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    func pop() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Deque$.java$util$Deque_pop__java$lang$Object(jobj)())
    }

    func remove(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_remove_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Deque$.java$util$Deque_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func size() throws -> jint {
        return try java$util$Deque$.java$util$Deque_size__I(jobj)()
    }

    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Deque$.java$util$Deque_iterator__java$util$Iterator(jobj)())
    }

    func descendingIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Deque$.java$util$Deque_descendingIterator__java$util$Iterator(jobj)())
    }

}

public class java$util$Dictionary : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Dictionary_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Dictionary$.java$util$Dictionary_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Dictionary_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try java$util$Dictionary$.java$util$Dictionary_size__I(jobj)()
    }

    private static let java$util$Dictionary_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try java$util$Dictionary$.java$util$Dictionary_isEmpty__Z(jobj)()
    }

    private static let java$util$Dictionary_keys__java$util$Enumeration = invoker("keys", returns: JObjectType("java/util/Enumeration"))
    public func keys() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Dictionary$.java$util$Dictionary_keys__java$util$Enumeration(jobj)())
    }

    private static let java$util$Dictionary_elements__java$util$Enumeration = invoker("elements", returns: JObjectType("java/util/Enumeration"))
    public func elements() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Dictionary$.java$util$Dictionary_elements__java$util$Enumeration(jobj)())
    }

    private static let java$util$Dictionary_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Dictionary$.java$util$Dictionary_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Dictionary_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Dictionary$.java$util$Dictionary_put_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Dictionary_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Dictionary$.java$util$Dictionary_remove_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

}

public typealias java$util$Dictionary$ = java$util$Dictionary

public class java$util$DoubleSummaryStatistics : java$lang$Object$, java$util$function$DoubleConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$DoubleSummaryStatistics_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$DoubleSummaryStatistics_accept_D__V = invoker("accept", returns: JVoid.jniType, arguments: (jdouble.jniType))
    public func accept(a0: jdouble) throws -> Void {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_accept_D__V(jobj)(a0)
    }

    private static let java$util$DoubleSummaryStatistics_combine_java$util$DoubleSummaryStatistics__V = invoker("combine", returns: JVoid.jniType, arguments: (JObjectType("java/util/DoubleSummaryStatistics")))
    public func combine(a0: java$util$DoubleSummaryStatistics?) throws -> Void {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_combine_java$util$DoubleSummaryStatistics__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$DoubleSummaryStatistics_getCount__J = invoker("getCount", returns: jlong.jniType)
    public func getCount() throws -> jlong {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_getCount__J(jobj)()
    }

    private static let java$util$DoubleSummaryStatistics_getSum__D = invoker("getSum", returns: jdouble.jniType)
    public func getSum() throws -> jdouble {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_getSum__D(jobj)()
    }

    private static let java$util$DoubleSummaryStatistics_getMin__D = invoker("getMin", returns: jdouble.jniType)
    public func getMin() throws -> jdouble {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_getMin__D(jobj)()
    }

    private static let java$util$DoubleSummaryStatistics_getMax__D = invoker("getMax", returns: jdouble.jniType)
    public func getMax() throws -> jdouble {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_getMax__D(jobj)()
    }

    private static let java$util$DoubleSummaryStatistics_getAverage__D = invoker("getAverage", returns: jdouble.jniType)
    public func getAverage() throws -> jdouble {
        return try java$util$DoubleSummaryStatistics$.java$util$DoubleSummaryStatistics_getAverage__D(jobj)()
    }

    private static let java$util$DoubleSummaryStatistics_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$DoubleSummaryStatistics$ = java$util$DoubleSummaryStatistics

public final class java$util$DualPivotQuicksort : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$DualPivotQuicksort$ = java$util$DualPivotQuicksort

public class java$util$DuplicateFormatFlagsException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$DuplicateFormatFlagsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$DuplicateFormatFlagsException$.java$util$DuplicateFormatFlagsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$DuplicateFormatFlagsException_getFlags__java$lang$String = invoker("getFlags", returns: JObjectType("java/lang/String"))
    public func getFlags() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$DuplicateFormatFlagsException$.java$util$DuplicateFormatFlagsException_getFlags__java$lang$String(jobj)())
    }

    private static let java$util$DuplicateFormatFlagsException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$DuplicateFormatFlagsException$ = java$util$DuplicateFormatFlagsException

public class java$util$EmptyStackException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$EmptyStackException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$EmptyStackException$.java$util$EmptyStackException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$util$EmptyStackException$ = java$util$EmptyStackException

public class java$util$EnumMap : java$util$AbstractMap$, java$io$Serializable, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$EnumMap_init_java$lang$Class__V = constructor((JObjectType("java/lang/Class")))
    public convenience init!(_ a0: java$lang$Class?) throws {
        let jobj = try java$util$EnumMap$.java$util$EnumMap_init_java$lang$Class__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$EnumMap_init_java$util$EnumMap__V = constructor((JObjectType("java/util/EnumMap")))
    public convenience init!(_ a0: java$util$EnumMap?) throws {
        let jobj = try java$util$EnumMap$.java$util$EnumMap_init_java$util$EnumMap__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$EnumMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$EnumMap$.java$util$EnumMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$EnumMap_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$EnumMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$EnumMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$EnumMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$EnumMap_put_java$lang$Enum_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$Enum?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$EnumMap$.java$util$EnumMap_put_java$lang$Enum_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$EnumMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$EnumMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$EnumMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$EnumMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$EnumMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$EnumMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$EnumMap_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$EnumMap_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$EnumMap_clone__java$util$EnumMap = invoker("clone", returns: JObjectType("java/util/EnumMap"))
    public func clone() throws -> java$util$EnumMap? {
        return try java$util$EnumMap$(jobj: java$util$EnumMap$.java$util$EnumMap_clone__java$util$EnumMap(jobj)())
    }

    private static let java$util$EnumMap_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$EnumMap$.java$util$EnumMap_clone__java$lang$Object(jobj)())
    }

    private static let java$util$EnumMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
}

public typealias java$util$EnumMap$ = java$util$EnumMap

public class java$util$EnumSet : java$util$AbstractSet$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$EnumSet_noneOf_java$lang$Class__java$util$EnumSet = svoker("noneOf", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Class")))
    public static func noneOf(a0: java$lang$Class?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_noneOf_java$lang$Class__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_allOf_java$lang$Class__java$util$EnumSet = svoker("allOf", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Class")))
    public static func allOf(a0: java$lang$Class?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_allOf_java$lang$Class__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_copyOf_java$util$EnumSet__java$util$EnumSet = svoker("copyOf", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/util/EnumSet")))
    public static func copyOf(a0: java$util$EnumSet?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_copyOf_java$util$EnumSet__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_copyOf_java$util$Collection__java$util$EnumSet = svoker("copyOf", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/util/Collection")))
    public static func copyOf(a0: java$util$Collection?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_copyOf_java$util$Collection__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_complementOf_java$util$EnumSet__java$util$EnumSet = svoker("complementOf", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/util/EnumSet")))
    public static func complementOf(a0: java$util$EnumSet?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_complementOf_java$util$EnumSet__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum")))
    public static func of(a0: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum_java$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum")))
    public static func of(a0: java$lang$Enum?, _ a1: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum")))
    public static func of(a0: java$lang$Enum?, _ a1: java$lang$Enum?, _ a2: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum")))
    public static func of(a0: java$lang$Enum?, _ a1: java$lang$Enum?, _ a2: java$lang$Enum?, _ a3: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum")))
    public static func of(a0: java$lang$Enum?, _ a1: java$lang$Enum?, _ a2: java$lang$Enum?, _ a3: java$lang$Enum?, _ a4: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil, a4?.jobj ?? nil))
    }

    private static let java$util$EnumSet_of_java$lang$Enum_Ajava$lang$Enum__java$util$EnumSet = svoker("of", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JArray(JObjectType("java/lang/Enum"))))
    public static func of(a0: java$lang$Enum?, _ a1: [java$lang$Enum?]?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_of_java$lang$Enum_Ajava$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.map({ java$lang$Enum$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$EnumSet_range_java$lang$Enum_java$lang$Enum__java$util$EnumSet = svoker("range", returns: JObjectType("java/util/EnumSet"), arguments: (JObjectType("java/lang/Enum"), JObjectType("java/lang/Enum")))
    public static func range(a0: java$lang$Enum?, _ a1: java$lang$Enum?) throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_range_java$lang$Enum_java$lang$Enum__java$util$EnumSet(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$EnumSet_clone__java$util$EnumSet = invoker("clone", returns: JObjectType("java/util/EnumSet"))
    public func clone() throws -> java$util$EnumSet? {
        return try java$util$EnumSet$(jobj: java$util$EnumSet$.java$util$EnumSet_clone__java$util$EnumSet(jobj)())
    }

    private static let java$util$EnumSet_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$EnumSet$.java$util$EnumSet_clone__java$lang$Object(jobj)())
    }

}

public typealias java$util$EnumSet$ = java$util$EnumSet

public protocol java$util$Enumeration : JavaObject {
    func hasMoreElements() throws -> jboolean
    func nextElement() throws -> java$lang$Object?
}

public class java$util$Enumeration$ : java$lang$Object$, java$util$Enumeration {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Enumeration_hasMoreElements__Z = invoker("hasMoreElements", returns: jboolean.jniType)
    private static let java$util$Enumeration_nextElement__java$lang$Object = invoker("nextElement", returns: JObjectType("java/lang/Object"))
}

public extension java$util$Enumeration {
    func hasMoreElements() throws -> jboolean {
        return try java$util$Enumeration$.java$util$Enumeration_hasMoreElements__Z(jobj)()
    }

    func nextElement() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Enumeration$.java$util$Enumeration_nextElement__java$lang$Object(jobj)())
    }

}

public protocol java$util$EventListener : JavaObject {
}

public class java$util$EventListener$ : java$lang$Object$, java$util$EventListener {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$util$EventListener {
}

public class java$util$EventListenerProxy : java$lang$Object$, java$util$EventListener {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$EventListenerProxy_init_java$util$EventListener__V = constructor((JObjectType("java/util/EventListener")))
    public convenience init!(_ a0: java$util$EventListener?) throws {
        let jobj = try java$util$EventListenerProxy$.java$util$EventListenerProxy_init_java$util$EventListener__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$EventListenerProxy_getListener__java$util$EventListener = invoker("getListener", returns: JObjectType("java/util/EventListener"))
    public func getListener() throws -> java$util$EventListener? {
        return try java$util$EventListener$(jobj: java$util$EventListenerProxy$.java$util$EventListenerProxy_getListener__java$util$EventListener(jobj)())
    }

}

public typealias java$util$EventListenerProxy$ = java$util$EventListenerProxy

public class java$util$EventObject : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$EventObject_init_java$lang$Object__V = constructor((JObjectType("java/lang/Object")))
    public convenience init!(_ a0: java$lang$Object?) throws {
        let jobj = try java$util$EventObject$.java$util$EventObject_init_java$lang$Object__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$EventObject_getSource__java$lang$Object = invoker("getSource", returns: JObjectType("java/lang/Object"))
    public func getSource() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$EventObject$.java$util$EventObject_getSource__java$lang$Object(jobj)())
    }

    private static let java$util$EventObject_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$EventObject$ = java$util$EventObject

public class java$util$FormatFlagsConversionMismatchException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$FormatFlagsConversionMismatchException_init_java$lang$String_C__V = constructor((JObjectType("java/lang/String"), jchar.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jchar) throws {
        let jobj = try java$util$FormatFlagsConversionMismatchException$.java$util$FormatFlagsConversionMismatchException_init_java$lang$String_C__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$FormatFlagsConversionMismatchException_getFlags__java$lang$String = invoker("getFlags", returns: JObjectType("java/lang/String"))
    public func getFlags() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$FormatFlagsConversionMismatchException$.java$util$FormatFlagsConversionMismatchException_getFlags__java$lang$String(jobj)())
    }

    private static let java$util$FormatFlagsConversionMismatchException_getConversion__C = invoker("getConversion", returns: jchar.jniType)
    public func getConversion() throws -> jchar {
        return try java$util$FormatFlagsConversionMismatchException$.java$util$FormatFlagsConversionMismatchException_getConversion__C(jobj)()
    }

    private static let java$util$FormatFlagsConversionMismatchException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$FormatFlagsConversionMismatchException$ = java$util$FormatFlagsConversionMismatchException

public protocol java$util$Formattable : JavaObject {
    func formatTo(a0: java$util$Formatter?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> Void
}

public class java$util$Formattable$ : java$lang$Object$, java$util$Formattable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Formattable_formatTo_java$util$Formatter_I_I_I__V = invoker("formatTo", returns: JVoid.jniType, arguments: (JObjectType("java/util/Formatter"), jint.jniType, jint.jniType, jint.jniType))
}

public extension java$util$Formattable {
    func formatTo(a0: java$util$Formatter?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$util$Formattable$.java$util$Formattable_formatTo_java$util$Formatter_I_I_I__V(jobj)(a0?.jobj ?? nil, a1, a2, a3)
    }

}

public class java$util$FormattableFlags : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$FormattableFlags$ = java$util$FormattableFlags

public final class java$util$Formatter : java$lang$Object$, java$io$Closeable, java$io$Flushable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Formatter_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$lang$Appendable__V = constructor((JObjectType("java/lang/Appendable")))
    public convenience init!(_ a0: java$lang$Appendable?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$lang$Appendable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$util$Locale__V = constructor((JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$util$Locale?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$util$Locale__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$lang$Appendable_java$util$Locale__V = constructor((JObjectType("java/lang/Appendable"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$lang$Appendable?, _ a1: java$util$Locale?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$lang$Appendable_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$lang$String_java$lang$String_java$util$Locale__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$util$Locale?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$lang$String_java$lang$String_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$File_java$lang$String_java$util$Locale__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?, _ a2: java$util$Locale?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$File_java$lang$String_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$PrintStream__V = constructor((JObjectType("java/io/PrintStream")))
    public convenience init!(_ a0: java$io$PrintStream?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$PrintStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$OutputStream__V = constructor((JObjectType("java/io/OutputStream")))
    public convenience init!(_ a0: java$io$OutputStream?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$OutputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$OutputStream_java$lang$String__V = constructor((JObjectType("java/io/OutputStream"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$OutputStream_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_init_java$io$OutputStream_java$lang$String_java$util$Locale__V = constructor((JObjectType("java/io/OutputStream"), JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$io$OutputStream?, _ a1: java$lang$String?, _ a2: java$util$Locale?) throws {
        let jobj = try java$util$Formatter$.java$util$Formatter_init_java$io$OutputStream_java$lang$String_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Formatter_locale__java$util$Locale = invoker("locale", returns: JObjectType("java/util/Locale"))
    public func locale() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Formatter$.java$util$Formatter_locale__java$util$Locale(jobj)())
    }

    private static let java$util$Formatter_out__java$lang$Appendable = invoker("out", returns: JObjectType("java/lang/Appendable"))
    public func out() throws -> java$lang$Appendable? {
        return try java$lang$Appendable$(jobj: java$util$Formatter$.java$util$Formatter_out__java$lang$Appendable(jobj)())
    }

    private static let java$util$Formatter_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Formatter_flush__V = invoker("flush", returns: JVoid.jniType)
    public func flush() throws -> Void {
        return try java$util$Formatter$.java$util$Formatter_flush__V(jobj)()
    }

    private static let java$util$Formatter_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$util$Formatter$.java$util$Formatter_close__V(jobj)()
    }

    private static let java$util$Formatter_ioException__java$io$IOException = invoker("ioException", returns: JObjectType("java/io/IOException"))
    public func ioException() throws -> java$io$IOException? {
        return try java$io$IOException$(jobj: java$util$Formatter$.java$util$Formatter_ioException__java$io$IOException(jobj)())
    }

    private static let java$util$Formatter_format_java$lang$String_Ajava$lang$Object__java$util$Formatter = invoker("format", returns: JObjectType("java/util/Formatter"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$util$Formatter? {
        return try java$util$Formatter$(jobj: java$util$Formatter$.java$util$Formatter_format_java$lang$String_Ajava$lang$Object__java$util$Formatter(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    private static let java$util$Formatter_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$util$Formatter = invoker("format", returns: JObjectType("java/util/Formatter"), arguments: (JObjectType("java/util/Locale"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    public func format(a0: java$util$Locale?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$util$Formatter? {
        return try java$util$Formatter$(jobj: java$util$Formatter$.java$util$Formatter_format_java$util$Locale_java$lang$String_Ajava$lang$Object__java$util$Formatter(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

}

public typealias java$util$Formatter$ = java$util$Formatter

public class java$util$FormatterClosedException : java$lang$IllegalStateException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$FormatterClosedException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$FormatterClosedException$.java$util$FormatterClosedException_init__V()
        self.init(jobj: jobj)
    }

}

public typealias java$util$FormatterClosedException$ = java$util$FormatterClosedException

public class java$util$GregorianCalendar : java$util$Calendar$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$GregorianCalendar_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_java$util$TimeZone__V = constructor((JObjectType("java/util/TimeZone")))
    public convenience init!(_ a0: java$util$TimeZone?) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_java$util$TimeZone__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_java$util$Locale__V = constructor((JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$util$Locale?) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_java$util$Locale__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_java$util$TimeZone_java$util$Locale__V = constructor((JObjectType("java/util/TimeZone"), JObjectType("java/util/Locale")))
    public convenience init!(_ a0: java$util$TimeZone?, _ a1: java$util$Locale?) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_java$util$TimeZone_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_I_I_I__V(a0, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_I_I_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_I_I_I_I_I__V(a0, a1, a2, a3, a4)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_init_I_I_I_I_I_I__V = constructor((jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint) throws {
        let jobj = try java$util$GregorianCalendar$.java$util$GregorianCalendar_init_I_I_I_I_I_I__V(a0, a1, a2, a3, a4, a5)
        self.init(jobj: jobj)
    }

    private static let java$util$GregorianCalendar_setGregorianChange_java$util$Date__V = invoker("setGregorianChange", returns: JVoid.jniType, arguments: (JObjectType("java/util/Date")))
    public func setGregorianChange(a0: java$util$Date?) throws -> Void {
        return try java$util$GregorianCalendar$.java$util$GregorianCalendar_setGregorianChange_java$util$Date__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$GregorianCalendar_getGregorianChange__java$util$Date = invoker("getGregorianChange", returns: JObjectType("java/util/Date"))
    public func getGregorianChange() throws -> java$util$Date? {
        return try java$util$Date$(jobj: java$util$GregorianCalendar$.java$util$GregorianCalendar_getGregorianChange__java$util$Date(jobj)())
    }

    private static let java$util$GregorianCalendar_isLeapYear_I__Z = invoker("isLeapYear", returns: jboolean.jniType, arguments: (jint.jniType))
    public func isLeapYear(a0: jint) throws -> jboolean {
        return try java$util$GregorianCalendar$.java$util$GregorianCalendar_isLeapYear_I__Z(jobj)(a0)
    }

    private static let java$util$GregorianCalendar_getCalendarType__java$lang$String = invoker("getCalendarType", returns: JObjectType("java/lang/String"))
    private static let java$util$GregorianCalendar_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$GregorianCalendar_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$GregorianCalendar_add_I_I__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$util$GregorianCalendar_roll_I_Z__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    private static let java$util$GregorianCalendar_roll_I_I__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$util$GregorianCalendar_getMinimum_I__I = invoker("getMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_getMaximum_I__I = invoker("getMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_getGreatestMinimum_I__I = invoker("getGreatestMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_getLeastMaximum_I__I = invoker("getLeastMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_getActualMinimum_I__I = invoker("getActualMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_getActualMaximum_I__I = invoker("getActualMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$GregorianCalendar_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$util$GregorianCalendar_getTimeZone__java$util$TimeZone = invoker("getTimeZone", returns: JObjectType("java/util/TimeZone"))
    private static let java$util$GregorianCalendar_setTimeZone_java$util$TimeZone__V = invoker("setTimeZone", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimeZone")))
    private static let java$util$GregorianCalendar_isWeekDateSupported__Z = invoker("isWeekDateSupported", returns: jboolean.jniType)
    private static let java$util$GregorianCalendar_getWeekYear__I = invoker("getWeekYear", returns: jint.jniType)
    private static let java$util$GregorianCalendar_setWeekDate_I_I_I__V = invoker("setWeekDate", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    private static let java$util$GregorianCalendar_getWeeksInWeekYear__I = invoker("getWeeksInWeekYear", returns: jint.jniType)
    private static let java$util$GregorianCalendar_toZonedDateTime__java$time$ZonedDateTime = invoker("toZonedDateTime", returns: JObjectType("java/time/ZonedDateTime"))
    public func toZonedDateTime() throws -> java$time$ZonedDateTime? {
        return try java$time$ZonedDateTime$(jobj: java$util$GregorianCalendar$.java$util$GregorianCalendar_toZonedDateTime__java$time$ZonedDateTime(jobj)())
    }

    private static let java$util$GregorianCalendar_from_java$time$ZonedDateTime__java$util$GregorianCalendar = svoker("from", returns: JObjectType("java/util/GregorianCalendar"), arguments: (JObjectType("java/time/ZonedDateTime")))
    public static func from(a0: java$time$ZonedDateTime?) throws -> java$util$GregorianCalendar? {
        return try java$util$GregorianCalendar$(jobj: java$util$GregorianCalendar$.java$util$GregorianCalendar_from_java$time$ZonedDateTime__java$util$GregorianCalendar(a0?.jobj ?? nil))
    }

}

public typealias java$util$GregorianCalendar$ = java$util$GregorianCalendar

public class java$util$HashMap : java$util$AbstractMap$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$HashMap_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$HashMap$.java$util$HashMap_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$HashMap_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$HashMap$.java$util$HashMap_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$HashMap_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$HashMap$.java$util$HashMap_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$HashMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$HashMap$.java$util$HashMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$HashMap_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$HashMap_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$HashMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$HashMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$HashMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$HashMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$HashMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$HashMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$HashMap_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object = invoker("getOrDefault", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func getOrDefault(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object = invoker("putIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func putIfAbsent(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_remove_java$lang$Object_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean {
        return try java$util$HashMap$.java$util$HashMap_remove_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$HashMap_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z = invoker("replace", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean {
        return try java$util$HashMap$.java$util$HashMap_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$HashMap_replace_java$lang$Object_java$lang$Object__java$lang$Object = invoker("replace", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_replace_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object = invoker("computeIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/Function")))
    public func computeIfAbsent(a0: java$lang$Object?, _ a1: java$util$function$Function?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("computeIfPresent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func computeIfPresent(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("compute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func compute(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$HashMap_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("merge", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func merge(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$HashMap_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    public func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$HashMap$.java$util$HashMap_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$HashMap_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    public func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$HashMap$.java$util$HashMap_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$HashMap_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashMap$.java$util$HashMap_clone__java$lang$Object(jobj)())
    }

}

public typealias java$util$HashMap$ = java$util$HashMap

public class java$util$HashSet : java$util$AbstractSet$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$HashSet_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$HashSet$.java$util$HashSet_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$HashSet_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$HashSet$.java$util$HashSet_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$HashSet_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$HashSet$.java$util$HashSet_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$HashSet_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$HashSet$.java$util$HashSet_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$HashSet_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$HashSet_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$HashSet_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$HashSet_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashSet_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashSet_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$HashSet_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$HashSet_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$HashSet$.java$util$HashSet_clone__java$lang$Object(jobj)())
    }

    private static let java$util$HashSet_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$HashSet$.java$util$HashSet_spliterator__java$util$Spliterator(jobj)())
    }

}

public typealias java$util$HashSet$ = java$util$HashSet

public class java$util$Hashtable : java$util$Dictionary$, java$util$Map, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Hashtable_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$Hashtable$.java$util$Hashtable_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$Hashtable_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$Hashtable$.java$util$Hashtable_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$Hashtable_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Hashtable$.java$util$Hashtable_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Hashtable_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$Hashtable$.java$util$Hashtable_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Hashtable_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Hashtable_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$Hashtable_keys__java$util$Enumeration = invoker("keys", returns: JObjectType("java/util/Enumeration"))
    private static let java$util$Hashtable_elements__java$util$Enumeration = invoker("elements", returns: JObjectType("java/util/Enumeration"))
    private static let java$util$Hashtable_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Hashtable$.java$util$Hashtable_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsValue(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Hashtable$.java$util$Hashtable_containsValue_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsKey(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Hashtable$.java$util$Hashtable_containsKey_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Hashtable_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Hashtable_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Hashtable_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    public func putAll(a0: java$util$Map?) throws -> Void {
        return try java$util$Hashtable$.java$util$Hashtable_putAll_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try java$util$Hashtable$.java$util$Hashtable_clear__V(jobj)()
    }

    private static let java$util$Hashtable_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_clone__java$lang$Object(jobj)())
    }

    private static let java$util$Hashtable_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Hashtable_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    public func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Hashtable$.java$util$Hashtable_keySet__java$util$Set(jobj)())
    }

    private static let java$util$Hashtable_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    public func entrySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Hashtable$.java$util$Hashtable_entrySet__java$util$Set(jobj)())
    }

    private static let java$util$Hashtable_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    public func values() throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$Hashtable$.java$util$Hashtable_values__java$util$Collection(jobj)())
    }

    private static let java$util$Hashtable_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Hashtable_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Hashtable_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object = invoker("getOrDefault", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func getOrDefault(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    public func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$Hashtable$.java$util$Hashtable_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    public func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$Hashtable$.java$util$Hashtable_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Hashtable_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object = invoker("putIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func putIfAbsent(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_remove_java$lang$Object_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean {
        return try java$util$Hashtable$.java$util$Hashtable_remove_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Hashtable_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z = invoker("replace", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean {
        return try java$util$Hashtable$.java$util$Hashtable_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Hashtable_replace_java$lang$Object_java$lang$Object__java$lang$Object = invoker("replace", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_replace_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object = invoker("computeIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/Function")))
    public func computeIfAbsent(a0: java$lang$Object?, _ a1: java$util$function$Function?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("computeIfPresent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func computeIfPresent(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("compute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func compute(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Hashtable_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("merge", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    public func merge(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Hashtable$.java$util$Hashtable_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

}

public typealias java$util$Hashtable$ = java$util$Hashtable

public class java$util$IdentityHashMap : java$util$AbstractMap$, java$io$Serializable, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IdentityHashMap_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$IdentityHashMap$.java$util$IdentityHashMap_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$IdentityHashMap_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$IdentityHashMap$.java$util$IdentityHashMap_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$IdentityHashMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$IdentityHashMap$.java$util$IdentityHashMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$IdentityHashMap_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$IdentityHashMap_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$IdentityHashMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$IdentityHashMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$IdentityHashMap_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$IdentityHashMap_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$IdentityHashMap_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$IdentityHashMap$.java$util$IdentityHashMap_clone__java$lang$Object(jobj)())
    }

    private static let java$util$IdentityHashMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$IdentityHashMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$IdentityHashMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$IdentityHashMap_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    public func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$IdentityHashMap$.java$util$IdentityHashMap_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$IdentityHashMap_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    public func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$IdentityHashMap$.java$util$IdentityHashMap_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$IdentityHashMap$ = java$util$IdentityHashMap

public class java$util$IllegalFormatCodePointException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllegalFormatCodePointException_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$IllegalFormatCodePointException$.java$util$IllegalFormatCodePointException_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$IllegalFormatCodePointException_getCodePoint__I = invoker("getCodePoint", returns: jint.jniType)
    public func getCodePoint() throws -> jint {
        return try java$util$IllegalFormatCodePointException$.java$util$IllegalFormatCodePointException_getCodePoint__I(jobj)()
    }

    private static let java$util$IllegalFormatCodePointException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IllegalFormatCodePointException$ = java$util$IllegalFormatCodePointException

public class java$util$IllegalFormatConversionException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllegalFormatConversionException_init_C_java$lang$Class__V = constructor((jchar.jniType, JObjectType("java/lang/Class")))
    public convenience init!(_ a0: jchar, _ a1: java$lang$Class?) throws {
        let jobj = try java$util$IllegalFormatConversionException$.java$util$IllegalFormatConversionException_init_C_java$lang$Class__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$IllegalFormatConversionException_getConversion__C = invoker("getConversion", returns: jchar.jniType)
    public func getConversion() throws -> jchar {
        return try java$util$IllegalFormatConversionException$.java$util$IllegalFormatConversionException_getConversion__C(jobj)()
    }

    private static let java$util$IllegalFormatConversionException_getArgumentClass__java$lang$Class = invoker("getArgumentClass", returns: JObjectType("java/lang/Class"))
    public func getArgumentClass() throws -> java$lang$Class? {
        return try java$lang$Class$(jobj: java$util$IllegalFormatConversionException$.java$util$IllegalFormatConversionException_getArgumentClass__java$lang$Class(jobj)())
    }

    private static let java$util$IllegalFormatConversionException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IllegalFormatConversionException$ = java$util$IllegalFormatConversionException

public class java$util$IllegalFormatException : java$lang$IllegalArgumentException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$IllegalFormatException$ = java$util$IllegalFormatException

public class java$util$IllegalFormatFlagsException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllegalFormatFlagsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$IllegalFormatFlagsException$.java$util$IllegalFormatFlagsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$IllegalFormatFlagsException_getFlags__java$lang$String = invoker("getFlags", returns: JObjectType("java/lang/String"))
    public func getFlags() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$IllegalFormatFlagsException$.java$util$IllegalFormatFlagsException_getFlags__java$lang$String(jobj)())
    }

    private static let java$util$IllegalFormatFlagsException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IllegalFormatFlagsException$ = java$util$IllegalFormatFlagsException

public class java$util$IllegalFormatPrecisionException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllegalFormatPrecisionException_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$IllegalFormatPrecisionException$.java$util$IllegalFormatPrecisionException_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$IllegalFormatPrecisionException_getPrecision__I = invoker("getPrecision", returns: jint.jniType)
    public func getPrecision() throws -> jint {
        return try java$util$IllegalFormatPrecisionException$.java$util$IllegalFormatPrecisionException_getPrecision__I(jobj)()
    }

    private static let java$util$IllegalFormatPrecisionException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IllegalFormatPrecisionException$ = java$util$IllegalFormatPrecisionException

public class java$util$IllegalFormatWidthException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllegalFormatWidthException_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$IllegalFormatWidthException$.java$util$IllegalFormatWidthException_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$IllegalFormatWidthException_getWidth__I = invoker("getWidth", returns: jint.jniType)
    public func getWidth() throws -> jint {
        return try java$util$IllegalFormatWidthException$.java$util$IllegalFormatWidthException_getWidth__I(jobj)()
    }

    private static let java$util$IllegalFormatWidthException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IllegalFormatWidthException$ = java$util$IllegalFormatWidthException

public class java$util$IllformedLocaleException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IllformedLocaleException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$IllformedLocaleException$.java$util$IllformedLocaleException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$IllformedLocaleException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$IllformedLocaleException$.java$util$IllformedLocaleException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$IllformedLocaleException_init_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jint) throws {
        let jobj = try java$util$IllformedLocaleException$.java$util$IllformedLocaleException_init_java$lang$String_I__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$IllformedLocaleException_getErrorIndex__I = invoker("getErrorIndex", returns: jint.jniType)
    public func getErrorIndex() throws -> jint {
        return try java$util$IllformedLocaleException$.java$util$IllformedLocaleException_getErrorIndex__I(jobj)()
    }

}

public typealias java$util$IllformedLocaleException$ = java$util$IllformedLocaleException

public class java$util$InputMismatchException : java$util$NoSuchElementException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$InputMismatchException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$InputMismatchException$.java$util$InputMismatchException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$InputMismatchException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$InputMismatchException$.java$util$InputMismatchException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$InputMismatchException$ = java$util$InputMismatchException

public class java$util$IntSummaryStatistics : java$lang$Object$, java$util$function$IntConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$IntSummaryStatistics_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$IntSummaryStatistics_accept_I__V = invoker("accept", returns: JVoid.jniType, arguments: (jint.jniType))
    public func accept(a0: jint) throws -> Void {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_accept_I__V(jobj)(a0)
    }

    private static let java$util$IntSummaryStatistics_combine_java$util$IntSummaryStatistics__V = invoker("combine", returns: JVoid.jniType, arguments: (JObjectType("java/util/IntSummaryStatistics")))
    public func combine(a0: java$util$IntSummaryStatistics?) throws -> Void {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_combine_java$util$IntSummaryStatistics__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$IntSummaryStatistics_getCount__J = invoker("getCount", returns: jlong.jniType)
    public func getCount() throws -> jlong {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_getCount__J(jobj)()
    }

    private static let java$util$IntSummaryStatistics_getSum__J = invoker("getSum", returns: jlong.jniType)
    public func getSum() throws -> jlong {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_getSum__J(jobj)()
    }

    private static let java$util$IntSummaryStatistics_getMin__I = invoker("getMin", returns: jint.jniType)
    public func getMin() throws -> jint {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_getMin__I(jobj)()
    }

    private static let java$util$IntSummaryStatistics_getMax__I = invoker("getMax", returns: jint.jniType)
    public func getMax() throws -> jint {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_getMax__I(jobj)()
    }

    private static let java$util$IntSummaryStatistics_getAverage__D = invoker("getAverage", returns: jdouble.jniType)
    public func getAverage() throws -> jdouble {
        return try java$util$IntSummaryStatistics$.java$util$IntSummaryStatistics_getAverage__D(jobj)()
    }

    private static let java$util$IntSummaryStatistics_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$IntSummaryStatistics$ = java$util$IntSummaryStatistics

public class java$util$InvalidPropertiesFormatException : java$io$IOException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$InvalidPropertiesFormatException_init_java$lang$Throwable__V = constructor((JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$Throwable?) throws {
        let jobj = try java$util$InvalidPropertiesFormatException$.java$util$InvalidPropertiesFormatException_init_java$lang$Throwable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$InvalidPropertiesFormatException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$InvalidPropertiesFormatException$.java$util$InvalidPropertiesFormatException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$InvalidPropertiesFormatException$ = java$util$InvalidPropertiesFormatException

public protocol java$util$Iterator : JavaObject {
    func hasNext() throws -> jboolean
    func next() throws -> java$lang$Object?
    func remove() throws -> Void
    func forEachRemaining(a0: java$util$function$Consumer?) throws -> Void
}

public class java$util$Iterator$ : java$lang$Object$, java$util$Iterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Iterator_hasNext__Z = invoker("hasNext", returns: jboolean.jniType)
    private static let java$util$Iterator_next__java$lang$Object = invoker("next", returns: JObjectType("java/lang/Object"))
    private static let java$util$Iterator_remove__V = invoker("remove", returns: JVoid.jniType)
    private static let java$util$Iterator_forEachRemaining_java$util$function$Consumer__V = invoker("forEachRemaining", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
}

public extension java$util$Iterator {
    func hasNext() throws -> jboolean {
        return try java$util$Iterator$.java$util$Iterator_hasNext__Z(jobj)()
    }

    func next() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Iterator$.java$util$Iterator_next__java$lang$Object(jobj)())
    }

    func remove() throws -> Void {
        return try java$util$Iterator$.java$util$Iterator_remove__V(jobj)()
    }

    func forEachRemaining(a0: java$util$function$Consumer?) throws -> Void {
        return try java$util$Iterator$.java$util$Iterator_forEachRemaining_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$util$JapaneseImperialCalendar : java$util$Calendar$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$JapaneseImperialCalendar_getCalendarType__java$lang$String = invoker("getCalendarType", returns: JObjectType("java/lang/String"))
    private static let java$util$JapaneseImperialCalendar_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$JapaneseImperialCalendar_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$JapaneseImperialCalendar_add_I_I__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$util$JapaneseImperialCalendar_roll_I_Z__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jboolean.jniType))
    private static let java$util$JapaneseImperialCalendar_roll_I_I__V = invoker("roll", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getDisplayName_I_I_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (jint.jniType, jint.jniType, JObjectType("java/util/Locale")))
    private static let java$util$JapaneseImperialCalendar_getDisplayNames_I_I_java$util$Locale__java$util$Map = invoker("getDisplayNames", returns: JObjectType("java/util/Map"), arguments: (jint.jniType, jint.jniType, JObjectType("java/util/Locale")))
    private static let java$util$JapaneseImperialCalendar_getMinimum_I__I = invoker("getMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getMaximum_I__I = invoker("getMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getGreatestMinimum_I__I = invoker("getGreatestMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getLeastMaximum_I__I = invoker("getLeastMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getActualMinimum_I__I = invoker("getActualMinimum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_getActualMaximum_I__I = invoker("getActualMaximum", returns: jint.jniType, arguments: (jint.jniType))
    private static let java$util$JapaneseImperialCalendar_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$util$JapaneseImperialCalendar_getTimeZone__java$util$TimeZone = invoker("getTimeZone", returns: JObjectType("java/util/TimeZone"))
    private static let java$util$JapaneseImperialCalendar_setTimeZone_java$util$TimeZone__V = invoker("setTimeZone", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimeZone")))
}

public typealias java$util$JapaneseImperialCalendar$ = java$util$JapaneseImperialCalendar

public class java$util$JumboEnumSet : java$util$EnumSet$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$JumboEnumSet_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$JumboEnumSet_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$JumboEnumSet_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$JumboEnumSet_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$JumboEnumSet_add_java$lang$Enum__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Enum")))
    public func add(a0: java$lang$Enum?) throws -> jboolean {
        return try java$util$JumboEnumSet$.java$util$JumboEnumSet_add_java$lang$Enum__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$JumboEnumSet_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$JumboEnumSet_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$JumboEnumSet_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$JumboEnumSet_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$JumboEnumSet_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$JumboEnumSet_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$JumboEnumSet_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$JumboEnumSet_clone__java$util$EnumSet = invoker("clone", returns: JObjectType("java/util/EnumSet"))
    private static let java$util$JumboEnumSet_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$JumboEnumSet_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
}

public typealias java$util$JumboEnumSet$ = java$util$JumboEnumSet

public class java$util$LinkedHashMap : java$util$HashMap$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$LinkedHashMap_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$LinkedHashMap$.java$util$LinkedHashMap_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashMap_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$LinkedHashMap$.java$util$LinkedHashMap_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashMap_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$LinkedHashMap$.java$util$LinkedHashMap_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$LinkedHashMap$.java$util$LinkedHashMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashMap_init_I_F_Z__V = constructor((jint.jniType, jfloat.jniType, jboolean.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat, _ a2: jboolean) throws {
        let jobj = try java$util$LinkedHashMap$.java$util$LinkedHashMap_init_I_F_Z__V(a0, a1, a2)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedHashMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedHashMap_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object = invoker("getOrDefault", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$LinkedHashMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$LinkedHashMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$LinkedHashMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$LinkedHashMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$LinkedHashMap_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    private static let java$util$LinkedHashMap_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
}

public typealias java$util$LinkedHashMap$ = java$util$LinkedHashMap

public class java$util$LinkedHashSet : java$util$HashSet$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$LinkedHashSet_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$LinkedHashSet$.java$util$LinkedHashSet_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashSet_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$LinkedHashSet$.java$util$LinkedHashSet_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashSet_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$LinkedHashSet$.java$util$LinkedHashSet_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashSet_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$LinkedHashSet$.java$util$LinkedHashSet_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedHashSet_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
}

public typealias java$util$LinkedHashSet$ = java$util$LinkedHashSet

public class java$util$LinkedList : java$util$AbstractSequentialList$, java$util$Deque, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$LinkedList_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$LinkedList$.java$util$LinkedList_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedList_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$LinkedList$.java$util$LinkedList_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$LinkedList_getFirst__java$lang$Object = invoker("getFirst", returns: JObjectType("java/lang/Object"))
    public func getFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_getFirst__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_getLast__java$lang$Object = invoker("getLast", returns: JObjectType("java/lang/Object"))
    public func getLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_getLast__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_removeFirst__java$lang$Object = invoker("removeFirst", returns: JObjectType("java/lang/Object"))
    public func removeFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_removeFirst__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_removeLast__java$lang$Object = invoker("removeLast", returns: JObjectType("java/lang/Object"))
    public func removeLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_removeLast__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_addFirst_java$lang$Object__V = invoker("addFirst", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func addFirst(a0: java$lang$Object?) throws -> Void {
        return try java$util$LinkedList$.java$util$LinkedList_addFirst_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_addLast_java$lang$Object__V = invoker("addLast", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func addLast(a0: java$lang$Object?) throws -> Void {
        return try java$util$LinkedList$.java$util$LinkedList_addLast_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$LinkedList_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$LinkedList_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$LinkedList_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$LinkedList_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$LinkedList_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$LinkedList_indexOf_java$lang$Object__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_lastIndexOf_java$lang$Object__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
    public func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_peek__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_element__java$lang$Object = invoker("element", returns: JObjectType("java/lang/Object"))
    public func element() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_element__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_poll__java$lang$Object = invoker("poll", returns: JObjectType("java/lang/Object"))
    public func poll() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_poll__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_remove__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"))
    public func remove() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_remove__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_offer_java$lang$Object__Z = invoker("offer", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offer(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$LinkedList$.java$util$LinkedList_offer_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_offerFirst_java$lang$Object__Z = invoker("offerFirst", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offerFirst(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$LinkedList$.java$util$LinkedList_offerFirst_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_offerLast_java$lang$Object__Z = invoker("offerLast", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offerLast(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$LinkedList$.java$util$LinkedList_offerLast_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_peekFirst__java$lang$Object = invoker("peekFirst", returns: JObjectType("java/lang/Object"))
    public func peekFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_peekFirst__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_peekLast__java$lang$Object = invoker("peekLast", returns: JObjectType("java/lang/Object"))
    public func peekLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_peekLast__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_pollFirst__java$lang$Object = invoker("pollFirst", returns: JObjectType("java/lang/Object"))
    public func pollFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_pollFirst__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_pollLast__java$lang$Object = invoker("pollLast", returns: JObjectType("java/lang/Object"))
    public func pollLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_pollLast__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_push_java$lang$Object__V = invoker("push", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func push(a0: java$lang$Object?) throws -> Void {
        return try java$util$LinkedList$.java$util$LinkedList_push_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_pop__java$lang$Object = invoker("pop", returns: JObjectType("java/lang/Object"))
    public func pop() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_pop__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_removeFirstOccurrence_java$lang$Object__Z = invoker("removeFirstOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func removeFirstOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$LinkedList$.java$util$LinkedList_removeFirstOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_removeLastOccurrence_java$lang$Object__Z = invoker("removeLastOccurrence", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func removeLastOccurrence(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$LinkedList$.java$util$LinkedList_removeLastOccurrence_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LinkedList_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    private static let java$util$LinkedList_descendingIterator__java$util$Iterator = invoker("descendingIterator", returns: JObjectType("java/util/Iterator"))
    public func descendingIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$LinkedList$.java$util$LinkedList_descendingIterator__java$util$Iterator(jobj)())
    }

    private static let java$util$LinkedList_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$LinkedList$.java$util$LinkedList_clone__java$lang$Object(jobj)())
    }

    private static let java$util$LinkedList_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$LinkedList_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$LinkedList_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$LinkedList$.java$util$LinkedList_spliterator__java$util$Spliterator(jobj)())
    }

}

public typealias java$util$LinkedList$ = java$util$LinkedList

public protocol java$util$List : java$util$Collection {
    func size() throws -> jint
    func isEmpty() throws -> jboolean
    func contains(a0: java$lang$Object?) throws -> jboolean
    func iterator() throws -> java$util$Iterator?
    func toArray() throws -> [java$lang$Object?]?
    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]?
    func add(a0: java$lang$Object?) throws -> jboolean
    func remove(a0: java$lang$Object?) throws -> jboolean
    func containsAll(a0: java$util$Collection?) throws -> jboolean
    func addAll(a0: java$util$Collection?) throws -> jboolean
    func addAll(a0: jint, _ a1: java$util$Collection?) throws -> jboolean
    func removeAll(a0: java$util$Collection?) throws -> jboolean
    func retainAll(a0: java$util$Collection?) throws -> jboolean
    func replaceAll(a0: java$util$function$UnaryOperator?) throws -> Void
    func sort(a0: java$util$Comparator?) throws -> Void
    func clear() throws -> Void
    func equals(a0: java$lang$Object?) throws -> jboolean
    func hashCode() throws -> jint
    func get(a0: jint) throws -> java$lang$Object?
    func set(a0: jint, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func add(a0: jint, _ a1: java$lang$Object?) throws -> Void
    func remove(a0: jint) throws -> java$lang$Object?
    func indexOf(a0: java$lang$Object?) throws -> jint
    func lastIndexOf(a0: java$lang$Object?) throws -> jint
    func listIterator() throws -> java$util$ListIterator?
    func listIterator(a0: jint) throws -> java$util$ListIterator?
    func subList(a0: jint, _ a1: jint) throws -> java$util$List?
    func spliterator() throws -> java$util$Spliterator?
}

public class java$util$List$ : java$lang$Object$, java$util$List, java$util$Collection {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$List_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$List_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$List_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$List_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$List_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$List_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$List_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$List_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$List_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$List_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$List_replaceAll_java$util$function$UnaryOperator__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/UnaryOperator")))
    private static let java$util$List_sort_java$util$Comparator__V = invoker("sort", returns: JVoid.jniType, arguments: (JObjectType("java/util/Comparator")))
    private static let java$util$List_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$List_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$List_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$List_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$List_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$List_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$List_indexOf_java$lang$Object__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_lastIndexOf_java$lang$Object__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$List_listIterator__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"))
    private static let java$util$List_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    private static let java$util$List_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
    private static let java$util$List_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
}

public extension java$util$List {
    func size() throws -> jint {
        return try java$util$List$.java$util$List_size__I(jobj)()
    }

    func isEmpty() throws -> jboolean {
        return try java$util$List$.java$util$List_isEmpty__Z(jobj)()
    }

    func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$List$.java$util$List_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$List$.java$util$List_iterator__java$util$Iterator(jobj)())
    }

    func toArray() throws -> [java$lang$Object?]? {
        return try java$util$List$.java$util$List_toArray__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]? {
        return try java$util$List$.java$util$List_toArray_Ajava$lang$Object__Ajava$lang$Object(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$List$.java$util$List_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func remove(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$List$.java$util$List_remove_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func containsAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$List$.java$util$List_containsAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func addAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$List$.java$util$List_addAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func addAll(a0: jint, _ a1: java$util$Collection?) throws -> jboolean {
        return try java$util$List$.java$util$List_addAll_I_java$util$Collection__Z(jobj)(a0, a1?.jobj ?? nil)
    }

    func removeAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$List$.java$util$List_removeAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func retainAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$List$.java$util$List_retainAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func replaceAll(a0: java$util$function$UnaryOperator?) throws -> Void {
        return try java$util$List$.java$util$List_replaceAll_java$util$function$UnaryOperator__V(jobj)(a0?.jobj ?? nil)
    }

    func sort(a0: java$util$Comparator?) throws -> Void {
        return try java$util$List$.java$util$List_sort_java$util$Comparator__V(jobj)(a0?.jobj ?? nil)
    }

    func clear() throws -> Void {
        return try java$util$List$.java$util$List_clear__V(jobj)()
    }

    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$List$.java$util$List_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func hashCode() throws -> jint {
        return try java$util$List$.java$util$List_hashCode__I(jobj)()
    }

    func get(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$List$.java$util$List_get_I__java$lang$Object(jobj)(a0))
    }

    func set(a0: jint, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$List$.java$util$List_set_I_java$lang$Object__java$lang$Object(jobj)(a0, a1?.jobj ?? nil))
    }

    func add(a0: jint, _ a1: java$lang$Object?) throws -> Void {
        return try java$util$List$.java$util$List_add_I_java$lang$Object__V(jobj)(a0, a1?.jobj ?? nil)
    }

    func remove(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$List$.java$util$List_remove_I__java$lang$Object(jobj)(a0))
    }

    func indexOf(a0: java$lang$Object?) throws -> jint {
        return try java$util$List$.java$util$List_indexOf_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    func lastIndexOf(a0: java$lang$Object?) throws -> jint {
        return try java$util$List$.java$util$List_lastIndexOf_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

    func listIterator() throws -> java$util$ListIterator? {
        return try java$util$ListIterator$(jobj: java$util$List$.java$util$List_listIterator__java$util$ListIterator(jobj)())
    }

    func listIterator(a0: jint) throws -> java$util$ListIterator? {
        return try java$util$ListIterator$(jobj: java$util$List$.java$util$List_listIterator_I__java$util$ListIterator(jobj)(a0))
    }

    func subList(a0: jint, _ a1: jint) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$List$.java$util$List_subList_I_I__java$util$List(jobj)(a0, a1))
    }

    func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$List$.java$util$List_spliterator__java$util$Spliterator(jobj)())
    }

}

public protocol java$util$ListIterator : java$util$Iterator {
    func hasNext() throws -> jboolean
    func next() throws -> java$lang$Object?
    func hasPrevious() throws -> jboolean
    func previous() throws -> java$lang$Object?
    func nextIndex() throws -> jint
    func previousIndex() throws -> jint
    func remove() throws -> Void
    func set(a0: java$lang$Object?) throws -> Void
    func add(a0: java$lang$Object?) throws -> Void
}

public class java$util$ListIterator$ : java$lang$Object$, java$util$ListIterator, java$util$Iterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ListIterator_hasNext__Z = invoker("hasNext", returns: jboolean.jniType)
    private static let java$util$ListIterator_next__java$lang$Object = invoker("next", returns: JObjectType("java/lang/Object"))
    private static let java$util$ListIterator_hasPrevious__Z = invoker("hasPrevious", returns: jboolean.jniType)
    private static let java$util$ListIterator_previous__java$lang$Object = invoker("previous", returns: JObjectType("java/lang/Object"))
    private static let java$util$ListIterator_nextIndex__I = invoker("nextIndex", returns: jint.jniType)
    private static let java$util$ListIterator_previousIndex__I = invoker("previousIndex", returns: jint.jniType)
    private static let java$util$ListIterator_remove__V = invoker("remove", returns: JVoid.jniType)
    private static let java$util$ListIterator_set_java$lang$Object__V = invoker("set", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$ListIterator_add_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
}

public extension java$util$ListIterator {
    func hasNext() throws -> jboolean {
        return try java$util$ListIterator$.java$util$ListIterator_hasNext__Z(jobj)()
    }

    func next() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ListIterator$.java$util$ListIterator_next__java$lang$Object(jobj)())
    }

    func hasPrevious() throws -> jboolean {
        return try java$util$ListIterator$.java$util$ListIterator_hasPrevious__Z(jobj)()
    }

    func previous() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ListIterator$.java$util$ListIterator_previous__java$lang$Object(jobj)())
    }

    func nextIndex() throws -> jint {
        return try java$util$ListIterator$.java$util$ListIterator_nextIndex__I(jobj)()
    }

    func previousIndex() throws -> jint {
        return try java$util$ListIterator$.java$util$ListIterator_previousIndex__I(jobj)()
    }

    func remove() throws -> Void {
        return try java$util$ListIterator$.java$util$ListIterator_remove__V(jobj)()
    }

    func set(a0: java$lang$Object?) throws -> Void {
        return try java$util$ListIterator$.java$util$ListIterator_set_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    func add(a0: java$lang$Object?) throws -> Void {
        return try java$util$ListIterator$.java$util$ListIterator_add_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$util$ListResourceBundle : java$util$ResourceBundle$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ListResourceBundle_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$ListResourceBundle$.java$util$ListResourceBundle_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$ListResourceBundle_handleGetObject_java$lang$String__java$lang$Object = invoker("handleGetObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func handleGetObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ListResourceBundle$.java$util$ListResourceBundle_handleGetObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$ListResourceBundle_getKeys__java$util$Enumeration = invoker("getKeys", returns: JObjectType("java/util/Enumeration"))
}

public typealias java$util$ListResourceBundle$ = java$util$ListResourceBundle

public final class java$util$Locale : java$lang$Object$, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Locale_init_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws {
        let jobj = try java$util$Locale$.java$util$Locale_init_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Locale_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Locale$.java$util$Locale_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Locale_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$Locale$.java$util$Locale_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Locale_getDefault__java$util$Locale = svoker("getDefault", returns: JObjectType("java/util/Locale"))
    public static func getDefault() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Locale$.java$util$Locale_getDefault__java$util$Locale())
    }

    private static let java$util$Locale_getDefault_java$util$Locale$Category__java$util$Locale = svoker("getDefault", returns: JObjectType("java/util/Locale"), arguments: (JObjectType("java/util/Locale$Category")))
    public static func getDefault(a0: java$util$Locale$Category?) throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Locale$.java$util$Locale_getDefault_java$util$Locale$Category__java$util$Locale(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_setDefault_java$util$Locale__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/util/Locale")))
    public static func setDefault(a0: java$util$Locale?) throws -> Void {
        return try java$util$Locale$.java$util$Locale_setDefault_java$util$Locale__V(a0?.jobj ?? nil)
    }

    private static let java$util$Locale_setDefault_java$util$Locale$Category_java$util$Locale__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/util/Locale$Category"), JObjectType("java/util/Locale")))
    public static func setDefault(a0: java$util$Locale$Category?, _ a1: java$util$Locale?) throws -> Void {
        return try java$util$Locale$.java$util$Locale_setDefault_java$util$Locale$Category_java$util$Locale__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Locale_getAvailableLocales__Ajava$util$Locale = svoker("getAvailableLocales", returns: JArray(JObjectType("java/util/Locale")))
    public static func getAvailableLocales() throws -> [java$util$Locale?]? {
        return try java$util$Locale$.java$util$Locale_getAvailableLocales__Ajava$util$Locale().jarrayToArray(java$util$Locale$.self)?.map({ $0 as java$util$Locale? })
    }

    private static let java$util$Locale_getISOCountries__Ajava$lang$String = svoker("getISOCountries", returns: JArray(JObjectType("java/lang/String")))
    public static func getISOCountries() throws -> [java$lang$String?]? {
        return try java$util$Locale$.java$util$Locale_getISOCountries__Ajava$lang$String().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$util$Locale_getISOLanguages__Ajava$lang$String = svoker("getISOLanguages", returns: JArray(JObjectType("java/lang/String")))
    public static func getISOLanguages() throws -> [java$lang$String?]? {
        return try java$util$Locale$.java$util$Locale_getISOLanguages__Ajava$lang$String().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$util$Locale_getLanguage__java$lang$String = invoker("getLanguage", returns: JObjectType("java/lang/String"))
    public func getLanguage() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getLanguage__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getScript__java$lang$String = invoker("getScript", returns: JObjectType("java/lang/String"))
    public func getScript() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getScript__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getCountry__java$lang$String = invoker("getCountry", returns: JObjectType("java/lang/String"))
    public func getCountry() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getCountry__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getVariant__java$lang$String = invoker("getVariant", returns: JObjectType("java/lang/String"))
    public func getVariant() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getVariant__java$lang$String(jobj)())
    }

    private static let java$util$Locale_hasExtensions__Z = invoker("hasExtensions", returns: jboolean.jniType)
    public func hasExtensions() throws -> jboolean {
        return try java$util$Locale$.java$util$Locale_hasExtensions__Z(jobj)()
    }

    private static let java$util$Locale_stripExtensions__java$util$Locale = invoker("stripExtensions", returns: JObjectType("java/util/Locale"))
    public func stripExtensions() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Locale$.java$util$Locale_stripExtensions__java$util$Locale(jobj)())
    }

    private static let java$util$Locale_getExtension_C__java$lang$String = invoker("getExtension", returns: JObjectType("java/lang/String"), arguments: (jchar.jniType))
    public func getExtension(a0: jchar) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getExtension_C__java$lang$String(jobj)(a0))
    }

    private static let java$util$Locale_getExtensionKeys__java$util$Set = invoker("getExtensionKeys", returns: JObjectType("java/util/Set"))
    public func getExtensionKeys() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Locale$.java$util$Locale_getExtensionKeys__java$util$Set(jobj)())
    }

    private static let java$util$Locale_getUnicodeLocaleAttributes__java$util$Set = invoker("getUnicodeLocaleAttributes", returns: JObjectType("java/util/Set"))
    public func getUnicodeLocaleAttributes() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Locale$.java$util$Locale_getUnicodeLocaleAttributes__java$util$Set(jobj)())
    }

    private static let java$util$Locale_getUnicodeLocaleType_java$lang$String__java$lang$String = invoker("getUnicodeLocaleType", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func getUnicodeLocaleType(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getUnicodeLocaleType_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getUnicodeLocaleKeys__java$util$Set = invoker("getUnicodeLocaleKeys", returns: JObjectType("java/util/Set"))
    public func getUnicodeLocaleKeys() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Locale$.java$util$Locale_getUnicodeLocaleKeys__java$util$Set(jobj)())
    }

    private static let java$util$Locale_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Locale_toLanguageTag__java$lang$String = invoker("toLanguageTag", returns: JObjectType("java/lang/String"))
    public func toLanguageTag() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_toLanguageTag__java$lang$String(jobj)())
    }

    private static let java$util$Locale_forLanguageTag_java$lang$String__java$util$Locale = svoker("forLanguageTag", returns: JObjectType("java/util/Locale"), arguments: (JObjectType("java/lang/String")))
    public static func forLanguageTag(a0: java$lang$String?) throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Locale$.java$util$Locale_forLanguageTag_java$lang$String__java$util$Locale(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getISO3Language__java$lang$String = invoker("getISO3Language", returns: JObjectType("java/lang/String"))
    public func getISO3Language() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getISO3Language__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getISO3Country__java$lang$String = invoker("getISO3Country", returns: JObjectType("java/lang/String"))
    public func getISO3Country() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getISO3Country__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayLanguage__java$lang$String = invoker("getDisplayLanguage", returns: JObjectType("java/lang/String"))
    public func getDisplayLanguage() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayLanguage__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayLanguage_java$util$Locale__java$lang$String = invoker("getDisplayLanguage", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayLanguage(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayLanguage_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getDisplayScript__java$lang$String = invoker("getDisplayScript", returns: JObjectType("java/lang/String"))
    public func getDisplayScript() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayScript__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayScript_java$util$Locale__java$lang$String = invoker("getDisplayScript", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayScript(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayScript_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getDisplayCountry__java$lang$String = invoker("getDisplayCountry", returns: JObjectType("java/lang/String"))
    public func getDisplayCountry() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayCountry__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayCountry_java$util$Locale__java$lang$String = invoker("getDisplayCountry", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayCountry(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayCountry_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getDisplayVariant__java$lang$String = invoker("getDisplayVariant", returns: JObjectType("java/lang/String"))
    public func getDisplayVariant() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayVariant__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayVariant_java$util$Locale__java$lang$String = invoker("getDisplayVariant", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayVariant(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayVariant_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_getDisplayName__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"))
    public func getDisplayName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayName__java$lang$String(jobj)())
    }

    private static let java$util$Locale_getDisplayName_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayName(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_getDisplayName_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Locale_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Locale$.java$util$Locale_clone__java$lang$Object(jobj)())
    }

    private static let java$util$Locale_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Locale_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Locale_filter_java$util$List_java$util$Collection_java$util$Locale$FilteringMode__java$util$List = svoker("filter", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection"), JObjectType("java/util/Locale$FilteringMode")))
    public static func filter(a0: java$util$List?, _ a1: java$util$Collection?, _ a2: java$util$Locale$FilteringMode?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Locale$.java$util$Locale_filter_java$util$List_java$util$Collection_java$util$Locale$FilteringMode__java$util$List(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$Locale_filter_java$util$List_java$util$Collection__java$util$List = svoker("filter", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection")))
    public static func filter(a0: java$util$List?, _ a1: java$util$Collection?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Locale$.java$util$Locale_filter_java$util$List_java$util$Collection__java$util$List(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Locale_filterTags_java$util$List_java$util$Collection_java$util$Locale$FilteringMode__java$util$List = svoker("filterTags", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection"), JObjectType("java/util/Locale$FilteringMode")))
    public static func filterTags(a0: java$util$List?, _ a1: java$util$Collection?, _ a2: java$util$Locale$FilteringMode?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Locale$.java$util$Locale_filterTags_java$util$List_java$util$Collection_java$util$Locale$FilteringMode__java$util$List(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$Locale_filterTags_java$util$List_java$util$Collection__java$util$List = svoker("filterTags", returns: JObjectType("java/util/List"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection")))
    public static func filterTags(a0: java$util$List?, _ a1: java$util$Collection?) throws -> java$util$List? {
        return try java$util$List$(jobj: java$util$Locale$.java$util$Locale_filterTags_java$util$List_java$util$Collection__java$util$List(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Locale_lookup_java$util$List_java$util$Collection__java$util$Locale = svoker("lookup", returns: JObjectType("java/util/Locale"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection")))
    public static func lookup(a0: java$util$List?, _ a1: java$util$Collection?) throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Locale$.java$util$Locale_lookup_java$util$List_java$util$Collection__java$util$Locale(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Locale_lookupTag_java$util$List_java$util$Collection__java$lang$String = svoker("lookupTag", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/List"), JObjectType("java/util/Collection")))
    public static func lookupTag(a0: java$util$List?, _ a1: java$util$Collection?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Locale$.java$util$Locale_lookupTag_java$util$List_java$util$Collection__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias java$util$Locale$ = java$util$Locale

public class java$util$LocaleISOData : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$LocaleISOData$ = java$util$LocaleISOData

public class java$util$LongSummaryStatistics : java$lang$Object$, java$util$function$LongConsumer, java$util$function$IntConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$LongSummaryStatistics_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$LongSummaryStatistics_accept_I__V = invoker("accept", returns: JVoid.jniType, arguments: (jint.jniType))
    public func accept(a0: jint) throws -> Void {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_accept_I__V(jobj)(a0)
    }

    private static let java$util$LongSummaryStatistics_accept_J__V = invoker("accept", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func accept(a0: jlong) throws -> Void {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_accept_J__V(jobj)(a0)
    }

    private static let java$util$LongSummaryStatistics_combine_java$util$LongSummaryStatistics__V = invoker("combine", returns: JVoid.jniType, arguments: (JObjectType("java/util/LongSummaryStatistics")))
    public func combine(a0: java$util$LongSummaryStatistics?) throws -> Void {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_combine_java$util$LongSummaryStatistics__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$LongSummaryStatistics_getCount__J = invoker("getCount", returns: jlong.jniType)
    public func getCount() throws -> jlong {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_getCount__J(jobj)()
    }

    private static let java$util$LongSummaryStatistics_getSum__J = invoker("getSum", returns: jlong.jniType)
    public func getSum() throws -> jlong {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_getSum__J(jobj)()
    }

    private static let java$util$LongSummaryStatistics_getMin__J = invoker("getMin", returns: jlong.jniType)
    public func getMin() throws -> jlong {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_getMin__J(jobj)()
    }

    private static let java$util$LongSummaryStatistics_getMax__J = invoker("getMax", returns: jlong.jniType)
    public func getMax() throws -> jlong {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_getMax__J(jobj)()
    }

    private static let java$util$LongSummaryStatistics_getAverage__D = invoker("getAverage", returns: jdouble.jniType)
    public func getAverage() throws -> jdouble {
        return try java$util$LongSummaryStatistics$.java$util$LongSummaryStatistics_getAverage__D(jobj)()
    }

    private static let java$util$LongSummaryStatistics_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$LongSummaryStatistics$ = java$util$LongSummaryStatistics

public protocol java$util$Map : JavaObject {
    func size() throws -> jint
    func isEmpty() throws -> jboolean
    func containsKey(a0: java$lang$Object?) throws -> jboolean
    func containsValue(a0: java$lang$Object?) throws -> jboolean
    func get(a0: java$lang$Object?) throws -> java$lang$Object?
    func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func remove(a0: java$lang$Object?) throws -> java$lang$Object?
    func putAll(a0: java$util$Map?) throws -> Void
    func clear() throws -> Void
    func keySet() throws -> java$util$Set?
    func values() throws -> java$util$Collection?
    func entrySet() throws -> java$util$Set?
    func equals(a0: java$lang$Object?) throws -> jboolean
    func hashCode() throws -> jint
    func getOrDefault(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func forEach(a0: java$util$function$BiConsumer?) throws -> Void
    func replaceAll(a0: java$util$function$BiFunction?) throws -> Void
    func putIfAbsent(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func remove(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean
    func replace(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean
    func replace(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func computeIfAbsent(a0: java$lang$Object?, _ a1: java$util$function$Function?) throws -> java$lang$Object?
    func computeIfPresent(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object?
    func compute(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object?
    func merge(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$util$function$BiFunction?) throws -> java$lang$Object?
}

public class java$util$Map$ : java$lang$Object$, java$util$Map {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Map_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Map_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$Map_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Map_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Map_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Map_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Map_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$Map_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$Map_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$Map_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$Map_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$Map_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Map_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Map_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object = invoker("getOrDefault", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    private static let java$util$Map_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    private static let java$util$Map_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object = invoker("putIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_remove_java$lang$Object_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z = invoker("replace", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_replace_java$lang$Object_java$lang$Object__java$lang$Object = invoker("replace", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$Map_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object = invoker("computeIfAbsent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/Function")))
    private static let java$util$Map_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("computeIfPresent", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    private static let java$util$Map_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("compute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
    private static let java$util$Map_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object = invoker("merge", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/util/function/BiFunction")))
}

public extension java$util$Map {
    func size() throws -> jint {
        return try java$util$Map$.java$util$Map_size__I(jobj)()
    }

    func isEmpty() throws -> jboolean {
        return try java$util$Map$.java$util$Map_isEmpty__Z(jobj)()
    }

    func containsKey(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Map$.java$util$Map_containsKey_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func containsValue(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Map$.java$util$Map_containsValue_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_put_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func remove(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_remove_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func putAll(a0: java$util$Map?) throws -> Void {
        return try java$util$Map$.java$util$Map_putAll_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    func clear() throws -> Void {
        return try java$util$Map$.java$util$Map_clear__V(jobj)()
    }

    func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Map$.java$util$Map_keySet__java$util$Set(jobj)())
    }

    func values() throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$Map$.java$util$Map_values__java$util$Collection(jobj)())
    }

    func entrySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Map$.java$util$Map_entrySet__java$util$Set(jobj)())
    }

    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Map$.java$util$Map_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func hashCode() throws -> jint {
        return try java$util$Map$.java$util$Map_hashCode__I(jobj)()
    }

    func getOrDefault(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_getOrDefault_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$Map$.java$util$Map_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$Map$.java$util$Map_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

    func putIfAbsent(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_putIfAbsent_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func remove(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean {
        return try java$util$Map$.java$util$Map_remove_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func replace(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean {
        return try java$util$Map$.java$util$Map_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    func replace(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_replace_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func computeIfAbsent(a0: java$lang$Object?, _ a1: java$util$function$Function?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_computeIfAbsent_java$lang$Object_java$util$function$Function__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func computeIfPresent(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_computeIfPresent_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func compute(a0: java$lang$Object?, _ a1: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_compute_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func merge(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$util$function$BiFunction?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Map$.java$util$Map_merge_java$lang$Object_java$lang$Object_java$util$function$BiFunction__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

}

public class java$util$MissingFormatArgumentException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$MissingFormatArgumentException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$MissingFormatArgumentException$.java$util$MissingFormatArgumentException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$MissingFormatArgumentException_getFormatSpecifier__java$lang$String = invoker("getFormatSpecifier", returns: JObjectType("java/lang/String"))
    public func getFormatSpecifier() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$MissingFormatArgumentException$.java$util$MissingFormatArgumentException_getFormatSpecifier__java$lang$String(jobj)())
    }

    private static let java$util$MissingFormatArgumentException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$MissingFormatArgumentException$ = java$util$MissingFormatArgumentException

public class java$util$MissingFormatWidthException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$MissingFormatWidthException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$MissingFormatWidthException$.java$util$MissingFormatWidthException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$MissingFormatWidthException_getFormatSpecifier__java$lang$String = invoker("getFormatSpecifier", returns: JObjectType("java/lang/String"))
    public func getFormatSpecifier() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$MissingFormatWidthException$.java$util$MissingFormatWidthException_getFormatSpecifier__java$lang$String(jobj)())
    }

    private static let java$util$MissingFormatWidthException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$MissingFormatWidthException$ = java$util$MissingFormatWidthException

public class java$util$MissingResourceException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$MissingResourceException_init_java$lang$String_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws {
        let jobj = try java$util$MissingResourceException$.java$util$MissingResourceException_init_java$lang$String_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$MissingResourceException_getClassName__java$lang$String = invoker("getClassName", returns: JObjectType("java/lang/String"))
    public func getClassName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$MissingResourceException$.java$util$MissingResourceException_getClassName__java$lang$String(jobj)())
    }

    private static let java$util$MissingResourceException_getKey__java$lang$String = invoker("getKey", returns: JObjectType("java/lang/String"))
    public func getKey() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$MissingResourceException$.java$util$MissingResourceException_getKey__java$lang$String(jobj)())
    }

}

public typealias java$util$MissingResourceException$ = java$util$MissingResourceException

public protocol java$util$NavigableMap : java$util$SortedMap {
    func lowerEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry?
    func lowerKey(a0: java$lang$Object?) throws -> java$lang$Object?
    func floorEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry?
    func floorKey(a0: java$lang$Object?) throws -> java$lang$Object?
    func ceilingEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry?
    func ceilingKey(a0: java$lang$Object?) throws -> java$lang$Object?
    func higherEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry?
    func higherKey(a0: java$lang$Object?) throws -> java$lang$Object?
    func firstEntry() throws -> java$util$Map$Entry?
    func lastEntry() throws -> java$util$Map$Entry?
    func pollFirstEntry() throws -> java$util$Map$Entry?
    func pollLastEntry() throws -> java$util$Map$Entry?
    func descendingMap() throws -> java$util$NavigableMap?
    func navigableKeySet() throws -> java$util$NavigableSet?
    func descendingKeySet() throws -> java$util$NavigableSet?
    func subMap(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableMap?
    func headMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap?
    func tailMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap?
    func subMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedMap?
    func headMap(a0: java$lang$Object?) throws -> java$util$SortedMap?
    func tailMap(a0: java$lang$Object?) throws -> java$util$SortedMap?
}

public class java$util$NavigableMap$ : java$lang$Object$, java$util$NavigableMap, java$util$SortedMap {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$NavigableMap_lowerEntry_java$lang$Object__java$util$Map$Entry = invoker("lowerEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_lowerKey_java$lang$Object__java$lang$Object = invoker("lowerKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_floorEntry_java$lang$Object__java$util$Map$Entry = invoker("floorEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_floorKey_java$lang$Object__java$lang$Object = invoker("floorKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_ceilingEntry_java$lang$Object__java$util$Map$Entry = invoker("ceilingEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_ceilingKey_java$lang$Object__java$lang$Object = invoker("ceilingKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_higherEntry_java$lang$Object__java$util$Map$Entry = invoker("higherEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_higherKey_java$lang$Object__java$lang$Object = invoker("higherKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_firstEntry__java$util$Map$Entry = invoker("firstEntry", returns: JObjectType("java/util/Map$Entry"))
    private static let java$util$NavigableMap_lastEntry__java$util$Map$Entry = invoker("lastEntry", returns: JObjectType("java/util/Map$Entry"))
    private static let java$util$NavigableMap_pollFirstEntry__java$util$Map$Entry = invoker("pollFirstEntry", returns: JObjectType("java/util/Map$Entry"))
    private static let java$util$NavigableMap_pollLastEntry__java$util$Map$Entry = invoker("pollLastEntry", returns: JObjectType("java/util/Map$Entry"))
    private static let java$util$NavigableMap_descendingMap__java$util$NavigableMap = invoker("descendingMap", returns: JObjectType("java/util/NavigableMap"))
    private static let java$util$NavigableMap_navigableKeySet__java$util$NavigableSet = invoker("navigableKeySet", returns: JObjectType("java/util/NavigableSet"))
    private static let java$util$NavigableMap_descendingKeySet__java$util$NavigableSet = invoker("descendingKeySet", returns: JObjectType("java/util/NavigableSet"))
    private static let java$util$NavigableMap_subMap_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableMap = invoker("subMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType, JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableMap_headMap_java$lang$Object_Z__java$util$NavigableMap = invoker("headMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableMap_tailMap_java$lang$Object_Z__java$util$NavigableMap = invoker("tailMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap = invoker("subMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_headMap_java$lang$Object__java$util$SortedMap = invoker("headMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableMap_tailMap_java$lang$Object__java$util$SortedMap = invoker("tailMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
}

public extension java$util$NavigableMap {
    func lowerEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_lowerEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    func lowerKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableMap$.java$util$NavigableMap_lowerKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func floorEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_floorEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    func floorKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableMap$.java$util$NavigableMap_floorKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func ceilingEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_ceilingEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    func ceilingKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableMap$.java$util$NavigableMap_ceilingKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func higherEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_higherEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    func higherKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableMap$.java$util$NavigableMap_higherKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func firstEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_firstEntry__java$util$Map$Entry(jobj)())
    }

    func lastEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_lastEntry__java$util$Map$Entry(jobj)())
    }

    func pollFirstEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_pollFirstEntry__java$util$Map$Entry(jobj)())
    }

    func pollLastEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$NavigableMap$.java$util$NavigableMap_pollLastEntry__java$util$Map$Entry(jobj)())
    }

    func descendingMap() throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_descendingMap__java$util$NavigableMap(jobj)())
    }

    func navigableKeySet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableMap$.java$util$NavigableMap_navigableKeySet__java$util$NavigableSet(jobj)())
    }

    func descendingKeySet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableMap$.java$util$NavigableMap_descendingKeySet__java$util$NavigableSet(jobj)())
    }

    func subMap(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_subMap_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3))
    }

    func headMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_headMap_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1))
    }

    func tailMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_tailMap_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1))
    }

    func subMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func headMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_headMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

    func tailMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$NavigableMap$.java$util$NavigableMap_tailMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

}

public protocol java$util$NavigableSet : java$util$SortedSet {
    func lower(a0: java$lang$Object?) throws -> java$lang$Object?
    func floor(a0: java$lang$Object?) throws -> java$lang$Object?
    func ceiling(a0: java$lang$Object?) throws -> java$lang$Object?
    func higher(a0: java$lang$Object?) throws -> java$lang$Object?
    func pollFirst() throws -> java$lang$Object?
    func pollLast() throws -> java$lang$Object?
    func iterator() throws -> java$util$Iterator?
    func descendingSet() throws -> java$util$NavigableSet?
    func descendingIterator() throws -> java$util$Iterator?
    func subSet(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableSet?
    func headSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet?
    func tailSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet?
    func subSet(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedSet?
    func headSet(a0: java$lang$Object?) throws -> java$util$SortedSet?
    func tailSet(a0: java$lang$Object?) throws -> java$util$SortedSet?
}

public class java$util$NavigableSet$ : java$lang$Object$, java$util$NavigableSet, java$util$SortedSet {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$NavigableSet_lower_java$lang$Object__java$lang$Object = invoker("lower", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_floor_java$lang$Object__java$lang$Object = invoker("floor", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_ceiling_java$lang$Object__java$lang$Object = invoker("ceiling", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_higher_java$lang$Object__java$lang$Object = invoker("higher", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_pollFirst__java$lang$Object = invoker("pollFirst", returns: JObjectType("java/lang/Object"))
    private static let java$util$NavigableSet_pollLast__java$lang$Object = invoker("pollLast", returns: JObjectType("java/lang/Object"))
    private static let java$util$NavigableSet_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$NavigableSet_descendingSet__java$util$NavigableSet = invoker("descendingSet", returns: JObjectType("java/util/NavigableSet"))
    private static let java$util$NavigableSet_descendingIterator__java$util$Iterator = invoker("descendingIterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$NavigableSet_subSet_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableSet = invoker("subSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType, JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableSet_headSet_java$lang$Object_Z__java$util$NavigableSet = invoker("headSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableSet_tailSet_java$lang$Object_Z__java$util$NavigableSet = invoker("tailSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    private static let java$util$NavigableSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet = invoker("subSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_headSet_java$lang$Object__java$util$SortedSet = invoker("headSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$NavigableSet_tailSet_java$lang$Object__java$util$SortedSet = invoker("tailSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
}

public extension java$util$NavigableSet {
    func lower(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_lower_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func floor(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_floor_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func ceiling(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_ceiling_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func higher(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_higher_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func pollFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_pollFirst__java$lang$Object(jobj)())
    }

    func pollLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$NavigableSet$.java$util$NavigableSet_pollLast__java$lang$Object(jobj)())
    }

    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$NavigableSet$.java$util$NavigableSet_iterator__java$util$Iterator(jobj)())
    }

    func descendingSet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_descendingSet__java$util$NavigableSet(jobj)())
    }

    func descendingIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$NavigableSet$.java$util$NavigableSet_descendingIterator__java$util$Iterator(jobj)())
    }

    func subSet(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_subSet_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3))
    }

    func headSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_headSet_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1))
    }

    func tailSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_tailSet_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1))
    }

    func subSet(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func headSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_headSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

    func tailSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$NavigableSet$.java$util$NavigableSet_tailSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

}

public class java$util$NoSuchElementException : java$lang$RuntimeException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$NoSuchElementException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$NoSuchElementException$.java$util$NoSuchElementException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$NoSuchElementException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$NoSuchElementException$.java$util$NoSuchElementException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$NoSuchElementException$ = java$util$NoSuchElementException

public final class java$util$Objects : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Objects_equals_java$lang$Object_java$lang$Object__Z = svoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public static func equals(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean {
        return try java$util$Objects$.java$util$Objects_equals_java$lang$Object_java$lang$Object__Z(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Objects_deepEquals_java$lang$Object_java$lang$Object__Z = svoker("deepEquals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public static func deepEquals(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> jboolean {
        return try java$util$Objects$.java$util$Objects_deepEquals_java$lang$Object_java$lang$Object__Z(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Objects_hashCode_java$lang$Object__I = svoker("hashCode", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func hashCode(a0: java$lang$Object?) throws -> jint {
        return try java$util$Objects$.java$util$Objects_hashCode_java$lang$Object__I(a0?.jobj ?? nil)
    }

    private static let java$util$Objects_hash_Ajava$lang$Object__I = svoker("hash", returns: jint.jniType, arguments: (JArray(JObjectType("java/lang/Object"))))
    public static func hash(a0: [java$lang$Object?]?) throws -> jint {
        return try java$util$Objects$.java$util$Objects_hash_Ajava$lang$Object__I(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Objects_toString_java$lang$Object__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/Object")))
    public static func toString(a0: java$lang$Object?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Objects$.java$util$Objects_toString_java$lang$Object__java$lang$String(a0?.jobj ?? nil))
    }

    private static let java$util$Objects_toString_java$lang$Object_java$lang$String__java$lang$String = svoker("toString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/String")))
    public static func toString(a0: java$lang$Object?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Objects$.java$util$Objects_toString_java$lang$Object_java$lang$String__java$lang$String(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Objects_compare_java$lang$Object_java$lang$Object_java$util$Comparator__I = svoker("compare", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/util/Comparator")))
    public static func compare(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$util$Comparator?) throws -> jint {
        return try java$util$Objects$.java$util$Objects_compare_java$lang$Object_java$lang$Object_java$util$Comparator__I(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Objects_requireNonNull_java$lang$Object__java$lang$Object = svoker("requireNonNull", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public static func requireNonNull(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Objects$.java$util$Objects_requireNonNull_java$lang$Object__java$lang$Object(a0?.jobj ?? nil))
    }

    private static let java$util$Objects_requireNonNull_java$lang$Object_java$lang$String__java$lang$Object = svoker("requireNonNull", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/String")))
    public static func requireNonNull(a0: java$lang$Object?, _ a1: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Objects$.java$util$Objects_requireNonNull_java$lang$Object_java$lang$String__java$lang$Object(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Objects_isNull_java$lang$Object__Z = svoker("isNull", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func isNull(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Objects$.java$util$Objects_isNull_java$lang$Object__Z(a0?.jobj ?? nil)
    }

    private static let java$util$Objects_nonNull_java$lang$Object__Z = svoker("nonNull", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public static func nonNull(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Objects$.java$util$Objects_nonNull_java$lang$Object__Z(a0?.jobj ?? nil)
    }

    private static let java$util$Objects_requireNonNull_java$lang$Object_java$util$function$Supplier__java$lang$Object = svoker("requireNonNull", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/util/function/Supplier")))
    public static func requireNonNull(a0: java$lang$Object?, _ a1: java$util$function$Supplier?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Objects$.java$util$Objects_requireNonNull_java$lang$Object_java$util$function$Supplier__java$lang$Object(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias java$util$Objects$ = java$util$Objects

public class java$util$Observable : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Observable_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Observable$.java$util$Observable_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Observable_addObserver_java$util$Observer__V = invoker("addObserver", returns: JVoid.jniType, arguments: (JObjectType("java/util/Observer")))
    public func addObserver(a0: java$util$Observer?) throws -> Void {
        return try java$util$Observable$.java$util$Observable_addObserver_java$util$Observer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Observable_deleteObserver_java$util$Observer__V = invoker("deleteObserver", returns: JVoid.jniType, arguments: (JObjectType("java/util/Observer")))
    public func deleteObserver(a0: java$util$Observer?) throws -> Void {
        return try java$util$Observable$.java$util$Observable_deleteObserver_java$util$Observer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Observable_notifyObservers__V = invoker("notifyObservers", returns: JVoid.jniType)
    public func notifyObservers() throws -> Void {
        return try java$util$Observable$.java$util$Observable_notifyObservers__V(jobj)()
    }

    private static let java$util$Observable_notifyObservers_java$lang$Object__V = invoker("notifyObservers", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func notifyObservers(a0: java$lang$Object?) throws -> Void {
        return try java$util$Observable$.java$util$Observable_notifyObservers_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Observable_deleteObservers__V = invoker("deleteObservers", returns: JVoid.jniType)
    public func deleteObservers() throws -> Void {
        return try java$util$Observable$.java$util$Observable_deleteObservers__V(jobj)()
    }

    private static let java$util$Observable_hasChanged__Z = invoker("hasChanged", returns: jboolean.jniType)
    public func hasChanged() throws -> jboolean {
        return try java$util$Observable$.java$util$Observable_hasChanged__Z(jobj)()
    }

    private static let java$util$Observable_countObservers__I = invoker("countObservers", returns: jint.jniType)
    public func countObservers() throws -> jint {
        return try java$util$Observable$.java$util$Observable_countObservers__I(jobj)()
    }

}

public typealias java$util$Observable$ = java$util$Observable

public protocol java$util$Observer : JavaObject {
    func update(a0: java$util$Observable?, _ a1: java$lang$Object?) throws -> Void
}

public class java$util$Observer$ : java$lang$Object$, java$util$Observer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Observer_update_java$util$Observable_java$lang$Object__V = invoker("update", returns: JVoid.jniType, arguments: (JObjectType("java/util/Observable"), JObjectType("java/lang/Object")))
}

public extension java$util$Observer {
    func update(a0: java$util$Observable?, _ a1: java$lang$Object?) throws -> Void {
        return try java$util$Observer$.java$util$Observer_update_java$util$Observable_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public final class java$util$Optional : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Optional_empty__java$util$Optional = svoker("empty", returns: JObjectType("java/util/Optional"))
    public static func empty() throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_empty__java$util$Optional())
    }

    private static let java$util$Optional_of_java$lang$Object__java$util$Optional = svoker("of", returns: JObjectType("java/util/Optional"), arguments: (JObjectType("java/lang/Object")))
    public static func of(a0: java$lang$Object?) throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_of_java$lang$Object__java$util$Optional(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_ofNullable_java$lang$Object__java$util$Optional = svoker("ofNullable", returns: JObjectType("java/util/Optional"), arguments: (JObjectType("java/lang/Object")))
    public static func ofNullable(a0: java$lang$Object?) throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_ofNullable_java$lang$Object__java$util$Optional(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_get__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"))
    public func get() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Optional$.java$util$Optional_get__java$lang$Object(jobj)())
    }

    private static let java$util$Optional_isPresent__Z = invoker("isPresent", returns: jboolean.jniType)
    public func isPresent() throws -> jboolean {
        return try java$util$Optional$.java$util$Optional_isPresent__Z(jobj)()
    }

    private static let java$util$Optional_ifPresent_java$util$function$Consumer__V = invoker("ifPresent", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    public func ifPresent(a0: java$util$function$Consumer?) throws -> Void {
        return try java$util$Optional$.java$util$Optional_ifPresent_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Optional_filter_java$util$function$Predicate__java$util$Optional = invoker("filter", returns: JObjectType("java/util/Optional"), arguments: (JObjectType("java/util/function/Predicate")))
    public func filter(a0: java$util$function$Predicate?) throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_filter_java$util$function$Predicate__java$util$Optional(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_map_java$util$function$Function__java$util$Optional = invoker("map", returns: JObjectType("java/util/Optional"), arguments: (JObjectType("java/util/function/Function")))
    public func map(a0: java$util$function$Function?) throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_map_java$util$function$Function__java$util$Optional(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_flatMap_java$util$function$Function__java$util$Optional = invoker("flatMap", returns: JObjectType("java/util/Optional"), arguments: (JObjectType("java/util/function/Function")))
    public func flatMap(a0: java$util$function$Function?) throws -> java$util$Optional? {
        return try java$util$Optional$(jobj: java$util$Optional$.java$util$Optional_flatMap_java$util$function$Function__java$util$Optional(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_orElse_java$lang$Object__java$lang$Object = invoker("orElse", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func orElse(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Optional$.java$util$Optional_orElse_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_orElseGet_java$util$function$Supplier__java$lang$Object = invoker("orElseGet", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/function/Supplier")))
    public func orElseGet(a0: java$util$function$Supplier?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Optional$.java$util$Optional_orElseGet_java$util$function$Supplier__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_orElseThrow_java$util$function$Supplier__java$lang$Object = invoker("orElseThrow", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/util/function/Supplier")))
    public func orElseThrow(a0: java$util$function$Supplier?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Optional$.java$util$Optional_orElseThrow_java$util$function$Supplier__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Optional_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Optional_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Optional_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$Optional$ = java$util$Optional

public final class java$util$OptionalDouble : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$OptionalDouble_empty__java$util$OptionalDouble = svoker("empty", returns: JObjectType("java/util/OptionalDouble"))
    public static func empty() throws -> java$util$OptionalDouble? {
        return try java$util$OptionalDouble$(jobj: java$util$OptionalDouble$.java$util$OptionalDouble_empty__java$util$OptionalDouble())
    }

    private static let java$util$OptionalDouble_of_D__java$util$OptionalDouble = svoker("of", returns: JObjectType("java/util/OptionalDouble"), arguments: (jdouble.jniType))
    public static func of(a0: jdouble) throws -> java$util$OptionalDouble? {
        return try java$util$OptionalDouble$(jobj: java$util$OptionalDouble$.java$util$OptionalDouble_of_D__java$util$OptionalDouble(a0))
    }

    private static let java$util$OptionalDouble_getAsDouble__D = invoker("getAsDouble", returns: jdouble.jniType)
    public func getAsDouble() throws -> jdouble {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_getAsDouble__D(jobj)()
    }

    private static let java$util$OptionalDouble_isPresent__Z = invoker("isPresent", returns: jboolean.jniType)
    public func isPresent() throws -> jboolean {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_isPresent__Z(jobj)()
    }

    private static let java$util$OptionalDouble_ifPresent_java$util$function$DoubleConsumer__V = invoker("ifPresent", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/DoubleConsumer")))
    public func ifPresent(a0: java$util$function$DoubleConsumer?) throws -> Void {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_ifPresent_java$util$function$DoubleConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalDouble_orElse_D__D = invoker("orElse", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public func orElse(a0: jdouble) throws -> jdouble {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_orElse_D__D(jobj)(a0)
    }

    private static let java$util$OptionalDouble_orElseGet_java$util$function$DoubleSupplier__D = invoker("orElseGet", returns: jdouble.jniType, arguments: (JObjectType("java/util/function/DoubleSupplier")))
    public func orElseGet(a0: java$util$function$DoubleSupplier?) throws -> jdouble {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_orElseGet_java$util$function$DoubleSupplier__D(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalDouble_orElseThrow_java$util$function$Supplier__D = invoker("orElseThrow", returns: jdouble.jniType, arguments: (JObjectType("java/util/function/Supplier")))
    public func orElseThrow(a0: java$util$function$Supplier?) throws -> jdouble {
        return try java$util$OptionalDouble$.java$util$OptionalDouble_orElseThrow_java$util$function$Supplier__D(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalDouble_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$OptionalDouble_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$OptionalDouble_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$OptionalDouble$ = java$util$OptionalDouble

public final class java$util$OptionalInt : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$OptionalInt_empty__java$util$OptionalInt = svoker("empty", returns: JObjectType("java/util/OptionalInt"))
    public static func empty() throws -> java$util$OptionalInt? {
        return try java$util$OptionalInt$(jobj: java$util$OptionalInt$.java$util$OptionalInt_empty__java$util$OptionalInt())
    }

    private static let java$util$OptionalInt_of_I__java$util$OptionalInt = svoker("of", returns: JObjectType("java/util/OptionalInt"), arguments: (jint.jniType))
    public static func of(a0: jint) throws -> java$util$OptionalInt? {
        return try java$util$OptionalInt$(jobj: java$util$OptionalInt$.java$util$OptionalInt_of_I__java$util$OptionalInt(a0))
    }

    private static let java$util$OptionalInt_getAsInt__I = invoker("getAsInt", returns: jint.jniType)
    public func getAsInt() throws -> jint {
        return try java$util$OptionalInt$.java$util$OptionalInt_getAsInt__I(jobj)()
    }

    private static let java$util$OptionalInt_isPresent__Z = invoker("isPresent", returns: jboolean.jniType)
    public func isPresent() throws -> jboolean {
        return try java$util$OptionalInt$.java$util$OptionalInt_isPresent__Z(jobj)()
    }

    private static let java$util$OptionalInt_ifPresent_java$util$function$IntConsumer__V = invoker("ifPresent", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/IntConsumer")))
    public func ifPresent(a0: java$util$function$IntConsumer?) throws -> Void {
        return try java$util$OptionalInt$.java$util$OptionalInt_ifPresent_java$util$function$IntConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalInt_orElse_I__I = invoker("orElse", returns: jint.jniType, arguments: (jint.jniType))
    public func orElse(a0: jint) throws -> jint {
        return try java$util$OptionalInt$.java$util$OptionalInt_orElse_I__I(jobj)(a0)
    }

    private static let java$util$OptionalInt_orElseGet_java$util$function$IntSupplier__I = invoker("orElseGet", returns: jint.jniType, arguments: (JObjectType("java/util/function/IntSupplier")))
    public func orElseGet(a0: java$util$function$IntSupplier?) throws -> jint {
        return try java$util$OptionalInt$.java$util$OptionalInt_orElseGet_java$util$function$IntSupplier__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalInt_orElseThrow_java$util$function$Supplier__I = invoker("orElseThrow", returns: jint.jniType, arguments: (JObjectType("java/util/function/Supplier")))
    public func orElseThrow(a0: java$util$function$Supplier?) throws -> jint {
        return try java$util$OptionalInt$.java$util$OptionalInt_orElseThrow_java$util$function$Supplier__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalInt_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$OptionalInt_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$OptionalInt_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$OptionalInt$ = java$util$OptionalInt

public final class java$util$OptionalLong : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$OptionalLong_empty__java$util$OptionalLong = svoker("empty", returns: JObjectType("java/util/OptionalLong"))
    public static func empty() throws -> java$util$OptionalLong? {
        return try java$util$OptionalLong$(jobj: java$util$OptionalLong$.java$util$OptionalLong_empty__java$util$OptionalLong())
    }

    private static let java$util$OptionalLong_of_J__java$util$OptionalLong = svoker("of", returns: JObjectType("java/util/OptionalLong"), arguments: (jlong.jniType))
    public static func of(a0: jlong) throws -> java$util$OptionalLong? {
        return try java$util$OptionalLong$(jobj: java$util$OptionalLong$.java$util$OptionalLong_of_J__java$util$OptionalLong(a0))
    }

    private static let java$util$OptionalLong_getAsLong__J = invoker("getAsLong", returns: jlong.jniType)
    public func getAsLong() throws -> jlong {
        return try java$util$OptionalLong$.java$util$OptionalLong_getAsLong__J(jobj)()
    }

    private static let java$util$OptionalLong_isPresent__Z = invoker("isPresent", returns: jboolean.jniType)
    public func isPresent() throws -> jboolean {
        return try java$util$OptionalLong$.java$util$OptionalLong_isPresent__Z(jobj)()
    }

    private static let java$util$OptionalLong_ifPresent_java$util$function$LongConsumer__V = invoker("ifPresent", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/LongConsumer")))
    public func ifPresent(a0: java$util$function$LongConsumer?) throws -> Void {
        return try java$util$OptionalLong$.java$util$OptionalLong_ifPresent_java$util$function$LongConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalLong_orElse_J__J = invoker("orElse", returns: jlong.jniType, arguments: (jlong.jniType))
    public func orElse(a0: jlong) throws -> jlong {
        return try java$util$OptionalLong$.java$util$OptionalLong_orElse_J__J(jobj)(a0)
    }

    private static let java$util$OptionalLong_orElseGet_java$util$function$LongSupplier__J = invoker("orElseGet", returns: jlong.jniType, arguments: (JObjectType("java/util/function/LongSupplier")))
    public func orElseGet(a0: java$util$function$LongSupplier?) throws -> jlong {
        return try java$util$OptionalLong$.java$util$OptionalLong_orElseGet_java$util$function$LongSupplier__J(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalLong_orElseThrow_java$util$function$Supplier__J = invoker("orElseThrow", returns: jlong.jniType, arguments: (JObjectType("java/util/function/Supplier")))
    public func orElseThrow(a0: java$util$function$Supplier?) throws -> jlong {
        return try java$util$OptionalLong$.java$util$OptionalLong_orElseThrow_java$util$function$Supplier__J(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$OptionalLong_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$OptionalLong_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$OptionalLong_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$OptionalLong$ = java$util$OptionalLong

public protocol java$util$PrimitiveIterator : java$util$Iterator {
    func forEachRemaining(a0: java$lang$Object?) throws -> Void
}

public class java$util$PrimitiveIterator$ : java$lang$Object$, java$util$PrimitiveIterator, java$util$Iterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$PrimitiveIterator_forEachRemaining_java$lang$Object__V = invoker("forEachRemaining", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
}

public extension java$util$PrimitiveIterator {
    func forEachRemaining(a0: java$lang$Object?) throws -> Void {
        return try java$util$PrimitiveIterator$.java$util$PrimitiveIterator_forEachRemaining_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

}

public class java$util$PriorityQueue : java$util$AbstractQueue$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$PriorityQueue_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_java$util$Comparator__V = constructor((JObjectType("java/util/Comparator")))
    public convenience init!(_ a0: java$util$Comparator?) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_java$util$Comparator__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_I_java$util$Comparator__V = constructor((jint.jniType, JObjectType("java/util/Comparator")))
    public convenience init!(_ a0: jint, _ a1: java$util$Comparator?) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_I_java$util$Comparator__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_java$util$PriorityQueue__V = constructor((JObjectType("java/util/PriorityQueue")))
    public convenience init!(_ a0: java$util$PriorityQueue?) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_java$util$PriorityQueue__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_init_java$util$SortedSet__V = constructor((JObjectType("java/util/SortedSet")))
    public convenience init!(_ a0: java$util$SortedSet?) throws {
        let jobj = try java$util$PriorityQueue$.java$util$PriorityQueue_init_java$util$SortedSet__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PriorityQueue_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$PriorityQueue_offer_java$lang$Object__Z = invoker("offer", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func offer(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$PriorityQueue$.java$util$PriorityQueue_offer_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$PriorityQueue_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
    public func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$PriorityQueue$.java$util$PriorityQueue_peek__java$lang$Object(jobj)())
    }

    private static let java$util$PriorityQueue_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$PriorityQueue_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$PriorityQueue_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$PriorityQueue_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$PriorityQueue_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$PriorityQueue_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$PriorityQueue_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$PriorityQueue_poll__java$lang$Object = invoker("poll", returns: JObjectType("java/lang/Object"))
    public func poll() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$PriorityQueue$.java$util$PriorityQueue_poll__java$lang$Object(jobj)())
    }

    private static let java$util$PriorityQueue_comparator__java$util$Comparator = invoker("comparator", returns: JObjectType("java/util/Comparator"))
    public func comparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$PriorityQueue$.java$util$PriorityQueue_comparator__java$util$Comparator(jobj)())
    }

    private static let java$util$PriorityQueue_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$PriorityQueue$.java$util$PriorityQueue_spliterator__java$util$Spliterator(jobj)())
    }

}

public typealias java$util$PriorityQueue$ = java$util$PriorityQueue

public class java$util$Properties : java$util$Hashtable$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Properties_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Properties$.java$util$Properties_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Properties_init_java$util$Properties__V = constructor((JObjectType("java/util/Properties")))
    public convenience init!(_ a0: java$util$Properties?) throws {
        let jobj = try java$util$Properties$.java$util$Properties_init_java$util$Properties__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Properties_setProperty_java$lang$String_java$lang$String__java$lang$Object = invoker("setProperty", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func setProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Properties$.java$util$Properties_setProperty_java$lang$String_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Properties_load_java$io$Reader__V = invoker("load", returns: JVoid.jniType, arguments: (JObjectType("java/io/Reader")))
    public func load(a0: java$io$Reader?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_load_java$io$Reader__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Properties_load_java$io$InputStream__V = invoker("load", returns: JVoid.jniType, arguments: (JObjectType("java/io/InputStream")))
    public func load(a0: java$io$InputStream?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_load_java$io$InputStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Properties_save_java$io$OutputStream_java$lang$String__V = invoker("save", returns: JVoid.jniType, arguments: (JObjectType("java/io/OutputStream"), JObjectType("java/lang/String")))
    public func save(a0: java$io$OutputStream?, _ a1: java$lang$String?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_save_java$io$OutputStream_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Properties_store_java$io$Writer_java$lang$String__V = invoker("store", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer"), JObjectType("java/lang/String")))
    public func store(a0: java$io$Writer?, _ a1: java$lang$String?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_store_java$io$Writer_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Properties_store_java$io$OutputStream_java$lang$String__V = invoker("store", returns: JVoid.jniType, arguments: (JObjectType("java/io/OutputStream"), JObjectType("java/lang/String")))
    public func store(a0: java$io$OutputStream?, _ a1: java$lang$String?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_store_java$io$OutputStream_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Properties_loadFromXML_java$io$InputStream__V = invoker("loadFromXML", returns: JVoid.jniType, arguments: (JObjectType("java/io/InputStream")))
    public func loadFromXML(a0: java$io$InputStream?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_loadFromXML_java$io$InputStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Properties_storeToXML_java$io$OutputStream_java$lang$String__V = invoker("storeToXML", returns: JVoid.jniType, arguments: (JObjectType("java/io/OutputStream"), JObjectType("java/lang/String")))
    public func storeToXML(a0: java$io$OutputStream?, _ a1: java$lang$String?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_storeToXML_java$io$OutputStream_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Properties_storeToXML_java$io$OutputStream_java$lang$String_java$lang$String__V = invoker("storeToXML", returns: JVoid.jniType, arguments: (JObjectType("java/io/OutputStream"), JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func storeToXML(a0: java$io$OutputStream?, _ a1: java$lang$String?, _ a2: java$lang$String?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_storeToXML_java$io$OutputStream_java$lang$String_java$lang$String__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$Properties_getProperty_java$lang$String__java$lang$String = invoker("getProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func getProperty(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Properties$.java$util$Properties_getProperty_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Properties_getProperty_java$lang$String_java$lang$String__java$lang$String = invoker("getProperty", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public func getProperty(a0: java$lang$String?, _ a1: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Properties$.java$util$Properties_getProperty_java$lang$String_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$Properties_propertyNames__java$util$Enumeration = invoker("propertyNames", returns: JObjectType("java/util/Enumeration"))
    public func propertyNames() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Properties$.java$util$Properties_propertyNames__java$util$Enumeration(jobj)())
    }

    private static let java$util$Properties_stringPropertyNames__java$util$Set = invoker("stringPropertyNames", returns: JObjectType("java/util/Set"))
    public func stringPropertyNames() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$Properties$.java$util$Properties_stringPropertyNames__java$util$Set(jobj)())
    }

    private static let java$util$Properties_list_java$io$PrintStream__V = invoker("list", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintStream")))
    public func list(a0: java$io$PrintStream?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_list_java$io$PrintStream__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Properties_list_java$io$PrintWriter__V = invoker("list", returns: JVoid.jniType, arguments: (JObjectType("java/io/PrintWriter")))
    public func list(a0: java$io$PrintWriter?) throws -> Void {
        return try java$util$Properties$.java$util$Properties_list_java$io$PrintWriter__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$Properties$ = java$util$Properties

public class java$util$PropertyResourceBundle : java$util$ResourceBundle$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$PropertyResourceBundle_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$util$PropertyResourceBundle$.java$util$PropertyResourceBundle_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PropertyResourceBundle_init_java$io$Reader__V = constructor((JObjectType("java/io/Reader")))
    public convenience init!(_ a0: java$io$Reader?) throws {
        let jobj = try java$util$PropertyResourceBundle$.java$util$PropertyResourceBundle_init_java$io$Reader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$PropertyResourceBundle_handleGetObject_java$lang$String__java$lang$Object = invoker("handleGetObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func handleGetObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$PropertyResourceBundle$.java$util$PropertyResourceBundle_handleGetObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$PropertyResourceBundle_getKeys__java$util$Enumeration = invoker("getKeys", returns: JObjectType("java/util/Enumeration"))
}

public typealias java$util$PropertyResourceBundle$ = java$util$PropertyResourceBundle

public protocol java$util$Queue : java$util$Collection {
    func add(a0: java$lang$Object?) throws -> jboolean
    func offer(a0: java$lang$Object?) throws -> jboolean
    func remove() throws -> java$lang$Object?
    func poll() throws -> java$lang$Object?
    func element() throws -> java$lang$Object?
    func peek() throws -> java$lang$Object?
}

public class java$util$Queue$ : java$lang$Object$, java$util$Queue, java$util$Collection {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Queue_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Queue_offer_java$lang$Object__Z = invoker("offer", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Queue_remove__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"))
    private static let java$util$Queue_poll__java$lang$Object = invoker("poll", returns: JObjectType("java/lang/Object"))
    private static let java$util$Queue_element__java$lang$Object = invoker("element", returns: JObjectType("java/lang/Object"))
    private static let java$util$Queue_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
}

public extension java$util$Queue {
    func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Queue$.java$util$Queue_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func offer(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Queue$.java$util$Queue_offer_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func remove() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Queue$.java$util$Queue_remove__java$lang$Object(jobj)())
    }

    func poll() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Queue$.java$util$Queue_poll__java$lang$Object(jobj)())
    }

    func element() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Queue$.java$util$Queue_element__java$lang$Object(jobj)())
    }

    func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Queue$.java$util$Queue_peek__java$lang$Object(jobj)())
    }

}

public class java$util$Random : java$lang$Object$, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Random_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Random$.java$util$Random_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Random_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$util$Random$.java$util$Random_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$Random_setSeed_J__V = invoker("setSeed", returns: JVoid.jniType, arguments: (jlong.jniType))
    public func setSeed(a0: jlong) throws -> Void {
        return try java$util$Random$.java$util$Random_setSeed_J__V(jobj)(a0)
    }

    private static let java$util$Random_nextBytes_AB__V = invoker("nextBytes", returns: JVoid.jniType, arguments: (JArray(jbyte.jniType)))
    public func nextBytes(a0: [jbyte]?) throws -> Void {
        return try java$util$Random$.java$util$Random_nextBytes_AB__V(jobj)(a0?.arrayToJArray() ?? nil)
    }

    private static let java$util$Random_nextInt__I = invoker("nextInt", returns: jint.jniType)
    public func nextInt() throws -> jint {
        return try java$util$Random$.java$util$Random_nextInt__I(jobj)()
    }

    private static let java$util$Random_nextInt_I__I = invoker("nextInt", returns: jint.jniType, arguments: (jint.jniType))
    public func nextInt(a0: jint) throws -> jint {
        return try java$util$Random$.java$util$Random_nextInt_I__I(jobj)(a0)
    }

    private static let java$util$Random_nextLong__J = invoker("nextLong", returns: jlong.jniType)
    public func nextLong() throws -> jlong {
        return try java$util$Random$.java$util$Random_nextLong__J(jobj)()
    }

    private static let java$util$Random_nextBoolean__Z = invoker("nextBoolean", returns: jboolean.jniType)
    public func nextBoolean() throws -> jboolean {
        return try java$util$Random$.java$util$Random_nextBoolean__Z(jobj)()
    }

    private static let java$util$Random_nextFloat__F = invoker("nextFloat", returns: jfloat.jniType)
    public func nextFloat() throws -> jfloat {
        return try java$util$Random$.java$util$Random_nextFloat__F(jobj)()
    }

    private static let java$util$Random_nextDouble__D = invoker("nextDouble", returns: jdouble.jniType)
    public func nextDouble() throws -> jdouble {
        return try java$util$Random$.java$util$Random_nextDouble__D(jobj)()
    }

    private static let java$util$Random_nextGaussian__D = invoker("nextGaussian", returns: jdouble.jniType)
    public func nextGaussian() throws -> jdouble {
        return try java$util$Random$.java$util$Random_nextGaussian__D(jobj)()
    }

    private static let java$util$Random_ints_J__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jlong.jniType))
    public func ints(a0: jlong) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Random$.java$util$Random_ints_J__java$util$stream$IntStream(jobj)(a0))
    }

    private static let java$util$Random_ints__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"))
    public func ints() throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Random$.java$util$Random_ints__java$util$stream$IntStream(jobj)())
    }

    private static let java$util$Random_ints_J_I_I__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jlong.jniType, jint.jniType, jint.jniType))
    public func ints(a0: jlong, _ a1: jint, _ a2: jint) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Random$.java$util$Random_ints_J_I_I__java$util$stream$IntStream(jobj)(a0, a1, a2))
    }

    private static let java$util$Random_ints_I_I__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jint.jniType, jint.jniType))
    public func ints(a0: jint, _ a1: jint) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$Random$.java$util$Random_ints_I_I__java$util$stream$IntStream(jobj)(a0, a1))
    }

    private static let java$util$Random_longs_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType))
    public func longs(a0: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Random$.java$util$Random_longs_J__java$util$stream$LongStream(jobj)(a0))
    }

    private static let java$util$Random_longs__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"))
    public func longs() throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Random$.java$util$Random_longs__java$util$stream$LongStream(jobj)())
    }

    private static let java$util$Random_longs_J_J_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType, jlong.jniType, jlong.jniType))
    public func longs(a0: jlong, _ a1: jlong, _ a2: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Random$.java$util$Random_longs_J_J_J__java$util$stream$LongStream(jobj)(a0, a1, a2))
    }

    private static let java$util$Random_longs_J_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType, jlong.jniType))
    public func longs(a0: jlong, _ a1: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$Random$.java$util$Random_longs_J_J__java$util$stream$LongStream(jobj)(a0, a1))
    }

    private static let java$util$Random_doubles_J__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jlong.jniType))
    public func doubles(a0: jlong) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Random$.java$util$Random_doubles_J__java$util$stream$DoubleStream(jobj)(a0))
    }

    private static let java$util$Random_doubles__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"))
    public func doubles() throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Random$.java$util$Random_doubles__java$util$stream$DoubleStream(jobj)())
    }

    private static let java$util$Random_doubles_J_D_D__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jlong.jniType, jdouble.jniType, jdouble.jniType))
    public func doubles(a0: jlong, _ a1: jdouble, _ a2: jdouble) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Random$.java$util$Random_doubles_J_D_D__java$util$stream$DoubleStream(jobj)(a0, a1, a2))
    }

    private static let java$util$Random_doubles_D_D__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jdouble.jniType, jdouble.jniType))
    public func doubles(a0: jdouble, _ a1: jdouble) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$Random$.java$util$Random_doubles_D_D__java$util$stream$DoubleStream(jobj)(a0, a1))
    }

}

public typealias java$util$Random$ = java$util$Random

public protocol java$util$RandomAccess : JavaObject {
}

public class java$util$RandomAccess$ : java$lang$Object$, java$util$RandomAccess {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public extension java$util$RandomAccess {
}

public class java$util$RandomAccessSubList : java$util$SubList$, java$util$RandomAccess {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$RandomAccessSubList_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
}

public typealias java$util$RandomAccessSubList$ = java$util$RandomAccessSubList

public class java$util$RegularEnumSet : java$util$EnumSet$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$RegularEnumSet_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$RegularEnumSet_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$RegularEnumSet_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$RegularEnumSet_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$RegularEnumSet_add_java$lang$Enum__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Enum")))
    public func add(a0: java$lang$Enum?) throws -> jboolean {
        return try java$util$RegularEnumSet$.java$util$RegularEnumSet_add_java$lang$Enum__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$RegularEnumSet_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$RegularEnumSet_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$RegularEnumSet_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$RegularEnumSet_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$RegularEnumSet_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$RegularEnumSet_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$RegularEnumSet_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$RegularEnumSet_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
}

public typealias java$util$RegularEnumSet$ = java$util$RegularEnumSet

public class java$util$ResourceBundle : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ResourceBundle_getBaseBundleName__java$lang$String = invoker("getBaseBundleName", returns: JObjectType("java/lang/String"))
    public func getBaseBundleName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBaseBundleName__java$lang$String(jobj)())
    }

    private static let java$util$ResourceBundle_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$ResourceBundle$.java$util$ResourceBundle_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$ResourceBundle_getString_java$lang$String__java$lang$String = invoker("getString", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func getString(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getString_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getStringArray_java$lang$String__Ajava$lang$String = invoker("getStringArray", returns: JArray(JObjectType("java/lang/String")), arguments: (JObjectType("java/lang/String")))
    public func getStringArray(a0: java$lang$String?) throws -> [java$lang$String?]? {
        return try java$util$ResourceBundle$.java$util$ResourceBundle_getStringArray_java$lang$String__Ajava$lang$String(jobj)(a0?.jobj ?? nil).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$util$ResourceBundle_getObject_java$lang$String__java$lang$Object = invoker("getObject", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func getObject(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getObject_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getLocale__java$util$Locale = invoker("getLocale", returns: JObjectType("java/util/Locale"))
    public func getLocale() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getLocale__java$util$Locale(jobj)())
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String")))
    public static func getBundle(a0: java$lang$String?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String__java$util$ResourceBundle(a0?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String_java$util$ResourceBundle$Control__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/ResourceBundle$Control")))
    public static func getBundle(a0: java$lang$String?, _ a1: java$util$ResourceBundle$Control?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String_java$util$ResourceBundle$Control__java$util$ResourceBundle(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Locale")))
    public static func getBundle(a0: java$lang$String?, _ a1: java$util$Locale?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale__java$util$ResourceBundle(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$util$ResourceBundle$Control__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Locale"), JObjectType("java/util/ResourceBundle$Control")))
    public static func getBundle(a0: java$lang$String?, _ a1: java$util$Locale?, _ a2: java$util$ResourceBundle$Control?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$util$ResourceBundle$Control__java$util$ResourceBundle(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$lang$ClassLoader__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Locale"), JObjectType("java/lang/ClassLoader")))
    public static func getBundle(a0: java$lang$String?, _ a1: java$util$Locale?, _ a2: java$lang$ClassLoader?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$lang$ClassLoader__java$util$ResourceBundle(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$lang$ClassLoader_java$util$ResourceBundle$Control__java$util$ResourceBundle = svoker("getBundle", returns: JObjectType("java/util/ResourceBundle"), arguments: (JObjectType("java/lang/String"), JObjectType("java/util/Locale"), JObjectType("java/lang/ClassLoader"), JObjectType("java/util/ResourceBundle$Control")))
    public static func getBundle(a0: java$lang$String?, _ a1: java$util$Locale?, _ a2: java$lang$ClassLoader?, _ a3: java$util$ResourceBundle$Control?) throws -> java$util$ResourceBundle? {
        return try java$util$ResourceBundle$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getBundle_java$lang$String_java$util$Locale_java$lang$ClassLoader_java$util$ResourceBundle$Control__java$util$ResourceBundle(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil, a3?.jobj ?? nil))
    }

    private static let java$util$ResourceBundle_clearCache__V = svoker("clearCache", returns: JVoid.jniType)
    public static func clearCache() throws -> Void {
        return try java$util$ResourceBundle$.java$util$ResourceBundle_clearCache__V()
    }

    private static let java$util$ResourceBundle_clearCache_java$lang$ClassLoader__V = svoker("clearCache", returns: JVoid.jniType, arguments: (JObjectType("java/lang/ClassLoader")))
    public static func clearCache(a0: java$lang$ClassLoader?) throws -> Void {
        return try java$util$ResourceBundle$.java$util$ResourceBundle_clearCache_java$lang$ClassLoader__V(a0?.jobj ?? nil)
    }

    private static let java$util$ResourceBundle_getKeys__java$util$Enumeration = invoker("getKeys", returns: JObjectType("java/util/Enumeration"))
    public func getKeys() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_getKeys__java$util$Enumeration(jobj)())
    }

    private static let java$util$ResourceBundle_containsKey_java$lang$String__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func containsKey(a0: java$lang$String?) throws -> jboolean {
        return try java$util$ResourceBundle$.java$util$ResourceBundle_containsKey_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$ResourceBundle_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    public func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$ResourceBundle$.java$util$ResourceBundle_keySet__java$util$Set(jobj)())
    }

}

public typealias java$util$ResourceBundle$ = java$util$ResourceBundle

public final class java$util$Scanner : java$lang$Object$, java$util$Iterator, java$io$Closeable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Scanner_init_java$lang$Readable__V = constructor((JObjectType("java/lang/Readable")))
    public convenience init!(_ a0: java$lang$Readable?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$lang$Readable__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$io$InputStream__V = constructor((JObjectType("java/io/InputStream")))
    public convenience init!(_ a0: java$io$InputStream?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$io$InputStream__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$io$InputStream_java$lang$String__V = constructor((JObjectType("java/io/InputStream"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$InputStream?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$io$InputStream_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$io$File__V = constructor((JObjectType("java/io/File")))
    public convenience init!(_ a0: java$io$File?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$io$File__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$io$File_java$lang$String__V = constructor((JObjectType("java/io/File"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$io$File?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$io$File_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$nio$file$Path__V = constructor((JObjectType("java/nio/file/Path")))
    public convenience init!(_ a0: java$nio$file$Path?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$nio$file$Path__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$nio$file$Path_java$lang$String__V = constructor((JObjectType("java/nio/file/Path"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$nio$file$Path?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$nio$file$Path_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$nio$channels$ReadableByteChannel__V = constructor((JObjectType("java/nio/channels/ReadableByteChannel")))
    public convenience init!(_ a0: java$nio$channels$ReadableByteChannel?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$nio$channels$ReadableByteChannel__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_init_java$nio$channels$ReadableByteChannel_java$lang$String__V = constructor((JObjectType("java/nio/channels/ReadableByteChannel"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$nio$channels$ReadableByteChannel?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$Scanner$.java$util$Scanner_init_java$nio$channels$ReadableByteChannel_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Scanner_close__V = invoker("close", returns: JVoid.jniType)
    public func close() throws -> Void {
        return try java$util$Scanner$.java$util$Scanner_close__V(jobj)()
    }

    private static let java$util$Scanner_ioException__java$io$IOException = invoker("ioException", returns: JObjectType("java/io/IOException"))
    public func ioException() throws -> java$io$IOException? {
        return try java$io$IOException$(jobj: java$util$Scanner$.java$util$Scanner_ioException__java$io$IOException(jobj)())
    }

    private static let java$util$Scanner_delimiter__java$util$regex$Pattern = invoker("delimiter", returns: JObjectType("java/util/regex/Pattern"))
    public func delimiter() throws -> java$util$regex$Pattern? {
        return try java$util$regex$Pattern$(jobj: java$util$Scanner$.java$util$Scanner_delimiter__java$util$regex$Pattern(jobj)())
    }

    private static let java$util$Scanner_useDelimiter_java$util$regex$Pattern__java$util$Scanner = invoker("useDelimiter", returns: JObjectType("java/util/Scanner"), arguments: (JObjectType("java/util/regex/Pattern")))
    public func useDelimiter(a0: java$util$regex$Pattern?) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_useDelimiter_java$util$regex$Pattern__java$util$Scanner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_useDelimiter_java$lang$String__java$util$Scanner = invoker("useDelimiter", returns: JObjectType("java/util/Scanner"), arguments: (JObjectType("java/lang/String")))
    public func useDelimiter(a0: java$lang$String?) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_useDelimiter_java$lang$String__java$util$Scanner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_locale__java$util$Locale = invoker("locale", returns: JObjectType("java/util/Locale"))
    public func locale() throws -> java$util$Locale? {
        return try java$util$Locale$(jobj: java$util$Scanner$.java$util$Scanner_locale__java$util$Locale(jobj)())
    }

    private static let java$util$Scanner_useLocale_java$util$Locale__java$util$Scanner = invoker("useLocale", returns: JObjectType("java/util/Scanner"), arguments: (JObjectType("java/util/Locale")))
    public func useLocale(a0: java$util$Locale?) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_useLocale_java$util$Locale__java$util$Scanner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_radix__I = invoker("radix", returns: jint.jniType)
    public func radix() throws -> jint {
        return try java$util$Scanner$.java$util$Scanner_radix__I(jobj)()
    }

    private static let java$util$Scanner_useRadix_I__java$util$Scanner = invoker("useRadix", returns: JObjectType("java/util/Scanner"), arguments: (jint.jniType))
    public func useRadix(a0: jint) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_useRadix_I__java$util$Scanner(jobj)(a0))
    }

    private static let java$util$Scanner_match__java$util$regex$MatchResult = invoker("match", returns: JObjectType("java/util/regex/MatchResult"))
    public func match() throws -> java$util$regex$MatchResult? {
        return try java$util$regex$MatchResult$(jobj: java$util$Scanner$.java$util$Scanner_match__java$util$regex$MatchResult(jobj)())
    }

    private static let java$util$Scanner_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Scanner_hasNext__Z = invoker("hasNext", returns: jboolean.jniType)
    public func hasNext() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNext__Z(jobj)()
    }

    private static let java$util$Scanner_next__java$lang$String = invoker("next", returns: JObjectType("java/lang/String"))
    public func next() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_next__java$lang$String(jobj)())
    }

    private static let java$util$Scanner_remove__V = invoker("remove", returns: JVoid.jniType)
    public func remove() throws -> Void {
        return try java$util$Scanner$.java$util$Scanner_remove__V(jobj)()
    }

    private static let java$util$Scanner_hasNext_java$lang$String__Z = invoker("hasNext", returns: jboolean.jniType, arguments: (JObjectType("java/lang/String")))
    public func hasNext(a0: java$lang$String?) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNext_java$lang$String__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Scanner_next_java$lang$String__java$lang$String = invoker("next", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func next(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_next_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_hasNext_java$util$regex$Pattern__Z = invoker("hasNext", returns: jboolean.jniType, arguments: (JObjectType("java/util/regex/Pattern")))
    public func hasNext(a0: java$util$regex$Pattern?) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNext_java$util$regex$Pattern__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Scanner_next_java$util$regex$Pattern__java$lang$String = invoker("next", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/regex/Pattern")))
    public func next(a0: java$util$regex$Pattern?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_next_java$util$regex$Pattern__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_hasNextLine__Z = invoker("hasNextLine", returns: jboolean.jniType)
    public func hasNextLine() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextLine__Z(jobj)()
    }

    private static let java$util$Scanner_nextLine__java$lang$String = invoker("nextLine", returns: JObjectType("java/lang/String"))
    public func nextLine() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_nextLine__java$lang$String(jobj)())
    }

    private static let java$util$Scanner_findInLine_java$lang$String__java$lang$String = invoker("findInLine", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func findInLine(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_findInLine_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_findInLine_java$util$regex$Pattern__java$lang$String = invoker("findInLine", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/regex/Pattern")))
    public func findInLine(a0: java$util$regex$Pattern?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_findInLine_java$util$regex$Pattern__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_findWithinHorizon_java$lang$String_I__java$lang$String = invoker("findWithinHorizon", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func findWithinHorizon(a0: java$lang$String?, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_findWithinHorizon_java$lang$String_I__java$lang$String(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Scanner_findWithinHorizon_java$util$regex$Pattern_I__java$lang$String = invoker("findWithinHorizon", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/regex/Pattern"), jint.jniType))
    public func findWithinHorizon(a0: java$util$regex$Pattern?, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$Scanner$.java$util$Scanner_findWithinHorizon_java$util$regex$Pattern_I__java$lang$String(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Scanner_skip_java$util$regex$Pattern__java$util$Scanner = invoker("skip", returns: JObjectType("java/util/Scanner"), arguments: (JObjectType("java/util/regex/Pattern")))
    public func skip(a0: java$util$regex$Pattern?) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_skip_java$util$regex$Pattern__java$util$Scanner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_skip_java$lang$String__java$util$Scanner = invoker("skip", returns: JObjectType("java/util/Scanner"), arguments: (JObjectType("java/lang/String")))
    public func skip(a0: java$lang$String?) throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_skip_java$lang$String__java$util$Scanner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Scanner_hasNextBoolean__Z = invoker("hasNextBoolean", returns: jboolean.jniType)
    public func hasNextBoolean() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextBoolean__Z(jobj)()
    }

    private static let java$util$Scanner_nextBoolean__Z = invoker("nextBoolean", returns: jboolean.jniType)
    public func nextBoolean() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_nextBoolean__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextByte__Z = invoker("hasNextByte", returns: jboolean.jniType)
    public func hasNextByte() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextByte__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextByte_I__Z = invoker("hasNextByte", returns: jboolean.jniType, arguments: (jint.jniType))
    public func hasNextByte(a0: jint) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextByte_I__Z(jobj)(a0)
    }

    private static let java$util$Scanner_nextByte__B = invoker("nextByte", returns: jbyte.jniType)
    public func nextByte() throws -> jbyte {
        return try java$util$Scanner$.java$util$Scanner_nextByte__B(jobj)()
    }

    private static let java$util$Scanner_nextByte_I__B = invoker("nextByte", returns: jbyte.jniType, arguments: (jint.jniType))
    public func nextByte(a0: jint) throws -> jbyte {
        return try java$util$Scanner$.java$util$Scanner_nextByte_I__B(jobj)(a0)
    }

    private static let java$util$Scanner_hasNextShort__Z = invoker("hasNextShort", returns: jboolean.jniType)
    public func hasNextShort() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextShort__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextShort_I__Z = invoker("hasNextShort", returns: jboolean.jniType, arguments: (jint.jniType))
    public func hasNextShort(a0: jint) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextShort_I__Z(jobj)(a0)
    }

    private static let java$util$Scanner_nextShort__S = invoker("nextShort", returns: jshort.jniType)
    public func nextShort() throws -> jshort {
        return try java$util$Scanner$.java$util$Scanner_nextShort__S(jobj)()
    }

    private static let java$util$Scanner_nextShort_I__S = invoker("nextShort", returns: jshort.jniType, arguments: (jint.jniType))
    public func nextShort(a0: jint) throws -> jshort {
        return try java$util$Scanner$.java$util$Scanner_nextShort_I__S(jobj)(a0)
    }

    private static let java$util$Scanner_hasNextInt__Z = invoker("hasNextInt", returns: jboolean.jniType)
    public func hasNextInt() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextInt__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextInt_I__Z = invoker("hasNextInt", returns: jboolean.jniType, arguments: (jint.jniType))
    public func hasNextInt(a0: jint) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextInt_I__Z(jobj)(a0)
    }

    private static let java$util$Scanner_nextInt__I = invoker("nextInt", returns: jint.jniType)
    public func nextInt() throws -> jint {
        return try java$util$Scanner$.java$util$Scanner_nextInt__I(jobj)()
    }

    private static let java$util$Scanner_nextInt_I__I = invoker("nextInt", returns: jint.jniType, arguments: (jint.jniType))
    public func nextInt(a0: jint) throws -> jint {
        return try java$util$Scanner$.java$util$Scanner_nextInt_I__I(jobj)(a0)
    }

    private static let java$util$Scanner_hasNextLong__Z = invoker("hasNextLong", returns: jboolean.jniType)
    public func hasNextLong() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextLong__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextLong_I__Z = invoker("hasNextLong", returns: jboolean.jniType, arguments: (jint.jniType))
    public func hasNextLong(a0: jint) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextLong_I__Z(jobj)(a0)
    }

    private static let java$util$Scanner_nextLong__J = invoker("nextLong", returns: jlong.jniType)
    public func nextLong() throws -> jlong {
        return try java$util$Scanner$.java$util$Scanner_nextLong__J(jobj)()
    }

    private static let java$util$Scanner_nextLong_I__J = invoker("nextLong", returns: jlong.jniType, arguments: (jint.jniType))
    public func nextLong(a0: jint) throws -> jlong {
        return try java$util$Scanner$.java$util$Scanner_nextLong_I__J(jobj)(a0)
    }

    private static let java$util$Scanner_hasNextFloat__Z = invoker("hasNextFloat", returns: jboolean.jniType)
    public func hasNextFloat() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextFloat__Z(jobj)()
    }

    private static let java$util$Scanner_nextFloat__F = invoker("nextFloat", returns: jfloat.jniType)
    public func nextFloat() throws -> jfloat {
        return try java$util$Scanner$.java$util$Scanner_nextFloat__F(jobj)()
    }

    private static let java$util$Scanner_hasNextDouble__Z = invoker("hasNextDouble", returns: jboolean.jniType)
    public func hasNextDouble() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextDouble__Z(jobj)()
    }

    private static let java$util$Scanner_nextDouble__D = invoker("nextDouble", returns: jdouble.jniType)
    public func nextDouble() throws -> jdouble {
        return try java$util$Scanner$.java$util$Scanner_nextDouble__D(jobj)()
    }

    private static let java$util$Scanner_hasNextBigInteger__Z = invoker("hasNextBigInteger", returns: jboolean.jniType)
    public func hasNextBigInteger() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextBigInteger__Z(jobj)()
    }

    private static let java$util$Scanner_hasNextBigInteger_I__Z = invoker("hasNextBigInteger", returns: jboolean.jniType, arguments: (jint.jniType))
    public func hasNextBigInteger(a0: jint) throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextBigInteger_I__Z(jobj)(a0)
    }

    private static let java$util$Scanner_nextBigInteger__java$math$BigInteger = invoker("nextBigInteger", returns: JObjectType("java/math/BigInteger"))
    public func nextBigInteger() throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$util$Scanner$.java$util$Scanner_nextBigInteger__java$math$BigInteger(jobj)())
    }

    private static let java$util$Scanner_nextBigInteger_I__java$math$BigInteger = invoker("nextBigInteger", returns: JObjectType("java/math/BigInteger"), arguments: (jint.jniType))
    public func nextBigInteger(a0: jint) throws -> java$math$BigInteger? {
        return try java$math$BigInteger$(jobj: java$util$Scanner$.java$util$Scanner_nextBigInteger_I__java$math$BigInteger(jobj)(a0))
    }

    private static let java$util$Scanner_hasNextBigDecimal__Z = invoker("hasNextBigDecimal", returns: jboolean.jniType)
    public func hasNextBigDecimal() throws -> jboolean {
        return try java$util$Scanner$.java$util$Scanner_hasNextBigDecimal__Z(jobj)()
    }

    private static let java$util$Scanner_nextBigDecimal__java$math$BigDecimal = invoker("nextBigDecimal", returns: JObjectType("java/math/BigDecimal"))
    public func nextBigDecimal() throws -> java$math$BigDecimal? {
        return try java$math$BigDecimal$(jobj: java$util$Scanner$.java$util$Scanner_nextBigDecimal__java$math$BigDecimal(jobj)())
    }

    private static let java$util$Scanner_reset__java$util$Scanner = invoker("reset", returns: JObjectType("java/util/Scanner"))
    public func reset() throws -> java$util$Scanner? {
        return try java$util$Scanner$(jobj: java$util$Scanner$.java$util$Scanner_reset__java$util$Scanner(jobj)())
    }

    private static let java$util$Scanner_next__java$lang$Object = invoker("next", returns: JObjectType("java/lang/Object"))
    public func next() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Scanner$.java$util$Scanner_next__java$lang$Object(jobj)())
    }

}

public typealias java$util$Scanner$ = java$util$Scanner

public class java$util$ServiceConfigurationError : java$lang$Error$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ServiceConfigurationError_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$ServiceConfigurationError$.java$util$ServiceConfigurationError_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$ServiceConfigurationError_init_java$lang$String_java$lang$Throwable__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/Throwable")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$Throwable?) throws {
        let jobj = try java$util$ServiceConfigurationError$.java$util$ServiceConfigurationError_init_java$lang$String_java$lang$Throwable__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$ServiceConfigurationError$ = java$util$ServiceConfigurationError

public final class java$util$ServiceLoader : java$lang$Object$, java$lang$Iterable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$ServiceLoader_reload__V = invoker("reload", returns: JVoid.jniType)
    public func reload() throws -> Void {
        return try java$util$ServiceLoader$.java$util$ServiceLoader_reload__V(jobj)()
    }

    private static let java$util$ServiceLoader_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    public func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$ServiceLoader$.java$util$ServiceLoader_iterator__java$util$Iterator(jobj)())
    }

    private static let java$util$ServiceLoader_load_java$lang$Class_java$lang$ClassLoader__java$util$ServiceLoader = svoker("load", returns: JObjectType("java/util/ServiceLoader"), arguments: (JObjectType("java/lang/Class"), JObjectType("java/lang/ClassLoader")))
    public static func load(a0: java$lang$Class?, _ a1: java$lang$ClassLoader?) throws -> java$util$ServiceLoader? {
        return try java$util$ServiceLoader$(jobj: java$util$ServiceLoader$.java$util$ServiceLoader_load_java$lang$Class_java$lang$ClassLoader__java$util$ServiceLoader(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$ServiceLoader_load_java$lang$Class__java$util$ServiceLoader = svoker("load", returns: JObjectType("java/util/ServiceLoader"), arguments: (JObjectType("java/lang/Class")))
    public static func load(a0: java$lang$Class?) throws -> java$util$ServiceLoader? {
        return try java$util$ServiceLoader$(jobj: java$util$ServiceLoader$.java$util$ServiceLoader_load_java$lang$Class__java$util$ServiceLoader(a0?.jobj ?? nil))
    }

    private static let java$util$ServiceLoader_loadInstalled_java$lang$Class__java$util$ServiceLoader = svoker("loadInstalled", returns: JObjectType("java/util/ServiceLoader"), arguments: (JObjectType("java/lang/Class")))
    public static func loadInstalled(a0: java$lang$Class?) throws -> java$util$ServiceLoader? {
        return try java$util$ServiceLoader$(jobj: java$util$ServiceLoader$.java$util$ServiceLoader_loadInstalled_java$lang$Class__java$util$ServiceLoader(a0?.jobj ?? nil))
    }

    private static let java$util$ServiceLoader_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$ServiceLoader$ = java$util$ServiceLoader

public protocol java$util$Set : java$util$Collection {
    func size() throws -> jint
    func isEmpty() throws -> jboolean
    func contains(a0: java$lang$Object?) throws -> jboolean
    func iterator() throws -> java$util$Iterator?
    func toArray() throws -> [java$lang$Object?]?
    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]?
    func add(a0: java$lang$Object?) throws -> jboolean
    func remove(a0: java$lang$Object?) throws -> jboolean
    func containsAll(a0: java$util$Collection?) throws -> jboolean
    func addAll(a0: java$util$Collection?) throws -> jboolean
    func retainAll(a0: java$util$Collection?) throws -> jboolean
    func removeAll(a0: java$util$Collection?) throws -> jboolean
    func clear() throws -> Void
    func equals(a0: java$lang$Object?) throws -> jboolean
    func hashCode() throws -> jint
    func spliterator() throws -> java$util$Spliterator?
}

public class java$util$Set$ : java$lang$Object$, java$util$Set, java$util$Collection {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Set_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Set_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$Set_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Set_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$Set_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$Set_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$Set_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Set_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Set_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Set_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Set_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Set_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Set_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$Set_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Set_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Set_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
}

public extension java$util$Set {
    func size() throws -> jint {
        return try java$util$Set$.java$util$Set_size__I(jobj)()
    }

    func isEmpty() throws -> jboolean {
        return try java$util$Set$.java$util$Set_isEmpty__Z(jobj)()
    }

    func contains(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_contains_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func iterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Set$.java$util$Set_iterator__java$util$Iterator(jobj)())
    }

    func toArray() throws -> [java$lang$Object?]? {
        return try java$util$Set$.java$util$Set_toArray__Ajava$lang$Object(jobj)().jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func toArray(a0: [java$lang$Object?]?) throws -> [java$lang$Object?]? {
        return try java$util$Set$.java$util$Set_toArray_Ajava$lang$Object__Ajava$lang$Object(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil).jarrayToArray(java$lang$Object$.self)?.map({ $0 as java$lang$Object? })
    }

    func add(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_add_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func remove(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_remove_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func containsAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_containsAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func addAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_addAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func retainAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_retainAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func removeAll(a0: java$util$Collection?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_removeAll_java$util$Collection__Z(jobj)(a0?.jobj ?? nil)
    }

    func clear() throws -> Void {
        return try java$util$Set$.java$util$Set_clear__V(jobj)()
    }

    func equals(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Set$.java$util$Set_equals_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func hashCode() throws -> jint {
        return try java$util$Set$.java$util$Set_hashCode__I(jobj)()
    }

    func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Set$.java$util$Set_spliterator__java$util$Spliterator(jobj)())
    }

}

public class java$util$SimpleTimeZone : java$util$TimeZone$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$SimpleTimeZone_init_I_java$lang$String__V = constructor((jint.jniType, JObjectType("java/lang/String")))
    public convenience init!(_ a0: jint, _ a1: java$lang$String?) throws {
        let jobj = try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_init_I_java$lang$String__V(a0, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$SimpleTimeZone_setStartYear_I__V = invoker("setStartYear", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setStartYear(a0: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setStartYear_I__V(jobj)(a0)
    }

    private static let java$util$SimpleTimeZone_setStartRule_I_I_I_I__V = invoker("setStartRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public func setStartRule(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setStartRule_I_I_I_I__V(jobj)(a0, a1, a2, a3)
    }

    private static let java$util$SimpleTimeZone_setStartRule_I_I_I__V = invoker("setStartRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func setStartRule(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setStartRule_I_I_I__V(jobj)(a0, a1, a2)
    }

    private static let java$util$SimpleTimeZone_setStartRule_I_I_I_I_Z__V = invoker("setStartRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jboolean.jniType))
    public func setStartRule(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jboolean) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setStartRule_I_I_I_I_Z__V(jobj)(a0, a1, a2, a3, a4)
    }

    private static let java$util$SimpleTimeZone_setEndRule_I_I_I_I__V = invoker("setEndRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public func setEndRule(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setEndRule_I_I_I_I__V(jobj)(a0, a1, a2, a3)
    }

    private static let java$util$SimpleTimeZone_setEndRule_I_I_I__V = invoker("setEndRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType))
    public func setEndRule(a0: jint, _ a1: jint, _ a2: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setEndRule_I_I_I__V(jobj)(a0, a1, a2)
    }

    private static let java$util$SimpleTimeZone_setEndRule_I_I_I_I_Z__V = invoker("setEndRule", returns: JVoid.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jboolean.jniType))
    public func setEndRule(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jboolean) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setEndRule_I_I_I_I_Z__V(jobj)(a0, a1, a2, a3, a4)
    }

    private static let java$util$SimpleTimeZone_getOffset_J__I = invoker("getOffset", returns: jint.jniType, arguments: (jlong.jniType))
    private static let java$util$SimpleTimeZone_getOffset_I_I_I_I_I_I__I = invoker("getOffset", returns: jint.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    private static let java$util$SimpleTimeZone_getRawOffset__I = invoker("getRawOffset", returns: jint.jniType)
    private static let java$util$SimpleTimeZone_setRawOffset_I__V = invoker("setRawOffset", returns: JVoid.jniType, arguments: (jint.jniType))
    private static let java$util$SimpleTimeZone_setDSTSavings_I__V = invoker("setDSTSavings", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setDSTSavings(a0: jint) throws -> Void {
        return try java$util$SimpleTimeZone$.java$util$SimpleTimeZone_setDSTSavings_I__V(jobj)(a0)
    }

    private static let java$util$SimpleTimeZone_getDSTSavings__I = invoker("getDSTSavings", returns: jint.jniType)
    private static let java$util$SimpleTimeZone_useDaylightTime__Z = invoker("useDaylightTime", returns: jboolean.jniType)
    private static let java$util$SimpleTimeZone_observesDaylightTime__Z = invoker("observesDaylightTime", returns: jboolean.jniType)
    private static let java$util$SimpleTimeZone_inDaylightTime_java$util$Date__Z = invoker("inDaylightTime", returns: jboolean.jniType, arguments: (JObjectType("java/util/Date")))
    private static let java$util$SimpleTimeZone_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    private static let java$util$SimpleTimeZone_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$SimpleTimeZone_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$SimpleTimeZone_hasSameRules_java$util$TimeZone__Z = invoker("hasSameRules", returns: jboolean.jniType, arguments: (JObjectType("java/util/TimeZone")))
    private static let java$util$SimpleTimeZone_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
}

public typealias java$util$SimpleTimeZone$ = java$util$SimpleTimeZone

public protocol java$util$SortedMap : java$util$Map {
    func comparator() throws -> java$util$Comparator?
    func subMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedMap?
    func headMap(a0: java$lang$Object?) throws -> java$util$SortedMap?
    func tailMap(a0: java$lang$Object?) throws -> java$util$SortedMap?
    func firstKey() throws -> java$lang$Object?
    func lastKey() throws -> java$lang$Object?
    func keySet() throws -> java$util$Set?
    func values() throws -> java$util$Collection?
    func entrySet() throws -> java$util$Set?
}

public class java$util$SortedMap$ : java$lang$Object$, java$util$SortedMap, java$util$Map {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$SortedMap_comparator__java$util$Comparator = invoker("comparator", returns: JObjectType("java/util/Comparator"))
    private static let java$util$SortedMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap = invoker("subMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$SortedMap_headMap_java$lang$Object__java$util$SortedMap = invoker("headMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$SortedMap_tailMap_java$lang$Object__java$util$SortedMap = invoker("tailMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$SortedMap_firstKey__java$lang$Object = invoker("firstKey", returns: JObjectType("java/lang/Object"))
    private static let java$util$SortedMap_lastKey__java$lang$Object = invoker("lastKey", returns: JObjectType("java/lang/Object"))
    private static let java$util$SortedMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$SortedMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$SortedMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
}

public extension java$util$SortedMap {
    func comparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$SortedMap$.java$util$SortedMap_comparator__java$util$Comparator(jobj)())
    }

    func subMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$SortedMap$.java$util$SortedMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func headMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$SortedMap$.java$util$SortedMap_headMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

    func tailMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$SortedMap$.java$util$SortedMap_tailMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

    func firstKey() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$SortedMap$.java$util$SortedMap_firstKey__java$lang$Object(jobj)())
    }

    func lastKey() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$SortedMap$.java$util$SortedMap_lastKey__java$lang$Object(jobj)())
    }

    func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$SortedMap$.java$util$SortedMap_keySet__java$util$Set(jobj)())
    }

    func values() throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: java$util$SortedMap$.java$util$SortedMap_values__java$util$Collection(jobj)())
    }

    func entrySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: java$util$SortedMap$.java$util$SortedMap_entrySet__java$util$Set(jobj)())
    }

}

public protocol java$util$SortedSet : java$util$Set {
    func comparator() throws -> java$util$Comparator?
    func subSet(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedSet?
    func headSet(a0: java$lang$Object?) throws -> java$util$SortedSet?
    func tailSet(a0: java$lang$Object?) throws -> java$util$SortedSet?
    func first() throws -> java$lang$Object?
    func last() throws -> java$lang$Object?
    func spliterator() throws -> java$util$Spliterator?
}

public class java$util$SortedSet$ : java$lang$Object$, java$util$SortedSet, java$util$Set {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$SortedSet_comparator__java$util$Comparator = invoker("comparator", returns: JObjectType("java/util/Comparator"))
    private static let java$util$SortedSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet = invoker("subSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$SortedSet_headSet_java$lang$Object__java$util$SortedSet = invoker("headSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$SortedSet_tailSet_java$lang$Object__java$util$SortedSet = invoker("tailSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$SortedSet_first__java$lang$Object = invoker("first", returns: JObjectType("java/lang/Object"))
    private static let java$util$SortedSet_last__java$lang$Object = invoker("last", returns: JObjectType("java/lang/Object"))
    private static let java$util$SortedSet_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
}

public extension java$util$SortedSet {
    func comparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$SortedSet$.java$util$SortedSet_comparator__java$util$Comparator(jobj)())
    }

    func subSet(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$SortedSet$.java$util$SortedSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func headSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$SortedSet$.java$util$SortedSet_headSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

    func tailSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$SortedSet$.java$util$SortedSet_tailSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

    func first() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$SortedSet$.java$util$SortedSet_first__java$lang$Object(jobj)())
    }

    func last() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$SortedSet$.java$util$SortedSet_last__java$lang$Object(jobj)())
    }

    func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$SortedSet$.java$util$SortedSet_spliterator__java$util$Spliterator(jobj)())
    }

}

public protocol java$util$Spliterator : JavaObject {
    func tryAdvance(a0: java$util$function$Consumer?) throws -> jboolean
    func forEachRemaining(a0: java$util$function$Consumer?) throws -> Void
    func trySplit() throws -> java$util$Spliterator?
    func estimateSize() throws -> jlong
    func getExactSizeIfKnown() throws -> jlong
    func characteristics() throws -> jint
    func hasCharacteristics(a0: jint) throws -> jboolean
    func getComparator() throws -> java$util$Comparator?
}

public class java$util$Spliterator$ : java$lang$Object$, java$util$Spliterator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Spliterator_tryAdvance_java$util$function$Consumer__Z = invoker("tryAdvance", returns: jboolean.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    private static let java$util$Spliterator_forEachRemaining_java$util$function$Consumer__V = invoker("forEachRemaining", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    private static let java$util$Spliterator_trySplit__java$util$Spliterator = invoker("trySplit", returns: JObjectType("java/util/Spliterator"))
    private static let java$util$Spliterator_estimateSize__J = invoker("estimateSize", returns: jlong.jniType)
    private static let java$util$Spliterator_getExactSizeIfKnown__J = invoker("getExactSizeIfKnown", returns: jlong.jniType)
    private static let java$util$Spliterator_characteristics__I = invoker("characteristics", returns: jint.jniType)
    private static let java$util$Spliterator_hasCharacteristics_I__Z = invoker("hasCharacteristics", returns: jboolean.jniType, arguments: (jint.jniType))
    private static let java$util$Spliterator_getComparator__java$util$Comparator = invoker("getComparator", returns: JObjectType("java/util/Comparator"))
}

public extension java$util$Spliterator {
    func tryAdvance(a0: java$util$function$Consumer?) throws -> jboolean {
        return try java$util$Spliterator$.java$util$Spliterator_tryAdvance_java$util$function$Consumer__Z(jobj)(a0?.jobj ?? nil)
    }

    func forEachRemaining(a0: java$util$function$Consumer?) throws -> Void {
        return try java$util$Spliterator$.java$util$Spliterator_forEachRemaining_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

    func trySplit() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterator$.java$util$Spliterator_trySplit__java$util$Spliterator(jobj)())
    }

    func estimateSize() throws -> jlong {
        return try java$util$Spliterator$.java$util$Spliterator_estimateSize__J(jobj)()
    }

    func getExactSizeIfKnown() throws -> jlong {
        return try java$util$Spliterator$.java$util$Spliterator_getExactSizeIfKnown__J(jobj)()
    }

    func characteristics() throws -> jint {
        return try java$util$Spliterator$.java$util$Spliterator_characteristics__I(jobj)()
    }

    func hasCharacteristics(a0: jint) throws -> jboolean {
        return try java$util$Spliterator$.java$util$Spliterator_hasCharacteristics_I__Z(jobj)(a0)
    }

    func getComparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$Spliterator$.java$util$Spliterator_getComparator__java$util$Comparator(jobj)())
    }

}

public final class java$util$Spliterators : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Spliterators_emptySpliterator__java$util$Spliterator = svoker("emptySpliterator", returns: JObjectType("java/util/Spliterator"))
    public static func emptySpliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_emptySpliterator__java$util$Spliterator())
    }

    private static let java$util$Spliterators_emptyIntSpliterator__java$util$Spliterator$OfInt = svoker("emptyIntSpliterator", returns: JObjectType("java/util/Spliterator$OfInt"))
    public static func emptyIntSpliterator() throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_emptyIntSpliterator__java$util$Spliterator$OfInt())
    }

    private static let java$util$Spliterators_emptyLongSpliterator__java$util$Spliterator$OfLong = svoker("emptyLongSpliterator", returns: JObjectType("java/util/Spliterator$OfLong"))
    public static func emptyLongSpliterator() throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_emptyLongSpliterator__java$util$Spliterator$OfLong())
    }

    private static let java$util$Spliterators_emptyDoubleSpliterator__java$util$Spliterator$OfDouble = svoker("emptyDoubleSpliterator", returns: JObjectType("java/util/Spliterator$OfDouble"))
    public static func emptyDoubleSpliterator() throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_emptyDoubleSpliterator__java$util$Spliterator$OfDouble())
    }

    private static let java$util$Spliterators_spliterator_Ajava$lang$Object_I__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType))
    public static func spliterator(a0: [java$lang$Object?]?, _ a1: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_Ajava$lang$Object_I__java$util$Spliterator(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_Ajava$lang$Object_I_I_I__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JArray(JObjectType("java/lang/Object")), jint.jniType, jint.jniType, jint.jniType))
    public static func spliterator(a0: [java$lang$Object?]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_Ajava$lang$Object_I_I_I__java$util$Spliterator(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil, a1, a2, a3))
    }

    private static let java$util$Spliterators_spliterator_AI_I__java$util$Spliterator$OfInt = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JArray(jint.jniType), jint.jniType))
    public static func spliterator(a0: [jint]?, _ a1: jint) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AI_I__java$util$Spliterator$OfInt(a0?.arrayToJArray() ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_AI_I_I_I__java$util$Spliterator$OfInt = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JArray(jint.jniType), jint.jniType, jint.jniType, jint.jniType))
    public static func spliterator(a0: [jint]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AI_I_I_I__java$util$Spliterator$OfInt(a0?.arrayToJArray() ?? nil, a1, a2, a3))
    }

    private static let java$util$Spliterators_spliterator_AJ_I__java$util$Spliterator$OfLong = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JArray(jlong.jniType), jint.jniType))
    public static func spliterator(a0: [jlong]?, _ a1: jint) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AJ_I__java$util$Spliterator$OfLong(a0?.arrayToJArray() ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_AJ_I_I_I__java$util$Spliterator$OfLong = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JArray(jlong.jniType), jint.jniType, jint.jniType, jint.jniType))
    public static func spliterator(a0: [jlong]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AJ_I_I_I__java$util$Spliterator$OfLong(a0?.arrayToJArray() ?? nil, a1, a2, a3))
    }

    private static let java$util$Spliterators_spliterator_AD_I__java$util$Spliterator$OfDouble = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JArray(jdouble.jniType), jint.jniType))
    public static func spliterator(a0: [jdouble]?, _ a1: jint) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AD_I__java$util$Spliterator$OfDouble(a0?.arrayToJArray() ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_AD_I_I_I__java$util$Spliterator$OfDouble = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JArray(jdouble.jniType), jint.jniType, jint.jniType, jint.jniType))
    public static func spliterator(a0: [jdouble]?, _ a1: jint, _ a2: jint, _ a3: jint) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_AD_I_I_I__java$util$Spliterator$OfDouble(a0?.arrayToJArray() ?? nil, a1, a2, a3))
    }

    private static let java$util$Spliterators_spliterator_java$util$Collection_I__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JObjectType("java/util/Collection"), jint.jniType))
    public static func spliterator(a0: java$util$Collection?, _ a1: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_java$util$Collection_I__java$util$Spliterator(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_java$util$Iterator_J_I__java$util$Spliterator = svoker("spliterator", returns: JObjectType("java/util/Spliterator"), arguments: (JObjectType("java/util/Iterator"), jlong.jniType, jint.jniType))
    public static func spliterator(a0: java$util$Iterator?, _ a1: jlong, _ a2: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_java$util$Iterator_J_I__java$util$Spliterator(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$util$Spliterators_spliteratorUnknownSize_java$util$Iterator_I__java$util$Spliterator = svoker("spliteratorUnknownSize", returns: JObjectType("java/util/Spliterator"), arguments: (JObjectType("java/util/Iterator"), jint.jniType))
    public static func spliteratorUnknownSize(a0: java$util$Iterator?, _ a1: jint) throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Spliterators$.java$util$Spliterators_spliteratorUnknownSize_java$util$Iterator_I__java$util$Spliterator(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfInt_J_I__java$util$Spliterator$OfInt = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JObjectType("java/util/PrimitiveIterator$OfInt"), jlong.jniType, jint.jniType))
    public static func spliterator(a0: java$util$PrimitiveIterator$OfInt?, _ a1: jlong, _ a2: jint) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfInt_J_I__java$util$Spliterator$OfInt(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfInt_I__java$util$Spliterator$OfInt = svoker("spliteratorUnknownSize", returns: JObjectType("java/util/Spliterator$OfInt"), arguments: (JObjectType("java/util/PrimitiveIterator$OfInt"), jint.jniType))
    public static func spliteratorUnknownSize(a0: java$util$PrimitiveIterator$OfInt?, _ a1: jint) throws -> java$util$Spliterator$OfInt? {
        return try java$util$Spliterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfInt_I__java$util$Spliterator$OfInt(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfLong_J_I__java$util$Spliterator$OfLong = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JObjectType("java/util/PrimitiveIterator$OfLong"), jlong.jniType, jint.jniType))
    public static func spliterator(a0: java$util$PrimitiveIterator$OfLong?, _ a1: jlong, _ a2: jint) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfLong_J_I__java$util$Spliterator$OfLong(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfLong_I__java$util$Spliterator$OfLong = svoker("spliteratorUnknownSize", returns: JObjectType("java/util/Spliterator$OfLong"), arguments: (JObjectType("java/util/PrimitiveIterator$OfLong"), jint.jniType))
    public static func spliteratorUnknownSize(a0: java$util$PrimitiveIterator$OfLong?, _ a1: jint) throws -> java$util$Spliterator$OfLong? {
        return try java$util$Spliterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfLong_I__java$util$Spliterator$OfLong(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfDouble_J_I__java$util$Spliterator$OfDouble = svoker("spliterator", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JObjectType("java/util/PrimitiveIterator$OfDouble"), jlong.jniType, jint.jniType))
    public static func spliterator(a0: java$util$PrimitiveIterator$OfDouble?, _ a1: jlong, _ a2: jint) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_spliterator_java$util$PrimitiveIterator$OfDouble_J_I__java$util$Spliterator$OfDouble(a0?.jobj ?? nil, a1, a2))
    }

    private static let java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfDouble_I__java$util$Spliterator$OfDouble = svoker("spliteratorUnknownSize", returns: JObjectType("java/util/Spliterator$OfDouble"), arguments: (JObjectType("java/util/PrimitiveIterator$OfDouble"), jint.jniType))
    public static func spliteratorUnknownSize(a0: java$util$PrimitiveIterator$OfDouble?, _ a1: jint) throws -> java$util$Spliterator$OfDouble? {
        return try java$util$Spliterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_spliteratorUnknownSize_java$util$PrimitiveIterator$OfDouble_I__java$util$Spliterator$OfDouble(a0?.jobj ?? nil, a1))
    }

    private static let java$util$Spliterators_iterator_java$util$Spliterator__java$util$Iterator = svoker("iterator", returns: JObjectType("java/util/Iterator"), arguments: (JObjectType("java/util/Spliterator")))
    public static func iterator(a0: java$util$Spliterator?) throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$Spliterators$.java$util$Spliterators_iterator_java$util$Spliterator__java$util$Iterator(a0?.jobj ?? nil))
    }

    private static let java$util$Spliterators_iterator_java$util$Spliterator$OfInt__java$util$PrimitiveIterator$OfInt = svoker("iterator", returns: JObjectType("java/util/PrimitiveIterator$OfInt"), arguments: (JObjectType("java/util/Spliterator$OfInt")))
    public static func iterator(a0: java$util$Spliterator$OfInt?) throws -> java$util$PrimitiveIterator$OfInt? {
        return try java$util$PrimitiveIterator$OfInt$(jobj: java$util$Spliterators$.java$util$Spliterators_iterator_java$util$Spliterator$OfInt__java$util$PrimitiveIterator$OfInt(a0?.jobj ?? nil))
    }

    private static let java$util$Spliterators_iterator_java$util$Spliterator$OfLong__java$util$PrimitiveIterator$OfLong = svoker("iterator", returns: JObjectType("java/util/PrimitiveIterator$OfLong"), arguments: (JObjectType("java/util/Spliterator$OfLong")))
    public static func iterator(a0: java$util$Spliterator$OfLong?) throws -> java$util$PrimitiveIterator$OfLong? {
        return try java$util$PrimitiveIterator$OfLong$(jobj: java$util$Spliterators$.java$util$Spliterators_iterator_java$util$Spliterator$OfLong__java$util$PrimitiveIterator$OfLong(a0?.jobj ?? nil))
    }

    private static let java$util$Spliterators_iterator_java$util$Spliterator$OfDouble__java$util$PrimitiveIterator$OfDouble = svoker("iterator", returns: JObjectType("java/util/PrimitiveIterator$OfDouble"), arguments: (JObjectType("java/util/Spliterator$OfDouble")))
    public static func iterator(a0: java$util$Spliterator$OfDouble?) throws -> java$util$PrimitiveIterator$OfDouble? {
        return try java$util$PrimitiveIterator$OfDouble$(jobj: java$util$Spliterators$.java$util$Spliterators_iterator_java$util$Spliterator$OfDouble__java$util$PrimitiveIterator$OfDouble(a0?.jobj ?? nil))
    }

}

public typealias java$util$Spliterators$ = java$util$Spliterators

public final class java$util$SplittableRandom : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$SplittableRandom_init_J__V = constructor((jlong.jniType))
    public convenience init!(_ a0: jlong) throws {
        let jobj = try java$util$SplittableRandom$.java$util$SplittableRandom_init_J__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$SplittableRandom_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$SplittableRandom$.java$util$SplittableRandom_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$SplittableRandom_split__java$util$SplittableRandom = invoker("split", returns: JObjectType("java/util/SplittableRandom"))
    public func split() throws -> java$util$SplittableRandom? {
        return try java$util$SplittableRandom$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_split__java$util$SplittableRandom(jobj)())
    }

    private static let java$util$SplittableRandom_nextInt__I = invoker("nextInt", returns: jint.jniType)
    public func nextInt() throws -> jint {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextInt__I(jobj)()
    }

    private static let java$util$SplittableRandom_nextInt_I__I = invoker("nextInt", returns: jint.jniType, arguments: (jint.jniType))
    public func nextInt(a0: jint) throws -> jint {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextInt_I__I(jobj)(a0)
    }

    private static let java$util$SplittableRandom_nextInt_I_I__I = invoker("nextInt", returns: jint.jniType, arguments: (jint.jniType, jint.jniType))
    public func nextInt(a0: jint, _ a1: jint) throws -> jint {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextInt_I_I__I(jobj)(a0, a1)
    }

    private static let java$util$SplittableRandom_nextLong__J = invoker("nextLong", returns: jlong.jniType)
    public func nextLong() throws -> jlong {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextLong__J(jobj)()
    }

    private static let java$util$SplittableRandom_nextLong_J__J = invoker("nextLong", returns: jlong.jniType, arguments: (jlong.jniType))
    public func nextLong(a0: jlong) throws -> jlong {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextLong_J__J(jobj)(a0)
    }

    private static let java$util$SplittableRandom_nextLong_J_J__J = invoker("nextLong", returns: jlong.jniType, arguments: (jlong.jniType, jlong.jniType))
    public func nextLong(a0: jlong, _ a1: jlong) throws -> jlong {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextLong_J_J__J(jobj)(a0, a1)
    }

    private static let java$util$SplittableRandom_nextDouble__D = invoker("nextDouble", returns: jdouble.jniType)
    public func nextDouble() throws -> jdouble {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextDouble__D(jobj)()
    }

    private static let java$util$SplittableRandom_nextDouble_D__D = invoker("nextDouble", returns: jdouble.jniType, arguments: (jdouble.jniType))
    public func nextDouble(a0: jdouble) throws -> jdouble {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextDouble_D__D(jobj)(a0)
    }

    private static let java$util$SplittableRandom_nextDouble_D_D__D = invoker("nextDouble", returns: jdouble.jniType, arguments: (jdouble.jniType, jdouble.jniType))
    public func nextDouble(a0: jdouble, _ a1: jdouble) throws -> jdouble {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextDouble_D_D__D(jobj)(a0, a1)
    }

    private static let java$util$SplittableRandom_nextBoolean__Z = invoker("nextBoolean", returns: jboolean.jniType)
    public func nextBoolean() throws -> jboolean {
        return try java$util$SplittableRandom$.java$util$SplittableRandom_nextBoolean__Z(jobj)()
    }

    private static let java$util$SplittableRandom_ints_J__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jlong.jniType))
    public func ints(a0: jlong) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_ints_J__java$util$stream$IntStream(jobj)(a0))
    }

    private static let java$util$SplittableRandom_ints__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"))
    public func ints() throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_ints__java$util$stream$IntStream(jobj)())
    }

    private static let java$util$SplittableRandom_ints_J_I_I__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jlong.jniType, jint.jniType, jint.jniType))
    public func ints(a0: jlong, _ a1: jint, _ a2: jint) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_ints_J_I_I__java$util$stream$IntStream(jobj)(a0, a1, a2))
    }

    private static let java$util$SplittableRandom_ints_I_I__java$util$stream$IntStream = invoker("ints", returns: JObjectType("java/util/stream/IntStream"), arguments: (jint.jniType, jint.jniType))
    public func ints(a0: jint, _ a1: jint) throws -> java$util$stream$IntStream? {
        return try java$util$stream$IntStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_ints_I_I__java$util$stream$IntStream(jobj)(a0, a1))
    }

    private static let java$util$SplittableRandom_longs_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType))
    public func longs(a0: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_longs_J__java$util$stream$LongStream(jobj)(a0))
    }

    private static let java$util$SplittableRandom_longs__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"))
    public func longs() throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_longs__java$util$stream$LongStream(jobj)())
    }

    private static let java$util$SplittableRandom_longs_J_J_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType, jlong.jniType, jlong.jniType))
    public func longs(a0: jlong, _ a1: jlong, _ a2: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_longs_J_J_J__java$util$stream$LongStream(jobj)(a0, a1, a2))
    }

    private static let java$util$SplittableRandom_longs_J_J__java$util$stream$LongStream = invoker("longs", returns: JObjectType("java/util/stream/LongStream"), arguments: (jlong.jniType, jlong.jniType))
    public func longs(a0: jlong, _ a1: jlong) throws -> java$util$stream$LongStream? {
        return try java$util$stream$LongStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_longs_J_J__java$util$stream$LongStream(jobj)(a0, a1))
    }

    private static let java$util$SplittableRandom_doubles_J__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jlong.jniType))
    public func doubles(a0: jlong) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_doubles_J__java$util$stream$DoubleStream(jobj)(a0))
    }

    private static let java$util$SplittableRandom_doubles__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"))
    public func doubles() throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_doubles__java$util$stream$DoubleStream(jobj)())
    }

    private static let java$util$SplittableRandom_doubles_J_D_D__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jlong.jniType, jdouble.jniType, jdouble.jniType))
    public func doubles(a0: jlong, _ a1: jdouble, _ a2: jdouble) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_doubles_J_D_D__java$util$stream$DoubleStream(jobj)(a0, a1, a2))
    }

    private static let java$util$SplittableRandom_doubles_D_D__java$util$stream$DoubleStream = invoker("doubles", returns: JObjectType("java/util/stream/DoubleStream"), arguments: (jdouble.jniType, jdouble.jniType))
    public func doubles(a0: jdouble, _ a1: jdouble) throws -> java$util$stream$DoubleStream? {
        return try java$util$stream$DoubleStream$(jobj: java$util$SplittableRandom$.java$util$SplittableRandom_doubles_D_D__java$util$stream$DoubleStream(jobj)(a0, a1))
    }

}

public typealias java$util$SplittableRandom$ = java$util$SplittableRandom

public class java$util$Stack : java$util$Vector$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Stack_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Stack$.java$util$Stack_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Stack_push_java$lang$Object__java$lang$Object = invoker("push", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func push(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Stack$.java$util$Stack_push_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$Stack_pop__java$lang$Object = invoker("pop", returns: JObjectType("java/lang/Object"))
    public func pop() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Stack$.java$util$Stack_pop__java$lang$Object(jobj)())
    }

    private static let java$util$Stack_peek__java$lang$Object = invoker("peek", returns: JObjectType("java/lang/Object"))
    public func peek() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Stack$.java$util$Stack_peek__java$lang$Object(jobj)())
    }

    private static let java$util$Stack_empty__Z = invoker("empty", returns: jboolean.jniType)
    public func empty() throws -> jboolean {
        return try java$util$Stack$.java$util$Stack_empty__Z(jobj)()
    }

    private static let java$util$Stack_search_java$lang$Object__I = invoker("search", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func search(a0: java$lang$Object?) throws -> jint {
        return try java$util$Stack$.java$util$Stack_search_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$Stack$ = java$util$Stack

public final class java$util$StringJoiner : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$StringJoiner_init_java$lang$CharSequence__V = constructor((JObjectType("java/lang/CharSequence")))
    public convenience init!(_ a0: java$lang$CharSequence?) throws {
        let jobj = try java$util$StringJoiner$.java$util$StringJoiner_init_java$lang$CharSequence__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$StringJoiner_init_java$lang$CharSequence_java$lang$CharSequence_java$lang$CharSequence__V = constructor((JObjectType("java/lang/CharSequence"), JObjectType("java/lang/CharSequence"), JObjectType("java/lang/CharSequence")))
    public convenience init!(_ a0: java$lang$CharSequence?, _ a1: java$lang$CharSequence?, _ a2: java$lang$CharSequence?) throws {
        let jobj = try java$util$StringJoiner$.java$util$StringJoiner_init_java$lang$CharSequence_java$lang$CharSequence_java$lang$CharSequence__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$StringJoiner_setEmptyValue_java$lang$CharSequence__java$util$StringJoiner = invoker("setEmptyValue", returns: JObjectType("java/util/StringJoiner"), arguments: (JObjectType("java/lang/CharSequence")))
    public func setEmptyValue(a0: java$lang$CharSequence?) throws -> java$util$StringJoiner? {
        return try java$util$StringJoiner$(jobj: java$util$StringJoiner$.java$util$StringJoiner_setEmptyValue_java$lang$CharSequence__java$util$StringJoiner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$StringJoiner_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$StringJoiner_add_java$lang$CharSequence__java$util$StringJoiner = invoker("add", returns: JObjectType("java/util/StringJoiner"), arguments: (JObjectType("java/lang/CharSequence")))
    public func add(a0: java$lang$CharSequence?) throws -> java$util$StringJoiner? {
        return try java$util$StringJoiner$(jobj: java$util$StringJoiner$.java$util$StringJoiner_add_java$lang$CharSequence__java$util$StringJoiner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$StringJoiner_merge_java$util$StringJoiner__java$util$StringJoiner = invoker("merge", returns: JObjectType("java/util/StringJoiner"), arguments: (JObjectType("java/util/StringJoiner")))
    public func merge(a0: java$util$StringJoiner?) throws -> java$util$StringJoiner? {
        return try java$util$StringJoiner$(jobj: java$util$StringJoiner$.java$util$StringJoiner_merge_java$util$StringJoiner__java$util$StringJoiner(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$StringJoiner_length__I = invoker("length", returns: jint.jniType)
    public func length() throws -> jint {
        return try java$util$StringJoiner$.java$util$StringJoiner_length__I(jobj)()
    }

}

public typealias java$util$StringJoiner$ = java$util$StringJoiner

public class java$util$StringTokenizer : java$lang$Object$, java$util$Enumeration {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$StringTokenizer_init_java$lang$String_java$lang$String_Z__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jboolean) throws {
        let jobj = try java$util$StringTokenizer$.java$util$StringTokenizer_init_java$lang$String_java$lang$String_Z__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let java$util$StringTokenizer_init_java$lang$String_java$lang$String__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?) throws {
        let jobj = try java$util$StringTokenizer$.java$util$StringTokenizer_init_java$lang$String_java$lang$String__V(a0?.jobj ?? nil, a1?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$StringTokenizer_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$StringTokenizer$.java$util$StringTokenizer_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$StringTokenizer_hasMoreTokens__Z = invoker("hasMoreTokens", returns: jboolean.jniType)
    public func hasMoreTokens() throws -> jboolean {
        return try java$util$StringTokenizer$.java$util$StringTokenizer_hasMoreTokens__Z(jobj)()
    }

    private static let java$util$StringTokenizer_nextToken__java$lang$String = invoker("nextToken", returns: JObjectType("java/lang/String"))
    public func nextToken() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$StringTokenizer$.java$util$StringTokenizer_nextToken__java$lang$String(jobj)())
    }

    private static let java$util$StringTokenizer_nextToken_java$lang$String__java$lang$String = invoker("nextToken", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    public func nextToken(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$StringTokenizer$.java$util$StringTokenizer_nextToken_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$StringTokenizer_hasMoreElements__Z = invoker("hasMoreElements", returns: jboolean.jniType)
    public func hasMoreElements() throws -> jboolean {
        return try java$util$StringTokenizer$.java$util$StringTokenizer_hasMoreElements__Z(jobj)()
    }

    private static let java$util$StringTokenizer_nextElement__java$lang$Object = invoker("nextElement", returns: JObjectType("java/lang/Object"))
    public func nextElement() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$StringTokenizer$.java$util$StringTokenizer_nextElement__java$lang$Object(jobj)())
    }

    private static let java$util$StringTokenizer_countTokens__I = invoker("countTokens", returns: jint.jniType)
    public func countTokens() throws -> jint {
        return try java$util$StringTokenizer$.java$util$StringTokenizer_countTokens__I(jobj)()
    }

}

public typealias java$util$StringTokenizer$ = java$util$StringTokenizer

public class java$util$SubList : java$util$AbstractList$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$SubList_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$SubList_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$SubList_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$SubList_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$SubList_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$SubList_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$SubList_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$SubList_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$SubList_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    private static let java$util$SubList_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
}

public typealias java$util$SubList$ = java$util$SubList

public class java$util$TaskQueue : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$TaskQueue$ = java$util$TaskQueue

public class java$util$TimSort : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$TimSort$ = java$util$TimSort

public class java$util$TimeZone : java$lang$Object$, java$io$Serializable, java$lang$Cloneable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TimeZone_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$TimeZone$.java$util$TimeZone_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$TimeZone_getOffset_I_I_I_I_I_I__I = invoker("getOffset", returns: jint.jniType, arguments: (jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType, jint.jniType))
    public func getOffset(a0: jint, _ a1: jint, _ a2: jint, _ a3: jint, _ a4: jint, _ a5: jint) throws -> jint {
        return try java$util$TimeZone$.java$util$TimeZone_getOffset_I_I_I_I_I_I__I(jobj)(a0, a1, a2, a3, a4, a5)
    }

    private static let java$util$TimeZone_getOffset_J__I = invoker("getOffset", returns: jint.jniType, arguments: (jlong.jniType))
    public func getOffset(a0: jlong) throws -> jint {
        return try java$util$TimeZone$.java$util$TimeZone_getOffset_J__I(jobj)(a0)
    }

    private static let java$util$TimeZone_setRawOffset_I__V = invoker("setRawOffset", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setRawOffset(a0: jint) throws -> Void {
        return try java$util$TimeZone$.java$util$TimeZone_setRawOffset_I__V(jobj)(a0)
    }

    private static let java$util$TimeZone_getRawOffset__I = invoker("getRawOffset", returns: jint.jniType)
    public func getRawOffset() throws -> jint {
        return try java$util$TimeZone$.java$util$TimeZone_getRawOffset__I(jobj)()
    }

    private static let java$util$TimeZone_getID__java$lang$String = invoker("getID", returns: JObjectType("java/lang/String"))
    public func getID() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$TimeZone$.java$util$TimeZone_getID__java$lang$String(jobj)())
    }

    private static let java$util$TimeZone_setID_java$lang$String__V = invoker("setID", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String")))
    public func setID(a0: java$lang$String?) throws -> Void {
        return try java$util$TimeZone$.java$util$TimeZone_setID_java$lang$String__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$TimeZone_getDisplayName__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"))
    public func getDisplayName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$TimeZone$.java$util$TimeZone_getDisplayName__java$lang$String(jobj)())
    }

    private static let java$util$TimeZone_getDisplayName_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/util/Locale")))
    public func getDisplayName(a0: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$TimeZone$.java$util$TimeZone_getDisplayName_java$util$Locale__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TimeZone_getDisplayName_Z_I__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType, jint.jniType))
    public func getDisplayName(a0: jboolean, _ a1: jint) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$TimeZone$.java$util$TimeZone_getDisplayName_Z_I__java$lang$String(jobj)(a0, a1))
    }

    private static let java$util$TimeZone_getDisplayName_Z_I_java$util$Locale__java$lang$String = invoker("getDisplayName", returns: JObjectType("java/lang/String"), arguments: (jboolean.jniType, jint.jniType, JObjectType("java/util/Locale")))
    public func getDisplayName(a0: jboolean, _ a1: jint, _ a2: java$util$Locale?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$TimeZone$.java$util$TimeZone_getDisplayName_Z_I_java$util$Locale__java$lang$String(jobj)(a0, a1, a2?.jobj ?? nil))
    }

    private static let java$util$TimeZone_getDSTSavings__I = invoker("getDSTSavings", returns: jint.jniType)
    public func getDSTSavings() throws -> jint {
        return try java$util$TimeZone$.java$util$TimeZone_getDSTSavings__I(jobj)()
    }

    private static let java$util$TimeZone_useDaylightTime__Z = invoker("useDaylightTime", returns: jboolean.jniType)
    public func useDaylightTime() throws -> jboolean {
        return try java$util$TimeZone$.java$util$TimeZone_useDaylightTime__Z(jobj)()
    }

    private static let java$util$TimeZone_observesDaylightTime__Z = invoker("observesDaylightTime", returns: jboolean.jniType)
    public func observesDaylightTime() throws -> jboolean {
        return try java$util$TimeZone$.java$util$TimeZone_observesDaylightTime__Z(jobj)()
    }

    private static let java$util$TimeZone_inDaylightTime_java$util$Date__Z = invoker("inDaylightTime", returns: jboolean.jniType, arguments: (JObjectType("java/util/Date")))
    public func inDaylightTime(a0: java$util$Date?) throws -> jboolean {
        return try java$util$TimeZone$.java$util$TimeZone_inDaylightTime_java$util$Date__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$TimeZone_getTimeZone_java$lang$String__java$util$TimeZone = svoker("getTimeZone", returns: JObjectType("java/util/TimeZone"), arguments: (JObjectType("java/lang/String")))
    public static func getTimeZone(a0: java$lang$String?) throws -> java$util$TimeZone? {
        return try java$util$TimeZone$(jobj: java$util$TimeZone$.java$util$TimeZone_getTimeZone_java$lang$String__java$util$TimeZone(a0?.jobj ?? nil))
    }

    private static let java$util$TimeZone_getTimeZone_java$time$ZoneId__java$util$TimeZone = svoker("getTimeZone", returns: JObjectType("java/util/TimeZone"), arguments: (JObjectType("java/time/ZoneId")))
    public static func getTimeZone(a0: java$time$ZoneId?) throws -> java$util$TimeZone? {
        return try java$util$TimeZone$(jobj: java$util$TimeZone$.java$util$TimeZone_getTimeZone_java$time$ZoneId__java$util$TimeZone(a0?.jobj ?? nil))
    }

    private static let java$util$TimeZone_toZoneId__java$time$ZoneId = invoker("toZoneId", returns: JObjectType("java/time/ZoneId"))
    public func toZoneId() throws -> java$time$ZoneId? {
        return try java$time$ZoneId$(jobj: java$util$TimeZone$.java$util$TimeZone_toZoneId__java$time$ZoneId(jobj)())
    }

    private static let java$util$TimeZone_getAvailableIDs_I__Ajava$lang$String = svoker("getAvailableIDs", returns: JArray(JObjectType("java/lang/String")), arguments: (jint.jniType))
    public static func getAvailableIDs(a0: jint) throws -> [java$lang$String?]? {
        return try java$util$TimeZone$.java$util$TimeZone_getAvailableIDs_I__Ajava$lang$String(a0).jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$util$TimeZone_getAvailableIDs__Ajava$lang$String = svoker("getAvailableIDs", returns: JArray(JObjectType("java/lang/String")))
    public static func getAvailableIDs() throws -> [java$lang$String?]? {
        return try java$util$TimeZone$.java$util$TimeZone_getAvailableIDs__Ajava$lang$String().jarrayToArray(java$lang$String$.self)?.map({ $0 as java$lang$String? })
    }

    private static let java$util$TimeZone_getDefault__java$util$TimeZone = svoker("getDefault", returns: JObjectType("java/util/TimeZone"))
    public static func getDefault() throws -> java$util$TimeZone? {
        return try java$util$TimeZone$(jobj: java$util$TimeZone$.java$util$TimeZone_getDefault__java$util$TimeZone())
    }

    private static let java$util$TimeZone_setDefault_java$util$TimeZone__V = svoker("setDefault", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimeZone")))
    public static func setDefault(a0: java$util$TimeZone?) throws -> Void {
        return try java$util$TimeZone$.java$util$TimeZone_setDefault_java$util$TimeZone__V(a0?.jobj ?? nil)
    }

    private static let java$util$TimeZone_hasSameRules_java$util$TimeZone__Z = invoker("hasSameRules", returns: jboolean.jniType, arguments: (JObjectType("java/util/TimeZone")))
    public func hasSameRules(a0: java$util$TimeZone?) throws -> jboolean {
        return try java$util$TimeZone$.java$util$TimeZone_hasSameRules_java$util$TimeZone__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$TimeZone_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TimeZone$.java$util$TimeZone_clone__java$lang$Object(jobj)())
    }

}

public typealias java$util$TimeZone$ = java$util$TimeZone

public class java$util$Timer : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Timer_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Timer$.java$util$Timer_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Timer_init_Z__V = constructor((jboolean.jniType))
    public convenience init!(_ a0: jboolean) throws {
        let jobj = try java$util$Timer$.java$util$Timer_init_Z__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$Timer_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$Timer$.java$util$Timer_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Timer_init_java$lang$String_Z__V = constructor((JObjectType("java/lang/String"), jboolean.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: jboolean) throws {
        let jobj = try java$util$Timer$.java$util$Timer_init_java$lang$String_Z__V(a0?.jobj ?? nil, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$Timer_schedule_java$util$TimerTask_J__V = invoker("schedule", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), jlong.jniType))
    public func schedule(a0: java$util$TimerTask?, _ a1: jlong) throws -> Void {
        return try java$util$Timer$.java$util$Timer_schedule_java$util$TimerTask_J__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Timer_schedule_java$util$TimerTask_java$util$Date__V = invoker("schedule", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), JObjectType("java/util/Date")))
    public func schedule(a0: java$util$TimerTask?, _ a1: java$util$Date?) throws -> Void {
        return try java$util$Timer$.java$util$Timer_schedule_java$util$TimerTask_java$util$Date__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let java$util$Timer_schedule_java$util$TimerTask_J_J__V = invoker("schedule", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), jlong.jniType, jlong.jniType))
    public func schedule(a0: java$util$TimerTask?, _ a1: jlong, _ a2: jlong) throws -> Void {
        return try java$util$Timer$.java$util$Timer_schedule_java$util$TimerTask_J_J__V(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$util$Timer_schedule_java$util$TimerTask_java$util$Date_J__V = invoker("schedule", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), JObjectType("java/util/Date"), jlong.jniType))
    public func schedule(a0: java$util$TimerTask?, _ a1: java$util$Date?, _ a2: jlong) throws -> Void {
        return try java$util$Timer$.java$util$Timer_schedule_java$util$TimerTask_java$util$Date_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    private static let java$util$Timer_scheduleAtFixedRate_java$util$TimerTask_J_J__V = invoker("scheduleAtFixedRate", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), jlong.jniType, jlong.jniType))
    public func scheduleAtFixedRate(a0: java$util$TimerTask?, _ a1: jlong, _ a2: jlong) throws -> Void {
        return try java$util$Timer$.java$util$Timer_scheduleAtFixedRate_java$util$TimerTask_J_J__V(jobj)(a0?.jobj ?? nil, a1, a2)
    }

    private static let java$util$Timer_scheduleAtFixedRate_java$util$TimerTask_java$util$Date_J__V = invoker("scheduleAtFixedRate", returns: JVoid.jniType, arguments: (JObjectType("java/util/TimerTask"), JObjectType("java/util/Date"), jlong.jniType))
    public func scheduleAtFixedRate(a0: java$util$TimerTask?, _ a1: java$util$Date?, _ a2: jlong) throws -> Void {
        return try java$util$Timer$.java$util$Timer_scheduleAtFixedRate_java$util$TimerTask_java$util$Date_J__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    private static let java$util$Timer_cancel__V = invoker("cancel", returns: JVoid.jniType)
    public func cancel() throws -> Void {
        return try java$util$Timer$.java$util$Timer_cancel__V(jobj)()
    }

    private static let java$util$Timer_purge__I = invoker("purge", returns: jint.jniType)
    public func purge() throws -> jint {
        return try java$util$Timer$.java$util$Timer_purge__I(jobj)()
    }

}

public typealias java$util$Timer$ = java$util$Timer

public class java$util$TimerTask : java$lang$Object$, java$lang$Runnable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TimerTask_run__V = invoker("run", returns: JVoid.jniType)
    public func run() throws -> Void {
        return try java$util$TimerTask$.java$util$TimerTask_run__V(jobj)()
    }

    private static let java$util$TimerTask_cancel__Z = invoker("cancel", returns: jboolean.jniType)
    public func cancel() throws -> jboolean {
        return try java$util$TimerTask$.java$util$TimerTask_cancel__Z(jobj)()
    }

    private static let java$util$TimerTask_scheduledExecutionTime__J = invoker("scheduledExecutionTime", returns: jlong.jniType)
    public func scheduledExecutionTime() throws -> jlong {
        return try java$util$TimerTask$.java$util$TimerTask_scheduledExecutionTime__J(jobj)()
    }

}

public typealias java$util$TimerTask$ = java$util$TimerTask

public class java$util$TimerThread : java$lang$Thread$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TimerThread_run__V = invoker("run", returns: JVoid.jniType)
}

public typealias java$util$TimerThread$ = java$util$TimerThread

public class java$util$TooManyListenersException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TooManyListenersException_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$TooManyListenersException$.java$util$TooManyListenersException_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$TooManyListenersException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$TooManyListenersException$.java$util$TooManyListenersException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

}

public typealias java$util$TooManyListenersException$ = java$util$TooManyListenersException

public class java$util$TreeMap : java$util$AbstractMap$, java$util$NavigableMap, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TreeMap_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$TreeMap$.java$util$TreeMap_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$TreeMap_init_java$util$Comparator__V = constructor((JObjectType("java/util/Comparator")))
    public convenience init!(_ a0: java$util$Comparator?) throws {
        let jobj = try java$util$TreeMap$.java$util$TreeMap_init_java$util$Comparator__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$TreeMap$.java$util$TreeMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeMap_init_java$util$SortedMap__V = constructor((JObjectType("java/util/SortedMap")))
    public convenience init!(_ a0: java$util$SortedMap?) throws {
        let jobj = try java$util$TreeMap$.java$util$TreeMap_init_java$util$SortedMap__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeMap_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$TreeMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeMap_comparator__java$util$Comparator = invoker("comparator", returns: JObjectType("java/util/Comparator"))
    public func comparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$TreeMap$.java$util$TreeMap_comparator__java$util$Comparator(jobj)())
    }

    private static let java$util$TreeMap_firstKey__java$lang$Object = invoker("firstKey", returns: JObjectType("java/lang/Object"))
    public func firstKey() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_firstKey__java$lang$Object(jobj)())
    }

    private static let java$util$TreeMap_lastKey__java$lang$Object = invoker("lastKey", returns: JObjectType("java/lang/Object"))
    public func lastKey() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_lastKey__java$lang$Object(jobj)())
    }

    private static let java$util$TreeMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$TreeMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$TreeMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$TreeMap_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_clone__java$lang$Object(jobj)())
    }

    private static let java$util$TreeMap_firstEntry__java$util$Map$Entry = invoker("firstEntry", returns: JObjectType("java/util/Map$Entry"))
    public func firstEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_firstEntry__java$util$Map$Entry(jobj)())
    }

    private static let java$util$TreeMap_lastEntry__java$util$Map$Entry = invoker("lastEntry", returns: JObjectType("java/util/Map$Entry"))
    public func lastEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_lastEntry__java$util$Map$Entry(jobj)())
    }

    private static let java$util$TreeMap_pollFirstEntry__java$util$Map$Entry = invoker("pollFirstEntry", returns: JObjectType("java/util/Map$Entry"))
    public func pollFirstEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_pollFirstEntry__java$util$Map$Entry(jobj)())
    }

    private static let java$util$TreeMap_pollLastEntry__java$util$Map$Entry = invoker("pollLastEntry", returns: JObjectType("java/util/Map$Entry"))
    public func pollLastEntry() throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_pollLastEntry__java$util$Map$Entry(jobj)())
    }

    private static let java$util$TreeMap_lowerEntry_java$lang$Object__java$util$Map$Entry = invoker("lowerEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    public func lowerEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_lowerEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_lowerKey_java$lang$Object__java$lang$Object = invoker("lowerKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func lowerKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_lowerKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_floorEntry_java$lang$Object__java$util$Map$Entry = invoker("floorEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    public func floorEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_floorEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_floorKey_java$lang$Object__java$lang$Object = invoker("floorKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func floorKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_floorKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_ceilingEntry_java$lang$Object__java$util$Map$Entry = invoker("ceilingEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    public func ceilingEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_ceilingEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_ceilingKey_java$lang$Object__java$lang$Object = invoker("ceilingKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func ceilingKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_ceilingKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_higherEntry_java$lang$Object__java$util$Map$Entry = invoker("higherEntry", returns: JObjectType("java/util/Map$Entry"), arguments: (JObjectType("java/lang/Object")))
    public func higherEntry(a0: java$lang$Object?) throws -> java$util$Map$Entry? {
        return try java$util$Map$Entry$(jobj: java$util$TreeMap$.java$util$TreeMap_higherEntry_java$lang$Object__java$util$Map$Entry(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_higherKey_java$lang$Object__java$lang$Object = invoker("higherKey", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func higherKey(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_higherKey_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$TreeMap_navigableKeySet__java$util$NavigableSet = invoker("navigableKeySet", returns: JObjectType("java/util/NavigableSet"))
    public func navigableKeySet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeMap$.java$util$TreeMap_navigableKeySet__java$util$NavigableSet(jobj)())
    }

    private static let java$util$TreeMap_descendingKeySet__java$util$NavigableSet = invoker("descendingKeySet", returns: JObjectType("java/util/NavigableSet"))
    public func descendingKeySet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeMap$.java$util$TreeMap_descendingKeySet__java$util$NavigableSet(jobj)())
    }

    private static let java$util$TreeMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$TreeMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$TreeMap_descendingMap__java$util$NavigableMap = invoker("descendingMap", returns: JObjectType("java/util/NavigableMap"))
    public func descendingMap() throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$TreeMap$.java$util$TreeMap_descendingMap__java$util$NavigableMap(jobj)())
    }

    private static let java$util$TreeMap_subMap_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableMap = invoker("subMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType, JObjectType("java/lang/Object"), jboolean.jniType))
    public func subMap(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$TreeMap$.java$util$TreeMap_subMap_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3))
    }

    private static let java$util$TreeMap_headMap_java$lang$Object_Z__java$util$NavigableMap = invoker("headMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    public func headMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$TreeMap$.java$util$TreeMap_headMap_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$TreeMap_tailMap_java$lang$Object_Z__java$util$NavigableMap = invoker("tailMap", returns: JObjectType("java/util/NavigableMap"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    public func tailMap(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableMap? {
        return try java$util$NavigableMap$(jobj: java$util$TreeMap$.java$util$TreeMap_tailMap_java$lang$Object_Z__java$util$NavigableMap(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$TreeMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap = invoker("subMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func subMap(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$TreeMap$.java$util$TreeMap_subMap_java$lang$Object_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$TreeMap_headMap_java$lang$Object__java$util$SortedMap = invoker("headMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
    public func headMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$TreeMap$.java$util$TreeMap_headMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_tailMap_java$lang$Object__java$util$SortedMap = invoker("tailMap", returns: JObjectType("java/util/SortedMap"), arguments: (JObjectType("java/lang/Object")))
    public func tailMap(a0: java$lang$Object?) throws -> java$util$SortedMap? {
        return try java$util$SortedMap$(jobj: java$util$TreeMap$.java$util$TreeMap_tailMap_java$lang$Object__java$util$SortedMap(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeMap_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z = invoker("replace", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?, _ a2: java$lang$Object?) throws -> jboolean {
        return try java$util$TreeMap$.java$util$TreeMap_replace_java$lang$Object_java$lang$Object_java$lang$Object__Z(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.jobj ?? nil)
    }

    private static let java$util$TreeMap_replace_java$lang$Object_java$lang$Object__java$lang$Object = invoker("replace", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func replace(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeMap$.java$util$TreeMap_replace_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$TreeMap_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    public func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$TreeMap$.java$util$TreeMap_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$TreeMap_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    public func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$TreeMap$.java$util$TreeMap_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$TreeMap$ = java$util$TreeMap

public class java$util$TreeSet : java$util$AbstractSet$, java$util$NavigableSet, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$TreeSet_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$TreeSet$.java$util$TreeSet_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$TreeSet_init_java$util$Comparator__V = constructor((JObjectType("java/util/Comparator")))
    public convenience init!(_ a0: java$util$Comparator?) throws {
        let jobj = try java$util$TreeSet$.java$util$TreeSet_init_java$util$Comparator__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeSet_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$TreeSet$.java$util$TreeSet_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeSet_init_java$util$SortedSet__V = constructor((JObjectType("java/util/SortedSet")))
    public convenience init!(_ a0: java$util$SortedSet?) throws {
        let jobj = try java$util$TreeSet$.java$util$TreeSet_init_java$util$SortedSet__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$TreeSet_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$TreeSet_descendingIterator__java$util$Iterator = invoker("descendingIterator", returns: JObjectType("java/util/Iterator"))
    public func descendingIterator() throws -> java$util$Iterator? {
        return try java$util$Iterator$(jobj: java$util$TreeSet$.java$util$TreeSet_descendingIterator__java$util$Iterator(jobj)())
    }

    private static let java$util$TreeSet_descendingSet__java$util$NavigableSet = invoker("descendingSet", returns: JObjectType("java/util/NavigableSet"))
    public func descendingSet() throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeSet$.java$util$TreeSet_descendingSet__java$util$NavigableSet(jobj)())
    }

    private static let java$util$TreeSet_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$TreeSet_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$TreeSet_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeSet_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeSet_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$TreeSet_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$TreeSet_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$TreeSet_subSet_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableSet = invoker("subSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType, JObjectType("java/lang/Object"), jboolean.jniType))
    public func subSet(a0: java$lang$Object?, _ a1: jboolean, _ a2: java$lang$Object?, _ a3: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeSet$.java$util$TreeSet_subSet_java$lang$Object_Z_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1, a2?.jobj ?? nil, a3))
    }

    private static let java$util$TreeSet_headSet_java$lang$Object_Z__java$util$NavigableSet = invoker("headSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    public func headSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeSet$.java$util$TreeSet_headSet_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$TreeSet_tailSet_java$lang$Object_Z__java$util$NavigableSet = invoker("tailSet", returns: JObjectType("java/util/NavigableSet"), arguments: (JObjectType("java/lang/Object"), jboolean.jniType))
    public func tailSet(a0: java$lang$Object?, _ a1: jboolean) throws -> java$util$NavigableSet? {
        return try java$util$NavigableSet$(jobj: java$util$TreeSet$.java$util$TreeSet_tailSet_java$lang$Object_Z__java$util$NavigableSet(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let java$util$TreeSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet = invoker("subSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func subSet(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$TreeSet$.java$util$TreeSet_subSet_java$lang$Object_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let java$util$TreeSet_headSet_java$lang$Object__java$util$SortedSet = invoker("headSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
    public func headSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$TreeSet$.java$util$TreeSet_headSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_tailSet_java$lang$Object__java$util$SortedSet = invoker("tailSet", returns: JObjectType("java/util/SortedSet"), arguments: (JObjectType("java/lang/Object")))
    public func tailSet(a0: java$lang$Object?) throws -> java$util$SortedSet? {
        return try java$util$SortedSet$(jobj: java$util$TreeSet$.java$util$TreeSet_tailSet_java$lang$Object__java$util$SortedSet(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_comparator__java$util$Comparator = invoker("comparator", returns: JObjectType("java/util/Comparator"))
    public func comparator() throws -> java$util$Comparator? {
        return try java$util$Comparator$(jobj: java$util$TreeSet$.java$util$TreeSet_comparator__java$util$Comparator(jobj)())
    }

    private static let java$util$TreeSet_first__java$lang$Object = invoker("first", returns: JObjectType("java/lang/Object"))
    public func first() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_first__java$lang$Object(jobj)())
    }

    private static let java$util$TreeSet_last__java$lang$Object = invoker("last", returns: JObjectType("java/lang/Object"))
    public func last() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_last__java$lang$Object(jobj)())
    }

    private static let java$util$TreeSet_lower_java$lang$Object__java$lang$Object = invoker("lower", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func lower(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_lower_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_floor_java$lang$Object__java$lang$Object = invoker("floor", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func floor(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_floor_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_ceiling_java$lang$Object__java$lang$Object = invoker("ceiling", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func ceiling(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_ceiling_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_higher_java$lang$Object__java$lang$Object = invoker("higher", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func higher(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_higher_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let java$util$TreeSet_pollFirst__java$lang$Object = invoker("pollFirst", returns: JObjectType("java/lang/Object"))
    public func pollFirst() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_pollFirst__java$lang$Object(jobj)())
    }

    private static let java$util$TreeSet_pollLast__java$lang$Object = invoker("pollLast", returns: JObjectType("java/lang/Object"))
    public func pollLast() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_pollLast__java$lang$Object(jobj)())
    }

    private static let java$util$TreeSet_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$TreeSet$.java$util$TreeSet_clone__java$lang$Object(jobj)())
    }

    private static let java$util$TreeSet_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$TreeSet$.java$util$TreeSet_spliterator__java$util$Spliterator(jobj)())
    }

}

public typealias java$util$TreeSet$ = java$util$TreeSet

public final class java$util$Tripwire : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public typealias java$util$Tripwire$ = java$util$Tripwire

public final class java$util$UUID : java$lang$Object$, java$io$Serializable, java$lang$Comparable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$UUID_init_J_J__V = constructor((jlong.jniType, jlong.jniType))
    public convenience init!(_ a0: jlong, _ a1: jlong) throws {
        let jobj = try java$util$UUID$.java$util$UUID_init_J_J__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$UUID_randomUUID__java$util$UUID = svoker("randomUUID", returns: JObjectType("java/util/UUID"))
    public static func randomUUID() throws -> java$util$UUID? {
        return try java$util$UUID$(jobj: java$util$UUID$.java$util$UUID_randomUUID__java$util$UUID())
    }

    private static let java$util$UUID_nameUUIDFromBytes_AB__java$util$UUID = svoker("nameUUIDFromBytes", returns: JObjectType("java/util/UUID"), arguments: (JArray(jbyte.jniType)))
    public static func nameUUIDFromBytes(a0: [jbyte]?) throws -> java$util$UUID? {
        return try java$util$UUID$(jobj: java$util$UUID$.java$util$UUID_nameUUIDFromBytes_AB__java$util$UUID(a0?.arrayToJArray() ?? nil))
    }

    private static let java$util$UUID_fromString_java$lang$String__java$util$UUID = svoker("fromString", returns: JObjectType("java/util/UUID"), arguments: (JObjectType("java/lang/String")))
    public static func fromString(a0: java$lang$String?) throws -> java$util$UUID? {
        return try java$util$UUID$(jobj: java$util$UUID$.java$util$UUID_fromString_java$lang$String__java$util$UUID(a0?.jobj ?? nil))
    }

    private static let java$util$UUID_getLeastSignificantBits__J = invoker("getLeastSignificantBits", returns: jlong.jniType)
    public func getLeastSignificantBits() throws -> jlong {
        return try java$util$UUID$.java$util$UUID_getLeastSignificantBits__J(jobj)()
    }

    private static let java$util$UUID_getMostSignificantBits__J = invoker("getMostSignificantBits", returns: jlong.jniType)
    public func getMostSignificantBits() throws -> jlong {
        return try java$util$UUID$.java$util$UUID_getMostSignificantBits__J(jobj)()
    }

    private static let java$util$UUID_version__I = invoker("version", returns: jint.jniType)
    public func version() throws -> jint {
        return try java$util$UUID$.java$util$UUID_version__I(jobj)()
    }

    private static let java$util$UUID_variant__I = invoker("variant", returns: jint.jniType)
    public func variant() throws -> jint {
        return try java$util$UUID$.java$util$UUID_variant__I(jobj)()
    }

    private static let java$util$UUID_timestamp__J = invoker("timestamp", returns: jlong.jniType)
    public func timestamp() throws -> jlong {
        return try java$util$UUID$.java$util$UUID_timestamp__J(jobj)()
    }

    private static let java$util$UUID_clockSequence__I = invoker("clockSequence", returns: jint.jniType)
    public func clockSequence() throws -> jint {
        return try java$util$UUID$.java$util$UUID_clockSequence__I(jobj)()
    }

    private static let java$util$UUID_node__J = invoker("node", returns: jlong.jniType)
    public func node() throws -> jlong {
        return try java$util$UUID$.java$util$UUID_node__J(jobj)()
    }

    private static let java$util$UUID_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$UUID_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$UUID_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$UUID_compareTo_java$util$UUID__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/util/UUID")))
    public func compareTo(a0: java$util$UUID?) throws -> jint {
        return try java$util$UUID$.java$util$UUID_compareTo_java$util$UUID__I(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$UUID_compareTo_java$lang$Object__I = invoker("compareTo", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    public func compareTo(a0: java$lang$Object?) throws -> jint {
        return try java$util$UUID$.java$util$UUID_compareTo_java$lang$Object__I(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$UUID$ = java$util$UUID

public class java$util$UnknownFormatConversionException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$UnknownFormatConversionException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$UnknownFormatConversionException$.java$util$UnknownFormatConversionException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$UnknownFormatConversionException_getConversion__java$lang$String = invoker("getConversion", returns: JObjectType("java/lang/String"))
    public func getConversion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$UnknownFormatConversionException$.java$util$UnknownFormatConversionException_getConversion__java$lang$String(jobj)())
    }

    private static let java$util$UnknownFormatConversionException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$UnknownFormatConversionException$ = java$util$UnknownFormatConversionException

public class java$util$UnknownFormatFlagsException : java$util$IllegalFormatException$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$UnknownFormatFlagsException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try java$util$UnknownFormatFlagsException$.java$util$UnknownFormatFlagsException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$UnknownFormatFlagsException_getFlags__java$lang$String = invoker("getFlags", returns: JObjectType("java/lang/String"))
    public func getFlags() throws -> java$lang$String? {
        return try java$lang$String$(jobj: java$util$UnknownFormatFlagsException$.java$util$UnknownFormatFlagsException_getFlags__java$lang$String(jobj)())
    }

    private static let java$util$UnknownFormatFlagsException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
}

public typealias java$util$UnknownFormatFlagsException$ = java$util$UnknownFormatFlagsException

public class java$util$Vector : java$util$AbstractList$, java$util$RandomAccess, java$lang$Cloneable, java$io$Serializable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$Vector_init_I_I__V = constructor((jint.jniType, jint.jniType))
    public convenience init!(_ a0: jint, _ a1: jint) throws {
        let jobj = try java$util$Vector$.java$util$Vector_init_I_I__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$Vector_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$Vector$.java$util$Vector_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$Vector_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$Vector$.java$util$Vector_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$Vector_init_java$util$Collection__V = constructor((JObjectType("java/util/Collection")))
    public convenience init!(_ a0: java$util$Collection?) throws {
        let jobj = try java$util$Vector$.java$util$Vector_init_java$util$Collection__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$Vector_copyInto_Ajava$lang$Object__V = invoker("copyInto", returns: JVoid.jniType, arguments: (JArray(JObjectType("java/lang/Object"))))
    public func copyInto(a0: [java$lang$Object?]?) throws -> Void {
        return try java$util$Vector$.java$util$Vector_copyInto_Ajava$lang$Object__V(jobj)(a0?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil)
    }

    private static let java$util$Vector_trimToSize__V = invoker("trimToSize", returns: JVoid.jniType)
    public func trimToSize() throws -> Void {
        return try java$util$Vector$.java$util$Vector_trimToSize__V(jobj)()
    }

    private static let java$util$Vector_ensureCapacity_I__V = invoker("ensureCapacity", returns: JVoid.jniType, arguments: (jint.jniType))
    public func ensureCapacity(a0: jint) throws -> Void {
        return try java$util$Vector$.java$util$Vector_ensureCapacity_I__V(jobj)(a0)
    }

    private static let java$util$Vector_setSize_I__V = invoker("setSize", returns: JVoid.jniType, arguments: (jint.jniType))
    public func setSize(a0: jint) throws -> Void {
        return try java$util$Vector$.java$util$Vector_setSize_I__V(jobj)(a0)
    }

    private static let java$util$Vector_capacity__I = invoker("capacity", returns: jint.jniType)
    public func capacity() throws -> jint {
        return try java$util$Vector$.java$util$Vector_capacity__I(jobj)()
    }

    private static let java$util$Vector_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$Vector_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$Vector_elements__java$util$Enumeration = invoker("elements", returns: JObjectType("java/util/Enumeration"))
    public func elements() throws -> java$util$Enumeration? {
        return try java$util$Enumeration$(jobj: java$util$Vector$.java$util$Vector_elements__java$util$Enumeration(jobj)())
    }

    private static let java$util$Vector_contains_java$lang$Object__Z = invoker("contains", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_indexOf_java$lang$Object__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_indexOf_java$lang$Object_I__I = invoker("indexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public func indexOf(a0: java$lang$Object?, _ a1: jint) throws -> jint {
        return try java$util$Vector$.java$util$Vector_indexOf_java$lang$Object_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Vector_lastIndexOf_java$lang$Object__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_lastIndexOf_java$lang$Object_I__I = invoker("lastIndexOf", returns: jint.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public func lastIndexOf(a0: java$lang$Object?, _ a1: jint) throws -> jint {
        return try java$util$Vector$.java$util$Vector_lastIndexOf_java$lang$Object_I__I(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Vector_elementAt_I__java$lang$Object = invoker("elementAt", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    public func elementAt(a0: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Vector$.java$util$Vector_elementAt_I__java$lang$Object(jobj)(a0))
    }

    private static let java$util$Vector_firstElement__java$lang$Object = invoker("firstElement", returns: JObjectType("java/lang/Object"))
    public func firstElement() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Vector$.java$util$Vector_firstElement__java$lang$Object(jobj)())
    }

    private static let java$util$Vector_lastElement__java$lang$Object = invoker("lastElement", returns: JObjectType("java/lang/Object"))
    public func lastElement() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Vector$.java$util$Vector_lastElement__java$lang$Object(jobj)())
    }

    private static let java$util$Vector_setElementAt_java$lang$Object_I__V = invoker("setElementAt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public func setElementAt(a0: java$lang$Object?, _ a1: jint) throws -> Void {
        return try java$util$Vector$.java$util$Vector_setElementAt_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Vector_removeElementAt_I__V = invoker("removeElementAt", returns: JVoid.jniType, arguments: (jint.jniType))
    public func removeElementAt(a0: jint) throws -> Void {
        return try java$util$Vector$.java$util$Vector_removeElementAt_I__V(jobj)(a0)
    }

    private static let java$util$Vector_insertElementAt_java$lang$Object_I__V = invoker("insertElementAt", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object"), jint.jniType))
    public func insertElementAt(a0: java$lang$Object?, _ a1: jint) throws -> Void {
        return try java$util$Vector$.java$util$Vector_insertElementAt_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let java$util$Vector_addElement_java$lang$Object__V = invoker("addElement", returns: JVoid.jniType, arguments: (JObjectType("java/lang/Object")))
    public func addElement(a0: java$lang$Object?) throws -> Void {
        return try java$util$Vector$.java$util$Vector_addElement_java$lang$Object__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_removeElement_java$lang$Object__Z = invoker("removeElement", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func removeElement(a0: java$lang$Object?) throws -> jboolean {
        return try java$util$Vector$.java$util$Vector_removeElement_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_removeAllElements__V = invoker("removeAllElements", returns: JVoid.jniType)
    public func removeAllElements() throws -> Void {
        return try java$util$Vector$.java$util$Vector_removeAllElements__V(jobj)()
    }

    private static let java$util$Vector_clone__java$lang$Object = invoker("clone", returns: JObjectType("java/lang/Object"))
    public func clone() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: java$util$Vector$.java$util$Vector_clone__java$lang$Object(jobj)())
    }

    private static let java$util$Vector_toArray__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")))
    private static let java$util$Vector_toArray_Ajava$lang$Object__Ajava$lang$Object = invoker("toArray", returns: JArray(JObjectType("java/lang/Object")), arguments: (JArray(JObjectType("java/lang/Object"))))
    private static let java$util$Vector_get_I__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$Vector_set_I_java$lang$Object__java$lang$Object = invoker("set", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$Vector_add_java$lang$Object__Z = invoker("add", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_remove_java$lang$Object__Z = invoker("remove", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_add_I_java$lang$Object__V = invoker("add", returns: JVoid.jniType, arguments: (jint.jniType, JObjectType("java/lang/Object")))
    private static let java$util$Vector_remove_I__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (jint.jniType))
    private static let java$util$Vector_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$Vector_containsAll_java$util$Collection__Z = invoker("containsAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Vector_addAll_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Vector_removeAll_java$util$Collection__Z = invoker("removeAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Vector_retainAll_java$util$Collection__Z = invoker("retainAll", returns: jboolean.jniType, arguments: (JObjectType("java/util/Collection")))
    private static let java$util$Vector_addAll_I_java$util$Collection__Z = invoker("addAll", returns: jboolean.jniType, arguments: (jint.jniType, JObjectType("java/util/Collection")))
    private static let java$util$Vector_equals_java$lang$Object__Z = invoker("equals", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$Vector_hashCode__I = invoker("hashCode", returns: jint.jniType)
    private static let java$util$Vector_toString__java$lang$String = invoker("toString", returns: JObjectType("java/lang/String"))
    private static let java$util$Vector_subList_I_I__java$util$List = invoker("subList", returns: JObjectType("java/util/List"), arguments: (jint.jniType, jint.jniType))
    private static let java$util$Vector_listIterator_I__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"), arguments: (jint.jniType))
    private static let java$util$Vector_listIterator__java$util$ListIterator = invoker("listIterator", returns: JObjectType("java/util/ListIterator"))
    private static let java$util$Vector_iterator__java$util$Iterator = invoker("iterator", returns: JObjectType("java/util/Iterator"))
    private static let java$util$Vector_forEach_java$util$function$Consumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/Consumer")))
    public func forEach(a0: java$util$function$Consumer?) throws -> Void {
        return try java$util$Vector$.java$util$Vector_forEach_java$util$function$Consumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_removeIf_java$util$function$Predicate__Z = invoker("removeIf", returns: jboolean.jniType, arguments: (JObjectType("java/util/function/Predicate")))
    public func removeIf(a0: java$util$function$Predicate?) throws -> jboolean {
        return try java$util$Vector$.java$util$Vector_removeIf_java$util$function$Predicate__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_replaceAll_java$util$function$UnaryOperator__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/UnaryOperator")))
    public func replaceAll(a0: java$util$function$UnaryOperator?) throws -> Void {
        return try java$util$Vector$.java$util$Vector_replaceAll_java$util$function$UnaryOperator__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_sort_java$util$Comparator__V = invoker("sort", returns: JVoid.jniType, arguments: (JObjectType("java/util/Comparator")))
    public func sort(a0: java$util$Comparator?) throws -> Void {
        return try java$util$Vector$.java$util$Vector_sort_java$util$Comparator__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$Vector_spliterator__java$util$Spliterator = invoker("spliterator", returns: JObjectType("java/util/Spliterator"))
    public func spliterator() throws -> java$util$Spliterator? {
        return try java$util$Spliterator$(jobj: java$util$Vector$.java$util$Vector_spliterator__java$util$Spliterator(jobj)())
    }

}

public typealias java$util$Vector$ = java$util$Vector

public class java$util$WeakHashMap : java$util$AbstractMap$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let java$util$WeakHashMap_init_I_F__V = constructor((jint.jniType, jfloat.jniType))
    public convenience init!(_ a0: jint, _ a1: jfloat) throws {
        let jobj = try java$util$WeakHashMap$.java$util$WeakHashMap_init_I_F__V(a0, a1)
        self.init(jobj: jobj)
    }

    private static let java$util$WeakHashMap_init_I__V = constructor((jint.jniType))
    public convenience init!(_ a0: jint) throws {
        let jobj = try java$util$WeakHashMap$.java$util$WeakHashMap_init_I__V(a0)
        self.init(jobj: jobj)
    }

    private static let java$util$WeakHashMap_init__V = constructor()
    public convenience init!() throws {
        let jobj = try java$util$WeakHashMap$.java$util$WeakHashMap_init__V()
        self.init(jobj: jobj)
    }

    private static let java$util$WeakHashMap_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try java$util$WeakHashMap$.java$util$WeakHashMap_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let java$util$WeakHashMap_size__I = invoker("size", returns: jint.jniType)
    private static let java$util$WeakHashMap_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    private static let java$util$WeakHashMap_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$WeakHashMap_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$WeakHashMap_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    private static let java$util$WeakHashMap_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let java$util$WeakHashMap_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let java$util$WeakHashMap_clear__V = invoker("clear", returns: JVoid.jniType)
    private static let java$util$WeakHashMap_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let java$util$WeakHashMap_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    private static let java$util$WeakHashMap_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    private static let java$util$WeakHashMap_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    private static let java$util$WeakHashMap_forEach_java$util$function$BiConsumer__V = invoker("forEach", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiConsumer")))
    public func forEach(a0: java$util$function$BiConsumer?) throws -> Void {
        return try java$util$WeakHashMap$.java$util$WeakHashMap_forEach_java$util$function$BiConsumer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let java$util$WeakHashMap_replaceAll_java$util$function$BiFunction__V = invoker("replaceAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/function/BiFunction")))
    public func replaceAll(a0: java$util$function$BiFunction?) throws -> Void {
        return try java$util$WeakHashMap$.java$util$WeakHashMap_replaceAll_java$util$function$BiFunction__V(jobj)(a0?.jobj ?? nil)
    }

}

public typealias java$util$WeakHashMap$ = java$util$WeakHashMap

public class javax$script$AbstractScriptEngine : java$lang$Object$, javax$script$ScriptEngine {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$AbstractScriptEngine_init__V = constructor()
    public convenience init!() throws {
        let jobj = try javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_init__V()
        self.init(jobj: jobj)
    }

    private static let javax$script$AbstractScriptEngine_init_javax$script$Bindings__V = constructor((JObjectType("javax/script/Bindings")))
    public convenience init!(_ a0: javax$script$Bindings?) throws {
        let jobj = try javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_init_javax$script$Bindings__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let javax$script$AbstractScriptEngine_setContext_javax$script$ScriptContext__V = invoker("setContext", returns: JVoid.jniType, arguments: (JObjectType("javax/script/ScriptContext")))
    public func setContext(a0: javax$script$ScriptContext?) throws -> Void {
        return try javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_setContext_javax$script$ScriptContext__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$AbstractScriptEngine_getContext__javax$script$ScriptContext = invoker("getContext", returns: JObjectType("javax/script/ScriptContext"))
    public func getContext() throws -> javax$script$ScriptContext? {
        return try javax$script$ScriptContext$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_getContext__javax$script$ScriptContext(jobj)())
    }

    private static let javax$script$AbstractScriptEngine_getBindings_I__javax$script$Bindings = invoker("getBindings", returns: JObjectType("javax/script/Bindings"), arguments: (jint.jniType))
    public func getBindings(a0: jint) throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_getBindings_I__javax$script$Bindings(jobj)(a0))
    }

    private static let javax$script$AbstractScriptEngine_setBindings_javax$script$Bindings_I__V = invoker("setBindings", returns: JVoid.jniType, arguments: (JObjectType("javax/script/Bindings"), jint.jniType))
    public func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void {
        return try javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_setBindings_javax$script$Bindings_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let javax$script$AbstractScriptEngine_put_java$lang$String_java$lang$Object__V = invoker("put", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_put_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let javax$script$AbstractScriptEngine_get_java$lang$String__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func get(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_get_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$AbstractScriptEngine_eval_java$io$Reader_javax$script$Bindings__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/io/Reader"), JObjectType("javax/script/Bindings")))
    public func eval(a0: java$io$Reader?, _ a1: javax$script$Bindings?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_eval_java$io$Reader_javax$script$Bindings__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let javax$script$AbstractScriptEngine_eval_java$lang$String_javax$script$Bindings__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/Bindings")))
    public func eval(a0: java$lang$String?, _ a1: javax$script$Bindings?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_eval_java$lang$String_javax$script$Bindings__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let javax$script$AbstractScriptEngine_eval_java$io$Reader__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/io/Reader")))
    public func eval(a0: java$io$Reader?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_eval_java$io$Reader__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$AbstractScriptEngine_eval_java$lang$String__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func eval(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$AbstractScriptEngine$.javax$script$AbstractScriptEngine_eval_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

}

public typealias javax$script$AbstractScriptEngine$ = javax$script$AbstractScriptEngine

public protocol javax$script$Bindings : java$util$Map {
    func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> java$lang$Object?
    func putAll(a0: java$util$Map?) throws -> Void
    func containsKey(a0: java$lang$Object?) throws -> jboolean
    func get(a0: java$lang$Object?) throws -> java$lang$Object?
    func remove(a0: java$lang$Object?) throws -> java$lang$Object?
    func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object?
}

public class javax$script$Bindings$ : java$lang$Object$, javax$script$Bindings, java$util$Map {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$Bindings_put_java$lang$String_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    private static let javax$script$Bindings_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    private static let javax$script$Bindings_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    private static let javax$script$Bindings_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let javax$script$Bindings_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    private static let javax$script$Bindings_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
}

public extension javax$script$Bindings {
    func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Bindings$.javax$script$Bindings_put_java$lang$String_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func putAll(a0: java$util$Map?) throws -> Void {
        return try javax$script$Bindings$.javax$script$Bindings_putAll_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    func containsKey(a0: java$lang$Object?) throws -> jboolean {
        return try javax$script$Bindings$.javax$script$Bindings_containsKey_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Bindings$.javax$script$Bindings_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func remove(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Bindings$.javax$script$Bindings_remove_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Bindings$.javax$script$Bindings_put_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public protocol javax$script$Compilable : JavaObject {
    func compile(a0: java$lang$String?) throws -> javax$script$CompiledScript?
    func compile(a0: java$io$Reader?) throws -> javax$script$CompiledScript?
}

public class javax$script$Compilable$ : java$lang$Object$, javax$script$Compilable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$Compilable_compile_java$lang$String__javax$script$CompiledScript = invoker("compile", returns: JObjectType("javax/script/CompiledScript"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$Compilable_compile_java$io$Reader__javax$script$CompiledScript = invoker("compile", returns: JObjectType("javax/script/CompiledScript"), arguments: (JObjectType("java/io/Reader")))
}

public extension javax$script$Compilable {
    func compile(a0: java$lang$String?) throws -> javax$script$CompiledScript? {
        return try javax$script$CompiledScript$(jobj: javax$script$Compilable$.javax$script$Compilable_compile_java$lang$String__javax$script$CompiledScript(jobj)(a0?.jobj ?? nil))
    }

    func compile(a0: java$io$Reader?) throws -> javax$script$CompiledScript? {
        return try javax$script$CompiledScript$(jobj: javax$script$Compilable$.javax$script$Compilable_compile_java$io$Reader__javax$script$CompiledScript(jobj)(a0?.jobj ?? nil))
    }

}

public class javax$script$CompiledScript : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$CompiledScript_init__V = constructor()
    public convenience init!() throws {
        let jobj = try javax$script$CompiledScript$.javax$script$CompiledScript_init__V()
        self.init(jobj: jobj)
    }

    private static let javax$script$CompiledScript_eval_javax$script$ScriptContext__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("javax/script/ScriptContext")))
    public func eval(a0: javax$script$ScriptContext?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$CompiledScript$.javax$script$CompiledScript_eval_javax$script$ScriptContext__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$CompiledScript_eval_javax$script$Bindings__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("javax/script/Bindings")))
    public func eval(a0: javax$script$Bindings?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$CompiledScript$.javax$script$CompiledScript_eval_javax$script$Bindings__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$CompiledScript_eval__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"))
    public func eval() throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$CompiledScript$.javax$script$CompiledScript_eval__java$lang$Object(jobj)())
    }

    private static let javax$script$CompiledScript_getEngine__javax$script$ScriptEngine = invoker("getEngine", returns: JObjectType("javax/script/ScriptEngine"))
    public func getEngine() throws -> javax$script$ScriptEngine? {
        return try javax$script$ScriptEngine$(jobj: javax$script$CompiledScript$.javax$script$CompiledScript_getEngine__javax$script$ScriptEngine(jobj)())
    }

}

public typealias javax$script$CompiledScript$ = javax$script$CompiledScript

public protocol javax$script$Invocable : JavaObject {
    func invokeMethod(a0: java$lang$Object?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$lang$Object?
    func invokeFunction(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$lang$Object?
    func getInterface(a0: java$lang$Class?) throws -> java$lang$Object?
    func getInterface(a0: java$lang$Object?, _ a1: java$lang$Class?) throws -> java$lang$Object?
}

public class javax$script$Invocable$ : java$lang$Object$, javax$script$Invocable {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$Invocable_invokeMethod_java$lang$Object_java$lang$String_Ajava$lang$Object__java$lang$Object = invoker("invokeMethod", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    private static let javax$script$Invocable_invokeFunction_java$lang$String_Ajava$lang$Object__java$lang$Object = invoker("invokeFunction", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JArray(JObjectType("java/lang/Object"))))
    private static let javax$script$Invocable_getInterface_java$lang$Class__java$lang$Object = invoker("getInterface", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Class")))
    private static let javax$script$Invocable_getInterface_java$lang$Object_java$lang$Class__java$lang$Object = invoker("getInterface", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Class")))
}

public extension javax$script$Invocable {
    func invokeMethod(a0: java$lang$Object?, _ a1: java$lang$String?, _ a2: [java$lang$Object?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Invocable$.javax$script$Invocable_invokeMethod_java$lang$Object_java$lang$String_Ajava$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func invokeFunction(a0: java$lang$String?, _ a1: [java$lang$Object?]?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Invocable$.javax$script$Invocable_invokeFunction_java$lang$String_Ajava$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.map({ java$lang$Object$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func getInterface(a0: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Invocable$.javax$script$Invocable_getInterface_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getInterface(a0: java$lang$Object?, _ a1: java$lang$Class?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$Invocable$.javax$script$Invocable_getInterface_java$lang$Object_java$lang$Class__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public protocol javax$script$ScriptContext : JavaObject {
    func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void
    func getBindings(a0: jint) throws -> javax$script$Bindings?
    func setAttribute(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void
    func getAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object?
    func removeAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object?
    func getAttribute(a0: java$lang$String?) throws -> java$lang$Object?
    func getAttributesScope(a0: java$lang$String?) throws -> jint
    func getWriter() throws -> java$io$Writer?
    func getErrorWriter() throws -> java$io$Writer?
    func setWriter(a0: java$io$Writer?) throws -> Void
    func setErrorWriter(a0: java$io$Writer?) throws -> Void
    func getReader() throws -> java$io$Reader?
    func setReader(a0: java$io$Reader?) throws -> Void
    func getScopes() throws -> java$util$List?
}

public class javax$script$ScriptContext$ : java$lang$Object$, javax$script$ScriptContext {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$ScriptContext_setBindings_javax$script$Bindings_I__V = invoker("setBindings", returns: JVoid.jniType, arguments: (JObjectType("javax/script/Bindings"), jint.jniType))
    private static let javax$script$ScriptContext_getBindings_I__javax$script$Bindings = invoker("getBindings", returns: JObjectType("javax/script/Bindings"), arguments: (jint.jniType))
    private static let javax$script$ScriptContext_setAttribute_java$lang$String_java$lang$Object_I__V = invoker("setAttribute", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), jint.jniType))
    private static let javax$script$ScriptContext_getAttribute_java$lang$String_I__java$lang$Object = invoker("getAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let javax$script$ScriptContext_removeAttribute_java$lang$String_I__java$lang$Object = invoker("removeAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    private static let javax$script$ScriptContext_getAttribute_java$lang$String__java$lang$Object = invoker("getAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptContext_getAttributesScope_java$lang$String__I = invoker("getAttributesScope", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptContext_getWriter__java$io$Writer = invoker("getWriter", returns: JObjectType("java/io/Writer"))
    private static let javax$script$ScriptContext_getErrorWriter__java$io$Writer = invoker("getErrorWriter", returns: JObjectType("java/io/Writer"))
    private static let javax$script$ScriptContext_setWriter_java$io$Writer__V = invoker("setWriter", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer")))
    private static let javax$script$ScriptContext_setErrorWriter_java$io$Writer__V = invoker("setErrorWriter", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer")))
    private static let javax$script$ScriptContext_getReader__java$io$Reader = invoker("getReader", returns: JObjectType("java/io/Reader"))
    private static let javax$script$ScriptContext_setReader_java$io$Reader__V = invoker("setReader", returns: JVoid.jniType, arguments: (JObjectType("java/io/Reader")))
    private static let javax$script$ScriptContext_getScopes__java$util$List = invoker("getScopes", returns: JObjectType("java/util/List"))
}

public extension javax$script$ScriptContext {
    func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_setBindings_javax$script$Bindings_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func getBindings(a0: jint) throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getBindings_I__javax$script$Bindings(jobj)(a0))
    }

    func setAttribute(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_setAttribute_java$lang$String_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    func getAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getAttribute_java$lang$String_I__java$lang$Object(jobj)(a0?.jobj ?? nil, a1))
    }

    func removeAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_removeAttribute_java$lang$String_I__java$lang$Object(jobj)(a0?.jobj ?? nil, a1))
    }

    func getAttribute(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getAttribute_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getAttributesScope(a0: java$lang$String?) throws -> jint {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_getAttributesScope_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    func getWriter() throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getWriter__java$io$Writer(jobj)())
    }

    func getErrorWriter() throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getErrorWriter__java$io$Writer(jobj)())
    }

    func setWriter(a0: java$io$Writer?) throws -> Void {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_setWriter_java$io$Writer__V(jobj)(a0?.jobj ?? nil)
    }

    func setErrorWriter(a0: java$io$Writer?) throws -> Void {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_setErrorWriter_java$io$Writer__V(jobj)(a0?.jobj ?? nil)
    }

    func getReader() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getReader__java$io$Reader(jobj)())
    }

    func setReader(a0: java$io$Reader?) throws -> Void {
        return try javax$script$ScriptContext$.javax$script$ScriptContext_setReader_java$io$Reader__V(jobj)(a0?.jobj ?? nil)
    }

    func getScopes() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$ScriptContext$.javax$script$ScriptContext_getScopes__java$util$List(jobj)())
    }

}

public protocol javax$script$ScriptEngine : JavaObject {
    func eval(a0: java$lang$String?, _ a1: javax$script$ScriptContext?) throws -> java$lang$Object?
    func eval(a0: java$io$Reader?, _ a1: javax$script$ScriptContext?) throws -> java$lang$Object?
    func eval(a0: java$lang$String?) throws -> java$lang$Object?
    func eval(a0: java$io$Reader?) throws -> java$lang$Object?
    func eval(a0: java$lang$String?, _ a1: javax$script$Bindings?) throws -> java$lang$Object?
    func eval(a0: java$io$Reader?, _ a1: javax$script$Bindings?) throws -> java$lang$Object?
    func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void
    func get(a0: java$lang$String?) throws -> java$lang$Object?
    func getBindings(a0: jint) throws -> javax$script$Bindings?
    func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void
    func createBindings() throws -> javax$script$Bindings?
    func getContext() throws -> javax$script$ScriptContext?
    func setContext(a0: javax$script$ScriptContext?) throws -> Void
    func getFactory() throws -> javax$script$ScriptEngineFactory?
}

public class javax$script$ScriptEngine$ : java$lang$Object$, javax$script$ScriptEngine {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$ScriptEngine_eval_java$lang$String_javax$script$ScriptContext__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/ScriptContext")))
    private static let javax$script$ScriptEngine_eval_java$io$Reader_javax$script$ScriptContext__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/io/Reader"), JObjectType("javax/script/ScriptContext")))
    private static let javax$script$ScriptEngine_eval_java$lang$String__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptEngine_eval_java$io$Reader__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/io/Reader")))
    private static let javax$script$ScriptEngine_eval_java$lang$String_javax$script$Bindings__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/Bindings")))
    private static let javax$script$ScriptEngine_eval_java$io$Reader_javax$script$Bindings__java$lang$Object = invoker("eval", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/io/Reader"), JObjectType("javax/script/Bindings")))
    private static let javax$script$ScriptEngine_put_java$lang$String_java$lang$Object__V = invoker("put", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    private static let javax$script$ScriptEngine_get_java$lang$String__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptEngine_getBindings_I__javax$script$Bindings = invoker("getBindings", returns: JObjectType("javax/script/Bindings"), arguments: (jint.jniType))
    private static let javax$script$ScriptEngine_setBindings_javax$script$Bindings_I__V = invoker("setBindings", returns: JVoid.jniType, arguments: (JObjectType("javax/script/Bindings"), jint.jniType))
    private static let javax$script$ScriptEngine_createBindings__javax$script$Bindings = invoker("createBindings", returns: JObjectType("javax/script/Bindings"))
    private static let javax$script$ScriptEngine_getContext__javax$script$ScriptContext = invoker("getContext", returns: JObjectType("javax/script/ScriptContext"))
    private static let javax$script$ScriptEngine_setContext_javax$script$ScriptContext__V = invoker("setContext", returns: JVoid.jniType, arguments: (JObjectType("javax/script/ScriptContext")))
    private static let javax$script$ScriptEngine_getFactory__javax$script$ScriptEngineFactory = invoker("getFactory", returns: JObjectType("javax/script/ScriptEngineFactory"))
}

public extension javax$script$ScriptEngine {
    func eval(a0: java$lang$String?, _ a1: javax$script$ScriptContext?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$lang$String_javax$script$ScriptContext__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func eval(a0: java$io$Reader?, _ a1: javax$script$ScriptContext?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$io$Reader_javax$script$ScriptContext__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func eval(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func eval(a0: java$io$Reader?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$io$Reader__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func eval(a0: java$lang$String?, _ a1: javax$script$Bindings?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$lang$String_javax$script$Bindings__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func eval(a0: java$io$Reader?, _ a1: javax$script$Bindings?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_eval_java$io$Reader_javax$script$Bindings__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try javax$script$ScriptEngine$.javax$script$ScriptEngine_put_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    func get(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_get_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getBindings(a0: jint) throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_getBindings_I__javax$script$Bindings(jobj)(a0))
    }

    func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void {
        return try javax$script$ScriptEngine$.javax$script$ScriptEngine_setBindings_javax$script$Bindings_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    func createBindings() throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_createBindings__javax$script$Bindings(jobj)())
    }

    func getContext() throws -> javax$script$ScriptContext? {
        return try javax$script$ScriptContext$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_getContext__javax$script$ScriptContext(jobj)())
    }

    func setContext(a0: javax$script$ScriptContext?) throws -> Void {
        return try javax$script$ScriptEngine$.javax$script$ScriptEngine_setContext_javax$script$ScriptContext__V(jobj)(a0?.jobj ?? nil)
    }

    func getFactory() throws -> javax$script$ScriptEngineFactory? {
        return try javax$script$ScriptEngineFactory$(jobj: javax$script$ScriptEngine$.javax$script$ScriptEngine_getFactory__javax$script$ScriptEngineFactory(jobj)())
    }

}

public protocol javax$script$ScriptEngineFactory : JavaObject {
    func getEngineName() throws -> java$lang$String?
    func getEngineVersion() throws -> java$lang$String?
    func getExtensions() throws -> java$util$List?
    func getMimeTypes() throws -> java$util$List?
    func getNames() throws -> java$util$List?
    func getLanguageName() throws -> java$lang$String?
    func getLanguageVersion() throws -> java$lang$String?
    func getParameter(a0: java$lang$String?) throws -> java$lang$Object?
    func getMethodCallSyntax(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: [java$lang$String?]?) throws -> java$lang$String?
    func getOutputStatement(a0: java$lang$String?) throws -> java$lang$String?
    func getProgram(a0: [java$lang$String?]?) throws -> java$lang$String?
    func getScriptEngine() throws -> javax$script$ScriptEngine?
}

public class javax$script$ScriptEngineFactory$ : java$lang$Object$, javax$script$ScriptEngineFactory {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$ScriptEngineFactory_getEngineName__java$lang$String = invoker("getEngineName", returns: JObjectType("java/lang/String"))
    private static let javax$script$ScriptEngineFactory_getEngineVersion__java$lang$String = invoker("getEngineVersion", returns: JObjectType("java/lang/String"))
    private static let javax$script$ScriptEngineFactory_getExtensions__java$util$List = invoker("getExtensions", returns: JObjectType("java/util/List"))
    private static let javax$script$ScriptEngineFactory_getMimeTypes__java$util$List = invoker("getMimeTypes", returns: JObjectType("java/util/List"))
    private static let javax$script$ScriptEngineFactory_getNames__java$util$List = invoker("getNames", returns: JObjectType("java/util/List"))
    private static let javax$script$ScriptEngineFactory_getLanguageName__java$lang$String = invoker("getLanguageName", returns: JObjectType("java/lang/String"))
    private static let javax$script$ScriptEngineFactory_getLanguageVersion__java$lang$String = invoker("getLanguageVersion", returns: JObjectType("java/lang/String"))
    private static let javax$script$ScriptEngineFactory_getParameter_java$lang$String__java$lang$Object = invoker("getParameter", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptEngineFactory_getMethodCallSyntax_java$lang$String_java$lang$String_Ajava$lang$String__java$lang$String = invoker("getMethodCallSyntax", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/String"), JArray(JObjectType("java/lang/String"))))
    private static let javax$script$ScriptEngineFactory_getOutputStatement_java$lang$String__java$lang$String = invoker("getOutputStatement", returns: JObjectType("java/lang/String"), arguments: (JObjectType("java/lang/String")))
    private static let javax$script$ScriptEngineFactory_getProgram_Ajava$lang$String__java$lang$String = invoker("getProgram", returns: JObjectType("java/lang/String"), arguments: (JArray(JObjectType("java/lang/String"))))
    private static let javax$script$ScriptEngineFactory_getScriptEngine__javax$script$ScriptEngine = invoker("getScriptEngine", returns: JObjectType("javax/script/ScriptEngine"))
}

public extension javax$script$ScriptEngineFactory {
    func getEngineName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getEngineName__java$lang$String(jobj)())
    }

    func getEngineVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getEngineVersion__java$lang$String(jobj)())
    }

    func getExtensions() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getExtensions__java$util$List(jobj)())
    }

    func getMimeTypes() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getMimeTypes__java$util$List(jobj)())
    }

    func getNames() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getNames__java$util$List(jobj)())
    }

    func getLanguageName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getLanguageName__java$lang$String(jobj)())
    }

    func getLanguageVersion() throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getLanguageVersion__java$lang$String(jobj)())
    }

    func getParameter(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getParameter_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    func getMethodCallSyntax(a0: java$lang$String?, _ a1: java$lang$String?, _ a2: [java$lang$String?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getMethodCallSyntax_java$lang$String_java$lang$String_Ajava$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func getOutputStatement(a0: java$lang$String?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getOutputStatement_java$lang$String__java$lang$String(jobj)(a0?.jobj ?? nil))
    }

    func getProgram(a0: [java$lang$String?]?) throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getProgram_Ajava$lang$String__java$lang$String(jobj)(a0?.map({ java$lang$String$(jobj: $0?.jobj ?? nil) }).arrayToJArray() ?? nil))
    }

    func getScriptEngine() throws -> javax$script$ScriptEngine? {
        return try javax$script$ScriptEngine$(jobj: javax$script$ScriptEngineFactory$.javax$script$ScriptEngineFactory_getScriptEngine__javax$script$ScriptEngine(jobj)())
    }

}

public class javax$script$ScriptEngineManager : java$lang$Object$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$ScriptEngineManager_init__V = constructor()
    public convenience init!() throws {
        let jobj = try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_init__V()
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptEngineManager_init_java$lang$ClassLoader__V = constructor((JObjectType("java/lang/ClassLoader")))
    public convenience init!(_ a0: java$lang$ClassLoader?) throws {
        let jobj = try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_init_java$lang$ClassLoader__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptEngineManager_setBindings_javax$script$Bindings__V = invoker("setBindings", returns: JVoid.jniType, arguments: (JObjectType("javax/script/Bindings")))
    public func setBindings(a0: javax$script$Bindings?) throws -> Void {
        return try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_setBindings_javax$script$Bindings__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$ScriptEngineManager_getBindings__javax$script$Bindings = invoker("getBindings", returns: JObjectType("javax/script/Bindings"))
    public func getBindings() throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_getBindings__javax$script$Bindings(jobj)())
    }

    private static let javax$script$ScriptEngineManager_put_java$lang$String_java$lang$Object__V = invoker("put", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> Void {
        return try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_put_java$lang$String_java$lang$Object__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let javax$script$ScriptEngineManager_get_java$lang$String__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func get(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_get_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$ScriptEngineManager_getEngineByName_java$lang$String__javax$script$ScriptEngine = invoker("getEngineByName", returns: JObjectType("javax/script/ScriptEngine"), arguments: (JObjectType("java/lang/String")))
    public func getEngineByName(a0: java$lang$String?) throws -> javax$script$ScriptEngine? {
        return try javax$script$ScriptEngine$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_getEngineByName_java$lang$String__javax$script$ScriptEngine(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$ScriptEngineManager_getEngineByExtension_java$lang$String__javax$script$ScriptEngine = invoker("getEngineByExtension", returns: JObjectType("javax/script/ScriptEngine"), arguments: (JObjectType("java/lang/String")))
    public func getEngineByExtension(a0: java$lang$String?) throws -> javax$script$ScriptEngine? {
        return try javax$script$ScriptEngine$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_getEngineByExtension_java$lang$String__javax$script$ScriptEngine(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$ScriptEngineManager_getEngineByMimeType_java$lang$String__javax$script$ScriptEngine = invoker("getEngineByMimeType", returns: JObjectType("javax/script/ScriptEngine"), arguments: (JObjectType("java/lang/String")))
    public func getEngineByMimeType(a0: java$lang$String?) throws -> javax$script$ScriptEngine? {
        return try javax$script$ScriptEngine$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_getEngineByMimeType_java$lang$String__javax$script$ScriptEngine(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$ScriptEngineManager_getEngineFactories__java$util$List = invoker("getEngineFactories", returns: JObjectType("java/util/List"))
    public func getEngineFactories() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_getEngineFactories__java$util$List(jobj)())
    }

    private static let javax$script$ScriptEngineManager_registerEngineName_java$lang$String_javax$script$ScriptEngineFactory__V = invoker("registerEngineName", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/ScriptEngineFactory")))
    public func registerEngineName(a0: java$lang$String?, _ a1: javax$script$ScriptEngineFactory?) throws -> Void {
        return try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_registerEngineName_java$lang$String_javax$script$ScriptEngineFactory__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let javax$script$ScriptEngineManager_registerEngineMimeType_java$lang$String_javax$script$ScriptEngineFactory__V = invoker("registerEngineMimeType", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/ScriptEngineFactory")))
    public func registerEngineMimeType(a0: java$lang$String?, _ a1: javax$script$ScriptEngineFactory?) throws -> Void {
        return try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_registerEngineMimeType_java$lang$String_javax$script$ScriptEngineFactory__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

    private static let javax$script$ScriptEngineManager_registerEngineExtension_java$lang$String_javax$script$ScriptEngineFactory__V = invoker("registerEngineExtension", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("javax/script/ScriptEngineFactory")))
    public func registerEngineExtension(a0: java$lang$String?, _ a1: javax$script$ScriptEngineFactory?) throws -> Void {
        return try javax$script$ScriptEngineManager$.javax$script$ScriptEngineManager_registerEngineExtension_java$lang$String_javax$script$ScriptEngineFactory__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil)
    }

}

public typealias javax$script$ScriptEngineManager$ = javax$script$ScriptEngineManager

public class javax$script$ScriptException : java$lang$Exception$ {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$ScriptException_init_java$lang$String__V = constructor((JObjectType("java/lang/String")))
    public convenience init!(_ a0: java$lang$String?) throws {
        let jobj = try javax$script$ScriptException$.javax$script$ScriptException_init_java$lang$String__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptException_init_java$lang$Exception__V = constructor((JObjectType("java/lang/Exception")))
    public convenience init!(_ a0: java$lang$Exception?) throws {
        let jobj = try javax$script$ScriptException$.javax$script$ScriptException_init_java$lang$Exception__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptException_init_java$lang$String_java$lang$String_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint) throws {
        let jobj = try javax$script$ScriptException$.javax$script$ScriptException_init_java$lang$String_java$lang$String_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptException_init_java$lang$String_java$lang$String_I_I__V = constructor((JObjectType("java/lang/String"), JObjectType("java/lang/String"), jint.jniType, jint.jniType))
    public convenience init!(_ a0: java$lang$String?, _ a1: java$lang$String?, _ a2: jint, _ a3: jint) throws {
        let jobj = try javax$script$ScriptException$.javax$script$ScriptException_init_java$lang$String_java$lang$String_I_I__V(a0?.jobj ?? nil, a1?.jobj ?? nil, a2, a3)
        self.init(jobj: jobj)
    }

    private static let javax$script$ScriptException_getMessage__java$lang$String = invoker("getMessage", returns: JObjectType("java/lang/String"))
    private static let javax$script$ScriptException_getLineNumber__I = invoker("getLineNumber", returns: jint.jniType)
    public func getLineNumber() throws -> jint {
        return try javax$script$ScriptException$.javax$script$ScriptException_getLineNumber__I(jobj)()
    }

    private static let javax$script$ScriptException_getColumnNumber__I = invoker("getColumnNumber", returns: jint.jniType)
    public func getColumnNumber() throws -> jint {
        return try javax$script$ScriptException$.javax$script$ScriptException_getColumnNumber__I(jobj)()
    }

    private static let javax$script$ScriptException_getFileName__java$lang$String = invoker("getFileName", returns: JObjectType("java/lang/String"))
    public func getFileName() throws -> java$lang$String? {
        return try java$lang$String$(jobj: javax$script$ScriptException$.javax$script$ScriptException_getFileName__java$lang$String(jobj)())
    }

}

public typealias javax$script$ScriptException$ = javax$script$ScriptException

public class javax$script$SimpleBindings : java$lang$Object$, javax$script$Bindings {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$SimpleBindings_init_java$util$Map__V = constructor((JObjectType("java/util/Map")))
    public convenience init!(_ a0: java$util$Map?) throws {
        let jobj = try javax$script$SimpleBindings$.javax$script$SimpleBindings_init_java$util$Map__V(a0?.jobj ?? nil)
        self.init(jobj: jobj)
    }

    private static let javax$script$SimpleBindings_init__V = constructor()
    public convenience init!() throws {
        let jobj = try javax$script$SimpleBindings$.javax$script$SimpleBindings_init__V()
        self.init(jobj: jobj)
    }

    private static let javax$script$SimpleBindings_put_java$lang$String_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$String?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_put_java$lang$String_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

    private static let javax$script$SimpleBindings_putAll_java$util$Map__V = invoker("putAll", returns: JVoid.jniType, arguments: (JObjectType("java/util/Map")))
    public func putAll(a0: java$util$Map?) throws -> Void {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_putAll_java$util$Map__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleBindings_clear__V = invoker("clear", returns: JVoid.jniType)
    public func clear() throws -> Void {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_clear__V(jobj)()
    }

    private static let javax$script$SimpleBindings_containsKey_java$lang$Object__Z = invoker("containsKey", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsKey(a0: java$lang$Object?) throws -> jboolean {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_containsKey_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleBindings_containsValue_java$lang$Object__Z = invoker("containsValue", returns: jboolean.jniType, arguments: (JObjectType("java/lang/Object")))
    public func containsValue(a0: java$lang$Object?) throws -> jboolean {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_containsValue_java$lang$Object__Z(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleBindings_entrySet__java$util$Set = invoker("entrySet", returns: JObjectType("java/util/Set"))
    public func entrySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_entrySet__java$util$Set(jobj)())
    }

    private static let javax$script$SimpleBindings_get_java$lang$Object__java$lang$Object = invoker("get", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func get(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_get_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$SimpleBindings_isEmpty__Z = invoker("isEmpty", returns: jboolean.jniType)
    public func isEmpty() throws -> jboolean {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_isEmpty__Z(jobj)()
    }

    private static let javax$script$SimpleBindings_keySet__java$util$Set = invoker("keySet", returns: JObjectType("java/util/Set"))
    public func keySet() throws -> java$util$Set? {
        return try java$util$Set$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_keySet__java$util$Set(jobj)())
    }

    private static let javax$script$SimpleBindings_remove_java$lang$Object__java$lang$Object = invoker("remove", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object")))
    public func remove(a0: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_remove_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$SimpleBindings_size__I = invoker("size", returns: jint.jniType)
    public func size() throws -> jint {
        return try javax$script$SimpleBindings$.javax$script$SimpleBindings_size__I(jobj)()
    }

    private static let javax$script$SimpleBindings_values__java$util$Collection = invoker("values", returns: JObjectType("java/util/Collection"))
    public func values() throws -> java$util$Collection? {
        return try java$util$Collection$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_values__java$util$Collection(jobj)())
    }

    private static let javax$script$SimpleBindings_put_java$lang$Object_java$lang$Object__java$lang$Object = invoker("put", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/Object"), JObjectType("java/lang/Object")))
    public func put(a0: java$lang$Object?, _ a1: java$lang$Object?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleBindings$.javax$script$SimpleBindings_put_java$lang$Object_java$lang$Object__java$lang$Object(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil))
    }

}

public typealias javax$script$SimpleBindings$ = javax$script$SimpleBindings

public class javax$script$SimpleScriptContext : java$lang$Object$, javax$script$ScriptContext {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

    private static let javax$script$SimpleScriptContext_init__V = constructor()
    public convenience init!() throws {
        let jobj = try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_init__V()
        self.init(jobj: jobj)
    }

    private static let javax$script$SimpleScriptContext_setBindings_javax$script$Bindings_I__V = invoker("setBindings", returns: JVoid.jniType, arguments: (JObjectType("javax/script/Bindings"), jint.jniType))
    public func setBindings(a0: javax$script$Bindings?, _ a1: jint) throws -> Void {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_setBindings_javax$script$Bindings_I__V(jobj)(a0?.jobj ?? nil, a1)
    }

    private static let javax$script$SimpleScriptContext_getAttribute_java$lang$String__java$lang$Object = invoker("getAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String")))
    public func getAttribute(a0: java$lang$String?) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getAttribute_java$lang$String__java$lang$Object(jobj)(a0?.jobj ?? nil))
    }

    private static let javax$script$SimpleScriptContext_getAttribute_java$lang$String_I__java$lang$Object = invoker("getAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func getAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getAttribute_java$lang$String_I__java$lang$Object(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let javax$script$SimpleScriptContext_removeAttribute_java$lang$String_I__java$lang$Object = invoker("removeAttribute", returns: JObjectType("java/lang/Object"), arguments: (JObjectType("java/lang/String"), jint.jniType))
    public func removeAttribute(a0: java$lang$String?, _ a1: jint) throws -> java$lang$Object? {
        return try java$lang$Object$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_removeAttribute_java$lang$String_I__java$lang$Object(jobj)(a0?.jobj ?? nil, a1))
    }

    private static let javax$script$SimpleScriptContext_setAttribute_java$lang$String_java$lang$Object_I__V = invoker("setAttribute", returns: JVoid.jniType, arguments: (JObjectType("java/lang/String"), JObjectType("java/lang/Object"), jint.jniType))
    public func setAttribute(a0: java$lang$String?, _ a1: java$lang$Object?, _ a2: jint) throws -> Void {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_setAttribute_java$lang$String_java$lang$Object_I__V(jobj)(a0?.jobj ?? nil, a1?.jobj ?? nil, a2)
    }

    private static let javax$script$SimpleScriptContext_getWriter__java$io$Writer = invoker("getWriter", returns: JObjectType("java/io/Writer"))
    public func getWriter() throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getWriter__java$io$Writer(jobj)())
    }

    private static let javax$script$SimpleScriptContext_getReader__java$io$Reader = invoker("getReader", returns: JObjectType("java/io/Reader"))
    public func getReader() throws -> java$io$Reader? {
        return try java$io$Reader$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getReader__java$io$Reader(jobj)())
    }

    private static let javax$script$SimpleScriptContext_setReader_java$io$Reader__V = invoker("setReader", returns: JVoid.jniType, arguments: (JObjectType("java/io/Reader")))
    public func setReader(a0: java$io$Reader?) throws -> Void {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_setReader_java$io$Reader__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleScriptContext_setWriter_java$io$Writer__V = invoker("setWriter", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer")))
    public func setWriter(a0: java$io$Writer?) throws -> Void {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_setWriter_java$io$Writer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleScriptContext_getErrorWriter__java$io$Writer = invoker("getErrorWriter", returns: JObjectType("java/io/Writer"))
    public func getErrorWriter() throws -> java$io$Writer? {
        return try java$io$Writer$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getErrorWriter__java$io$Writer(jobj)())
    }

    private static let javax$script$SimpleScriptContext_setErrorWriter_java$io$Writer__V = invoker("setErrorWriter", returns: JVoid.jniType, arguments: (JObjectType("java/io/Writer")))
    public func setErrorWriter(a0: java$io$Writer?) throws -> Void {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_setErrorWriter_java$io$Writer__V(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleScriptContext_getAttributesScope_java$lang$String__I = invoker("getAttributesScope", returns: jint.jniType, arguments: (JObjectType("java/lang/String")))
    public func getAttributesScope(a0: java$lang$String?) throws -> jint {
        return try javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getAttributesScope_java$lang$String__I(jobj)(a0?.jobj ?? nil)
    }

    private static let javax$script$SimpleScriptContext_getBindings_I__javax$script$Bindings = invoker("getBindings", returns: JObjectType("javax/script/Bindings"), arguments: (jint.jniType))
    public func getBindings(a0: jint) throws -> javax$script$Bindings? {
        return try javax$script$Bindings$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getBindings_I__javax$script$Bindings(jobj)(a0))
    }

    private static let javax$script$SimpleScriptContext_getScopes__java$util$List = invoker("getScopes", returns: JObjectType("java/util/List"))
    public func getScopes() throws -> java$util$List? {
        return try java$util$List$(jobj: javax$script$SimpleScriptContext$.javax$script$SimpleScriptContext_getScopes__java$util$List(jobj)())
    }

}

public typealias javax$script$SimpleScriptContext$ = javax$script$SimpleScriptContext

public protocol java$util$function$ToDoubleFunction : JavaObject {
}

public class java$util$function$ToDoubleFunction$ : java$lang$Object$, java$util$function$ToDoubleFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$file$Path : JavaObject {
}

public class java$nio$file$Path$ : java$lang$Object$, java$nio$file$Path {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$Instant : JavaObject {
}

public class java$time$Instant$ : java$lang$Object$, java$time$Instant {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$DoubleBinaryOperator : JavaObject {
}

public class java$util$function$DoubleBinaryOperator$ : java$lang$Object$, java$util$function$DoubleBinaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol javax$xml$transform$Source : JavaObject {
}

public class javax$xml$transform$Source$ : java$lang$Object$, javax$xml$transform$Source {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$Supplier : JavaObject {
}

public class java$util$function$Supplier$ : java$lang$Object$, java$util$function$Supplier {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntBinaryOperator : JavaObject {
}

public class java$util$function$IntBinaryOperator$ : java$lang$Object$, java$util$function$IntBinaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$DoubleConsumer : JavaObject {
}

public class java$util$function$DoubleConsumer$ : java$lang$Object$, java$util$function$DoubleConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$charset$CharsetEncoder : JavaObject {
}

public class java$nio$charset$CharsetEncoder$ : java$lang$Object$, java$nio$charset$CharsetEncoder {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$LongBuffer : JavaObject {
}

public class java$nio$LongBuffer$ : java$lang$Object$, java$nio$LongBuffer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Spliterator$OfInt : JavaObject {
}

public class java$util$Spliterator$OfInt$ : java$lang$Object$, java$util$Spliterator$OfInt {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$ZonedDateTime : JavaObject {
}

public class java$time$ZonedDateTime$ : java$lang$Object$, java$time$ZonedDateTime {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$jar$JarFile : JavaObject {
}

public class java$util$jar$JarFile$ : java$lang$Object$, java$util$jar$JarFile {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$LongConsumer : JavaObject {
}

public class java$util$function$LongConsumer$ : java$lang$Object$, java$util$function$LongConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$ReadableByteChannel : JavaObject {
}

public class java$nio$channels$ReadableByteChannel$ : java$lang$Object$, java$nio$channels$ReadableByteChannel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$Function : JavaObject {
}

public class java$util$function$Function$ : java$lang$Object$, java$util$function$Function {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$security$Permission : JavaObject {
}

public class java$security$Permission$ : java$lang$Object$, java$security$Permission {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$charset$CharsetDecoder : JavaObject {
}

public class java$nio$charset$CharsetDecoder$ : java$lang$Object$, java$nio$charset$CharsetDecoder {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$logging$Logger : JavaObject {
}

public class java$util$logging$Logger$ : java$lang$Object$, java$util$logging$Logger {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$stream$LongStream : JavaObject {
}

public class java$util$stream$LongStream$ : java$lang$Object$, java$util$stream$LongStream {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$BiFunction : JavaObject {
}

public class java$util$function$BiFunction$ : java$lang$Object$, java$util$function$BiFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$Predicate : JavaObject {
}

public class java$util$function$Predicate$ : java$lang$Object$, java$util$function$Predicate {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$ToIntFunction : JavaObject {
}

public class java$util$function$ToIntFunction$ : java$lang$Object$, java$util$function$ToIntFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol sun$reflect$MethodAccessor : JavaObject {
}

public class sun$reflect$MethodAccessor$ : java$lang$Object$, sun$reflect$MethodAccessor {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Map$Entry : JavaObject {
}

public class java$util$Map$Entry$ : java$lang$Object$, java$util$Map$Entry {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$security$Principal : JavaObject {
}

public class java$security$Principal$ : java$lang$Object$, java$security$Principal {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$security$PrivilegedExceptionAction : JavaObject {
}

public class java$security$PrivilegedExceptionAction$ : java$lang$Object$, java$security$PrivilegedExceptionAction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$io$ObjectOutputStream$PutField : JavaObject {
}

public class java$io$ObjectOutputStream$PutField$ : java$lang$Object$, java$io$ObjectOutputStream$PutField {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$stream$DoubleStream : JavaObject {
}

public class java$util$stream$DoubleStream$ : java$lang$Object$, java$util$stream$DoubleStream {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$ByteBuffer : JavaObject {
}

public class java$nio$ByteBuffer$ : java$lang$Object$, java$nio$ByteBuffer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$net$Authenticator$RequestorType : JavaObject {
}

public class java$net$Authenticator$RequestorType$ : java$lang$Object$, java$net$Authenticator$RequestorType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$text$Format$Field : JavaObject {
}

public class java$text$Format$Field$ : java$lang$Object$, java$text$Format$Field {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$jar$Manifest : JavaObject {
}

public class java$util$jar$Manifest$ : java$lang$Object$, java$util$jar$Manifest {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$security$ProtectionDomain : JavaObject {
}

public class java$security$ProtectionDomain$ : java$lang$Object$, java$security$ProtectionDomain {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$ToLongFunction : JavaObject {
}

public class java$util$function$ToLongFunction$ : java$lang$Object$, java$util$function$ToLongFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$CharBuffer : JavaObject {
}

public class java$nio$CharBuffer$ : java$lang$Object$, java$nio$CharBuffer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$LongBinaryOperator : JavaObject {
}

public class java$util$function$LongBinaryOperator$ : java$lang$Object$, java$util$function$LongBinaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$lang$ProcessBuilder$Redirect : JavaObject {
}

public class java$lang$ProcessBuilder$Redirect$ : java$lang$Object$, java$lang$ProcessBuilder$Redirect {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$BiConsumer : JavaObject {
}

public class java$util$function$BiConsumer$ : java$lang$Object$, java$util$function$BiConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$concurrent$Executor : JavaObject {
}

public class java$util$concurrent$Executor$ : java$lang$Object$, java$util$concurrent$Executor {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$text$Normalizer$Form : JavaObject {
}

public class java$text$Normalizer$Form$ : java$lang$Object$, java$text$Normalizer$Form {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$text$RBCollationTables$BuildAPI : JavaObject {
}

public class java$text$RBCollationTables$BuildAPI$ : java$lang$Object$, java$text$RBCollationTables$BuildAPI {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntUnaryOperator : JavaObject {
}

public class java$util$function$IntUnaryOperator$ : java$lang$Object$, java$util$function$IntUnaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$DoubleSupplier : JavaObject {
}

public class java$util$function$DoubleSupplier$ : java$lang$Object$, java$util$function$DoubleSupplier {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Locale$FilteringMode : JavaObject {
}

public class java$util$Locale$FilteringMode$ : java$lang$Object$, java$util$Locale$FilteringMode {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$lang$annotation$Annotation : JavaObject {
}

public class java$lang$annotation$Annotation$ : java$lang$Object$, java$lang$annotation$Annotation {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$text$Format$FieldDelegate : JavaObject {
}

public class java$text$Format$FieldDelegate$ : java$lang$Object$, java$text$Format$FieldDelegate {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$charset$Charset : JavaObject {
}

public class java$nio$charset$Charset$ : java$lang$Object$, java$nio$charset$Charset {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$stream$Stream : JavaObject {
}

public class java$util$stream$Stream$ : java$lang$Object$, java$util$stream$Stream {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$jar$Attributes : JavaObject {
}

public class java$util$jar$Attributes$ : java$lang$Object$, java$util$jar$Attributes {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$ZoneId : JavaObject {
}

public class java$time$ZoneId$ : java$lang$Object$, java$time$ZoneId {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$FileChannel : JavaObject {
}

public class java$nio$channels$FileChannel$ : java$lang$Object$, java$nio$channels$FileChannel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$ResourceBundle$Control : JavaObject {
}

public class java$util$ResourceBundle$Control$ : java$lang$Object$, java$util$ResourceBundle$Control {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$DatagramChannel : JavaObject {
}

public class java$nio$channels$DatagramChannel$ : java$lang$Object$, java$nio$channels$DatagramChannel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$LocalDate : JavaObject {
}

public class java$time$LocalDate$ : java$lang$Object$, java$time$LocalDate {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$BinaryOperator : JavaObject {
}

public class java$util$function$BinaryOperator$ : java$lang$Object$, java$util$function$BinaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntToLongFunction : JavaObject {
}

public class java$util$function$IntToLongFunction$ : java$lang$Object$, java$util$function$IntToLongFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$lang$Thread$State : JavaObject {
}

public class java$lang$Thread$State$ : java$lang$Object$, java$lang$Thread$State {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$security$cert$Certificate : JavaObject {
}

public class java$security$cert$Certificate$ : java$lang$Object$, java$security$cert$Certificate {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$concurrent$TimeUnit : JavaObject {
}

public class java$util$concurrent$TimeUnit$ : java$lang$Object$, java$util$concurrent$TimeUnit {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntConsumer : JavaObject {
}

public class java$util$function$IntConsumer$ : java$lang$Object$, java$util$function$IntConsumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$lang$Thread$UncaughtExceptionHandler : JavaObject {
}

public class java$lang$Thread$UncaughtExceptionHandler$ : java$lang$Object$, java$lang$Thread$UncaughtExceptionHandler {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$sql$SQLType : JavaObject {
}

public class java$sql$SQLType$ : java$lang$Object$, java$sql$SQLType {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol javax$xml$transform$Result : JavaObject {
}

public class javax$xml$transform$Result$ : java$lang$Object$, javax$xml$transform$Result {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$PrimitiveIterator$OfDouble : JavaObject {
}

public class java$util$PrimitiveIterator$OfDouble$ : java$lang$Object$, java$util$PrimitiveIterator$OfDouble {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$LocalDateTime : JavaObject {
}

public class java$time$LocalDateTime$ : java$lang$Object$, java$time$LocalDateTime {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Spliterator$OfDouble : JavaObject {
}

public class java$util$Spliterator$OfDouble$ : java$lang$Object$, java$util$Spliterator$OfDouble {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$Consumer : JavaObject {
}

public class java$util$function$Consumer$ : java$lang$Object$, java$util$function$Consumer {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Base64$Encoder : JavaObject {
}

public class java$util$Base64$Encoder$ : java$lang$Object$, java$util$Base64$Encoder {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$jar$JarEntry : JavaObject {
}

public class java$util$jar$JarEntry$ : java$lang$Object$, java$util$jar$JarEntry {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntToDoubleFunction : JavaObject {
}

public class java$util$function$IntToDoubleFunction$ : java$lang$Object$, java$util$function$IntToDoubleFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$stream$IntStream : JavaObject {
}

public class java$util$stream$IntStream$ : java$lang$Object$, java$util$stream$IntStream {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$SocketChannel : JavaObject {
}

public class java$nio$channels$SocketChannel$ : java$lang$Object$, java$nio$channels$SocketChannel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$regex$Pattern : JavaObject {
}

public class java$util$regex$Pattern$ : java$lang$Object$, java$util$regex$Pattern {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntFunction : JavaObject {
}

public class java$util$function$IntFunction$ : java$lang$Object$, java$util$function$IntFunction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$net$Proxy$Type : JavaObject {
}

public class java$net$Proxy$Type$ : java$lang$Object$, java$net$Proxy$Type {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$Channel : JavaObject {
}

public class java$nio$channels$Channel$ : java$lang$Object$, java$nio$channels$Channel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$io$ObjectInputStream$GetField : JavaObject {
}

public class java$io$ObjectInputStream$GetField$ : java$lang$Object$, java$io$ObjectInputStream$GetField {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$PrimitiveIterator$OfInt : JavaObject {
}

public class java$util$PrimitiveIterator$OfInt$ : java$lang$Object$, java$util$PrimitiveIterator$OfInt {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol sun$reflect$LangReflectAccess : JavaObject {
}

public class sun$reflect$LangReflectAccess$ : java$lang$Object$, sun$reflect$LangReflectAccess {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$sql$DriverAction : JavaObject {
}

public class java$sql$DriverAction$ : java$lang$Object$, java$sql$DriverAction {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$UnaryOperator : JavaObject {
}

public class java$util$function$UnaryOperator$ : java$lang$Object$, java$util$function$UnaryOperator {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$PrimitiveIterator$OfLong : JavaObject {
}

public class java$util$PrimitiveIterator$OfLong$ : java$lang$Object$, java$util$PrimitiveIterator$OfLong {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Locale$Category : JavaObject {
}

public class java$util$Locale$Category$ : java$lang$Object$, java$util$Locale$Category {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$regex$MatchResult : JavaObject {
}

public class java$util$regex$MatchResult$ : java$lang$Object$, java$util$regex$MatchResult {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$LongSupplier : JavaObject {
}

public class java$util$function$LongSupplier$ : java$lang$Object$, java$util$function$LongSupplier {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$function$IntSupplier : JavaObject {
}

public class java$util$function$IntSupplier$ : java$lang$Object$, java$util$function$IntSupplier {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Spliterator$OfLong : JavaObject {
}

public class java$util$Spliterator$OfLong$ : java$lang$Object$, java$util$Spliterator$OfLong {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol sun$reflect$ConstructorAccessor : JavaObject {
}

public class sun$reflect$ConstructorAccessor$ : java$lang$Object$, sun$reflect$ConstructorAccessor {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$time$LocalTime : JavaObject {
}

public class java$time$LocalTime$ : java$lang$Object$, java$time$LocalTime {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$nio$channels$ServerSocketChannel : JavaObject {
}

public class java$nio$channels$ServerSocketChannel$ : java$lang$Object$, java$nio$channels$ServerSocketChannel {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$text$AttributedCharacterIterator$Attribute : JavaObject {
}

public class java$text$AttributedCharacterIterator$Attribute$ : java$lang$Object$, java$text$AttributedCharacterIterator$Attribute {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

public protocol java$util$Base64$Decoder : JavaObject {
}

public class java$util$Base64$Decoder$ : java$lang$Object$, java$util$Base64$Decoder {
    public required init?(jobj: jobject) { super.init(jobj: jobj) }

}

